<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="起因开始于 记录调试Vulkan程序打印奇怪日志的问题\n这篇文章详细展开了 WinDbg 的基础用法。\n"><title>WinDbg的初级用法</title><link rel=canonical href=https://crackhopper.github.io/2025/11/17/windbg%E7%9A%84%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/><link rel=stylesheet href=/scss/style.min.4d36f8dc1fd48129e1635deb4b8eb2870fa09474f7280c4cb606d40b2526994b.css><meta property='og:title' content="WinDbg的初级用法"><meta property='og:description' content="起因开始于 记录调试Vulkan程序打印奇怪日志的问题\n这篇文章详细展开了 WinDbg 的基础用法。\n"><meta property='og:url' content='https://crackhopper.github.io/2025/11/17/windbg%E7%9A%84%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/'><meta property='og:site_name' content='crackhopper的技术博客'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='windbg'><meta property='article:tag' content='二进制'><meta property='article:tag' content='调试'><meta property='article:published_time' content='2025-11-17T22:05:20+08:00'><meta property='article:modified_time' content='2025-11-17T22:05:20+08:00'><meta name=twitter:title content="WinDbg的初级用法"><meta name=twitter:description content="起因开始于 记录调试Vulkan程序打印奇怪日志的问题\n这篇文章详细展开了 WinDbg 的基础用法。\n"><link rel=stylesheet href=/css/custom.css></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_337fe2b325ec916d.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>crackhopper的技术博客</a></h1><h2 class=site-description>C++, Graphics, Game, AI/ML</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>文章</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于我</span></a></li><li><a href=/projects/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>项目</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#正文开始>正文开始</a><ul><li><a href=#简要介绍>简要介绍</a></li><li><a href=#安装与启动-windbg>安装与启动 WinDbg</a></li><li><a href=#启动调试>启动调试</a></li><li><a href=#时间旅行调试-ttd-time-travel-debugging>时间旅行调试 (TTD, Time Travel Debugging)</a></li><li><a href=#常用寄存器>常用寄存器</a></li><li><a href=#内存的引用>内存的引用</a></li><li><a href=#指令集sseavx简介>指令集（SSE/AVX）简介</a></li><li><a href=#常用指令>常用指令</a><ul><li><a href=#first-of-all>First of All</a></li><li><a href=#执行控制和断点>执行控制和断点</a></li><li><a href=#内存检查>内存检查</a></li><li><a href=#上下文与符号信息-context--symbol>上下文与符号信息 (Context & Symbol)</a></li></ul></li><li><a href=#断点设定示例>断点设定示例</a><ul><li><a href=#createfilea-和-createfilew-函数>CreateFileA 和 CreateFileW 函数</a></li><li><a href=#createfile函数参数>CreateFile函数参数</a></li><li><a href=#windows-x64调用约定>Windows x64调用约定</a></li></ul></li></ul></li><li><a href=#实操演练>实操演练</a><ul><li><a href=#初始页面讲解>初始页面讲解</a><ul><li><a href=#模块加载信息>模块加载信息</a><ul><li><a href=#主程序>主程序</a></li><li><a href=#其他模块简要介绍>其他模块简要介绍</a></li><li><a href=#为什么是这个加载顺序>为什么是这个加载顺序？</a></li></ul></li><li><a href=#ui配置>UI配置</a></li><li><a href=#第一个中断>第一个中断</a></li><li><a href=#命令窗口-0000>命令窗口 <code>0:000></code></a></li></ul></li><li><a href=#添加断点>添加断点</a></li><li><a href=#中断到createfile>中断到CreateFile</a><ul><li><a href=#寄存器观察>寄存器观察</a><ul><li><a href=#易失性和非易失性寄存器>易失性和非易失性寄存器</a></li><li><a href=#状态和段寄存器不太常用>状态和段寄存器（不太常用）</a></li></ul></li><li><a href=#更多函数参数的观察>更多函数参数的观察</a><ul><li><a href=#关于-db-dw-dd-dq>关于 <code>db, dw, dd, dq</code></a></li><li><a href=#关于寄存器>关于寄存器</a></li><li><a href=#栈上参数>栈上参数</a></li></ul></li></ul></li><li><a href=#函数代码的观察>函数代码的观察</a><ul><li><ul><li><a href=#指令的解读-ff25ea270300>指令的解读 <code>ff25ea270300</code></a></li><li><a href=#真正的代码位置>真正的代码位置</a></li><li><a href=#函数地址和符号>函数地址和符号</a></li><li><a href=#符号和地址如何关联的呢>符号和地址如何关联的呢？</a></li><li><a href=#如何知道我们自己程序的调试符号表有没有加载><strong>如何知道我们自己程序的调试符号表有没有加载？</strong></a></li><li><a href=#如何查看具体汇编代码指令方式><strong>如何查看具体汇编代码</strong>（指令方式）</a></li><li><a href=#如何查看具体汇编代码ui方式><strong>如何查看具体汇编代码</strong>（UI方式）</a></li></ul></li></ul></li></ul></li><li><a href=#ttd指令>TTD指令</a></li><li><a href=#todo-未来有空再进一步研究>TODO: (未来有空再进一步研究)</a></li></ul></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/2025/11/17/windbg%E7%9A%84%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/>WinDbg的初级用法</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-11-17T22:05:20+08:00>Nov 17, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>11 minute read</time></div></footer></div></header><section class=article-content><p>起因开始于 <a class=link href=/2025/11/17/%E8%AE%B0%E5%BD%95%E8%B0%83%E8%AF%95vulkan%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8D%B0%E5%A5%87%E6%80%AA%E6%97%A5%E5%BF%97%E7%9A%84%E9%97%AE%E9%A2%98/>记录调试Vulkan程序打印奇怪日志的问题</a></p><p>这篇文章详细展开了 WinDbg 的基础用法。</p><h1 id=正文开始>正文开始</h1><h2 id=简要介绍>简要介绍</h2><p><strong>WinDbg</strong>（Windows Debugger）是 Microsoft 提供的强大调试工具，广泛应用于 Windows 系统的内核调试、用户模式调试、崩溃转储分析等场景。它适用于调试应用程序、驱动程序、操作系统内核等各种不同类型的程序。WinDbg 支持命令行界面，并且具有图形用户界面（WinDbg Preview），它能够帮助开发人员和系统管理员诊断并修复系统崩溃或程序错误。</p><h2 id=安装与启动-windbg>安装与启动 WinDbg</h2><p>参考文档： <a class=link href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/ target=_blank rel=noopener>https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/</a></p><p>简单来说：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ps data-lang=ps><span style=display:flex><span><span style=color:#6639ba>winget</span> <span style=color:#6639ba>install</span> <span style=color:#6639ba>Microsoft.WinDbg</span>
</span></span></code></pre></td></tr></table></div></div><p>用windows的包管理器下载即可。（类似苹果的HomeBrew，windows下我一般除了 winget，还会用到 chocolate 和 scoop）</p><h2 id=启动调试>启动调试</h2><p>点击文件：</p><p><img src=/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763393136760.png loading=lazy alt=WinDbg的初级用法-1763393136760></p><p>选项介绍：</p><ul><li>Launch executable : 直接启动一个exe，并且中断到最开始的地方。</li><li>Launch executable (advanced) : 这个模式支持更多设置，包括运行参数(arguments)和运行目录(start directory) 。还支持 时间旅行调试 (Time Travel Debugging, TTD)</li><li>Attach to process: 附加到已经在运行的进程上进行调试。</li><li>Open dump file: 加载一个先前捕获的内存转储文件（crash dump）进行事后分析。</li><li>Open trace file: 加载一个先前记录的 时间旅行调试 (TTD) 跟踪文件进行回放和分析。</li></ul><p>我们这里选择 Launch executable ，选择要调试的vulkan程序即可。</p><h2 id=时间旅行调试-ttd-time-travel-debugging>时间旅行调试 (TTD, Time Travel Debugging)</h2><p>启动调试的时候，选择 <code>Launch executable(advanced)</code> 。并勾选开启 Time Travel Debugging</p><p>微软开发的一种革命性的调试技术。它允许开发者和逆向工程师<strong>记录</strong>一个进程的执行过程，然后像观看视频一样，对这个记录进行<strong>回放</strong>和<strong>反向调试</strong>。</p><div class=table-wrapper><table><thead><tr><th><strong>特点</strong></th><th><strong>描述</strong></th><th><strong>优势</strong></th></tr></thead><tbody><tr><td><strong>反向执行 (Reverse Execution)</strong></td><td>可以在程序的执行时间轴上<strong>向后移动</strong>。</td><td>能够轻松地回溯到程序状态发生损坏、或导致崩溃的那个瞬间之前，准确找出问题的根源。</td></tr><tr><td><strong>完整记录 (Full Recording)</strong></td><td>捕获了程序执行过程中的所有状态变化，包括 CPU 寄存器、内存读写等。</td><td>无需重现 Bug。一旦记录了 Bug 发生的过程，您可以无限次地回放和分析，而 Bug 不会再“跑掉”。</td></tr><tr><td><strong>可重复性 (Reproducibility)</strong></td><td>调试会话基于记录文件，而不是实时运行的程序。</td><td>调试过程是完全确定的，在不同的机器上、不同的时间点上分析结果始终一致，非常利于协作。</td></tr><tr><td><strong>高级查询 (Advanced Query)</strong></td><td>允许使用查询语言（如 Linq）来搜索整个执行历史记录。</td><td>可以快速找到“是谁最后写入了这个内存地址？”或“这个函数在哪里被调用过？”等复杂问题。</td></tr></tbody></table></div><p>非常好用，建议调试复杂问题的时候，先开启TTD录制一次。随后加载对应的trace文件。就可以用TTD调试了。在这个调试模式可以使用：</p><ul><li><code>g-</code> : 跳到上一个断点（所以把所有断点 disable 或者清空后，可以直接跳到开头）</li><li><code>p-</code> : 往回跳1个指令。</li></ul><h2 id=常用寄存器>常用寄存器</h2><div class=table-wrapper><table><thead><tr><th><strong>变量</strong></th><th><strong>含义 (x64)</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><code>@rcx</code>, <code>@rdx</code>, <code>@r8</code>, <code>@r9</code></td><td>通用寄存器 （易失性）</td><td>在windows x64下，函数调用前，这四个寄存器会保存函数调用的前4个参数。（使用的时候，可以不带 <code>@</code> 符号)</td></tr><tr><td><code>@ip</code></td><td>instruction pointer</td><td>指向下一个要执行的指令。通常配合查看汇编代码的时候。</td></tr><tr><td><code>@rsp</code></td><td>栈指针寄存器</td><td>总是指向栈顶的地址。（地址越低，越靠近栈顶；函数开始调用前，会移动栈顶指针向低地址，以准备足够的栈空间用来存储局部变量）</td></tr><tr><td><code>@r14, r15</code></td><td>通用寄存器（非易失性）</td><td>常用于标识当前函数的栈帧起始位置。</td></tr><tr><td><code>ymm0, ymm1</code></td><td>256位矢量寄存器</td><td>avx指令集中的寄存器。AVX（Advanced Vector Extensions）</td></tr></tbody></table></div><h2 id=内存的引用>内存的引用</h2><p>一般采用 <code>[ expression ]</code> 的方式引用一个内存地址。随后配合指令，决定读写的大小。</p><p><code>expression</code> 可以是：</p><ul><li>寄存器</li><li>寄存器 + 偏移</li><li>基址 + 索引 * 缩放 + 偏移</li><li>标号</li><li>常量</li><li>任意合法的组合</li></ul><p>注意，有些指令需要内存对齐。否则产生GP异常（General Protection Fault，通用保护异常）。比如SSE，AVX指令。</p><pre tabindex=0><code>movaps xmm0, [rax]   ; 需要 16 字节对齐，否则 #GP 异常
movdqa xmm1, [rax]   ; 需要 16 字节对齐
vmovaps ymm0, [rax]  ; rax 必须 32 字节对齐
</code></pre><h2 id=指令集sseavx简介>指令集（SSE/AVX）简介</h2><p>上一节中，提到的一些用比较特别寄存器的，都是扩展指令集的指令。这节简要介绍一些。</p><ul><li>SSE: Streaming SIMD Extensions 。Intel 在 <strong>1999 年</strong> 发布的 SIMD（Single Instruction Multiple Data）扩展。使用 <strong>128 位的 XMM 寄存器（xmm0–xmm15）</strong> ，提供浮点加速。通常需要对齐。</li><li>AVX: Advanced Vector Extensions 。Intel 在 <strong>2011 年</strong> 推出的 SSE 进化版。 使用 <strong>256 位 YMM 寄存器（ymm0–ymm15 / ymm31）</strong>。具备无需对齐的指令。</li></ul><p>更多高阶指令：</p><ul><li>AVX2（2013）： 整数 SIMD，Gather 指令，更强的向量整数操作（如 vpblendd、vpmulld）。</li><li>AVX-512（2016）：寄存器扩大到 <strong>512 位的 ZMM0–31</strong>。掩码寄存器（k0–k7），更丰富的数学指令（如 exp/log），分段化（Foundation / BW / VL / VNNI / IFMA 等）。应用：HPC（科学计算），AI 推理（VNNI），数据中心服务器（Xeon 里普遍支持）</li><li>VNNI（Vector Neural Network Instructions）： 属于 AVX-512 家族（也有 AVX2 版本）。专为 AI 推理优化：提供更快的 dot-product（点积）运算，用于 INT8/INT16 加速。</li><li>AMX（Advanced Matrix Extensions）(2021)：<strong>矩阵加速器</strong>，不是传统 SIMD 了。Tile 寄存器（矩阵寄存器）、Tile 配置指令、Tile DP（矩阵乘加）。</li></ul><p>这些跟处理器相关。通常消费级处理器，没有AMX。</p><h2 id=常用指令>常用指令</h2><h3 id=first-of-all>First of All</h3><p>用 <code>.hh &lt;x></code> 指令可以查看 <code>&lt;x></code> 指令的文档。</p><h3 id=执行控制和断点>执行控制和断点</h3><div class=table-wrapper><table><thead><tr><th><strong>命令</strong></th><th><strong>完整形式/别名</strong></th><th><strong>功能描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong><code>g</code></strong></td><td><code>go</code></td><td><strong>继续执行</strong>。程序将从当前位置继续运行直到遇到断点或退出。</td><td><code>g</code></td></tr><tr><td><strong><code>p</code></strong></td><td><code>step</code></td><td><strong>步过 (Step Over)</strong>。执行下一条指令。如果下一条是函数调用，则执行完整个函数再停下。</td><td><code>p</code></td></tr><tr><td><strong><code>t</code></strong></td><td><code>trace</code></td><td><strong>步入 (Step Into)</strong>。执行下一条指令。如果下一条是函数调用，则进入该函数内部并停在第一条指令。</td><td><code>t</code></td></tr><tr><td><strong><code>bp</code></strong></td><td><code>Set Breakpoint</code></td><td><strong>设置软件断点</strong>。</td><td><code>bp MyModule!MyFunction</code></td></tr><tr><td><strong><code>ba</code></strong></td><td><code>Set Access Breakpoint</code></td><td><strong>设置访问断点（硬件断点）</strong>。用于监视内存地址的读、写或执行。</td><td><code>ba w8 @rcx</code> (在 <code>@rcx</code> 地址上设置 8 字节的写访问断点)</td></tr><tr><td><strong><code>bl</code></strong></td><td><code>List Breakpoints</code></td><td><strong>列出</strong> 当前设置的所有断点。</td><td><code>bl</code></td></tr><tr><td><strong><code>bc</code></strong></td><td><code>Clear Breakpoints</code></td><td><strong>清除</strong> 指定编号的断点。</td><td><code>bc 0</code> (清除编号为 0 的断点)</td></tr><tr><td><strong><code>be</code></strong></td><td><code>Enable Breakpoints</code></td><td><strong>启用</strong> 指定编号的断点。</td><td><code>be 0</code></td></tr><tr><td><strong><code>bd</code></strong></td><td><code>Disable Breakpoints</code></td><td><strong>禁用</strong> 指定编号的断点。</td><td><code>bd 0</code></td></tr><tr><td>重中之重：</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><code>bp, ba</code> : 调试必备</li></ul><p>注意， <code>bl,bc,be,bd</code> 在UI上操作更方便。</p><h3 id=内存检查>内存检查</h3><div class=table-wrapper><table><thead><tr><th><strong>命令</strong></th><th><strong>数据类型</strong></th><th><strong>功能描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong><code>db</code></strong></td><td>Byte (字节)</td><td><strong>显示</strong> 字节数据 (1 字节/8 位)。同时显示十六进制和 ASCII 字符。</td><td><code>db 0x180000000</code></td></tr><tr><td><strong><code>dw</code></strong></td><td>Word (字)</td><td><strong>显示</strong> 字数据 (2 字节/16 位)。</td><td><code>dw @rcx</code></td></tr><tr><td><strong><code>dd</code></strong></td><td>Double-Word (双字)</td><td><strong>显示</strong> 双字数据 (4 字节/32 位)。</td><td><code>dd @rsp</code></td></tr><tr><td><strong><code>dq</code></strong></td><td>Quad-Word (四字)</td><td><strong>显示</strong> 四字数据 (8 字节/64 位)。<strong>x64 环境下最常用</strong>。</td><td><code>dq @rcx</code></td></tr><tr><td><strong><code>da</code></strong></td><td>ASCII String</td><td><strong>显示</strong> 内存中的 <strong>ASCII</strong> 字符串。</td><td><code>da @rdx</code></td></tr><tr><td><strong><code>du</code></strong></td><td>UNICODE String</td><td><strong>显示</strong> 内存中的 <strong>UNICODE</strong> (UTF-16) 字符串。</td><td><code>du @rcx</code></td></tr></tbody></table></div><h3 id=上下文与符号信息-context--symbol>上下文与符号信息 (Context & Symbol)</h3><div class=table-wrapper><table><thead><tr><th><strong>命令</strong></th><th><strong>别名</strong></th><th><strong>功能描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong><code>r</code></strong></td><td><code>registers</code></td><td><strong>查看/修改</strong> 寄存器的值。</td><td><code>r</code> (查看所有) 或 <code>r rcx=0x123</code> (修改 <code>rcx</code>)</td></tr><tr><td><strong><code>k</code></strong></td><td><code>kb</code></td><td><strong>显示栈回溯 (Stack Backtrace)</strong>。这是最常用的调试命令之一。</td><td><code>k</code> 或 <code>kb</code> (后者会显示栈上前4个QWORD)</td></tr><tr><td><strong><code>lm</code></strong></td><td><code>list modules</code></td><td><strong>列出</strong> 当前加载的所有模块（DLL/EXE）。</td><td><code>lm</code> 或 <code>lm v</code> (显示详细信息)</td></tr><tr><td><strong><code>x</code></strong></td><td><code>examine symbols</code></td><td><strong>检查</strong> 指定模块内的符号（函数名、变量名）。</td><td><code>x MyModule!*</code> (列出 MyModule 的所有符号)</td></tr><tr><td><strong><code>?</code></strong></td><td><code>evaluate</code></td><td><strong>计算</strong> 表达式的值。</td><td><code>? 0x10 + @r8</code></td></tr><tr><td><code>lmv m</code></td><td></td><td>查看具体模块的详细信息</td><td><code>lmv m vulkan_1</code></td></tr></tbody></table></div><ul><li>用 <code>x</code> 指令，支持通配符。可以先用来查询模块中可以使用的符号。（有些带有pdb信息的，有些无pdb信息的仍然有导出库的符号）</li><li><code>r</code> 指令看寄存器的时候，可以指定格式。例如 <code>r ymm1:uq</code> 。具体参照文档。</li></ul><h2 id=断点设定示例>断点设定示例</h2><p>考虑在文件创建的时候打断点。</p><h3 id=createfilea-和-createfilew-函数>CreateFileA 和 CreateFileW 函数</h3><p>这两个是windows的api函数，用来创建文件。</p><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>CreateFileA (ANSI 版本)</strong></th><th><strong>CreateFileW (Unicode 版本)</strong></th></tr></thead><tbody><tr><td><strong>字符串类型</strong></td><td>接受 <strong>ANSI/多字节</strong> 字符串。</td><td>接受 <strong>Unicode</strong> (UTF-16) 字符串。</td></tr><tr><td><strong>应用场景</strong></td><td>主要用于<strong>较老</strong>或非 Unicode 环境的程序。</td><td><strong>现代 Windows 应用程序的主流</strong>，支持全球语言字符集。</td></tr><tr><td><strong>内部机制</strong></td><td>需要在内部将 ANSI 转换为 Unicode 才能交给系统内核处理，有轻微性能开销。</td><td>直接使用 Unicode，无需转换，<strong>效率更高，更可靠</strong>。</td></tr></tbody></table></div><h3 id=createfile函数参数>CreateFile函数参数</h3><p>两个函数调用的参数是类似的：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>HANDLE <span style=color:#6639ba>CreateFileW</span><span style=color:#1f2328>(</span>
</span></span><span style=display:flex><span>  LPCWSTR               lpFileName<span style=color:#1f2328>,</span>           <span style=color:#0550ae>//</span> <span style=color:#0550ae>1.</span> <span style=color:#f6f8fa;background-color:#82071e>文件名</span> <span style=color:#1f2328>(</span>W版本使用 LPCWSTR<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  DWORD                 dwDesiredAccess<span style=color:#1f2328>,</span>      <span style=color:#57606a>// 2. 期望的访问权限
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwShareMode<span style=color:#1f2328>,</span>          <span style=color:#57606a>// 3. 文件共享模式
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  LPSECURITY_ATTRIBUTES lpSecurityAttributes<span style=color:#1f2328>,</span> <span style=color:#57606a>// 4. 安全属性
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwCreationDisposition<span style=color:#1f2328>,</span><span style=color:#57606a>// 5. 创建/打开的方式
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwFlagsAndAttributes<span style=color:#1f2328>,</span> <span style=color:#57606a>// 6. 文件属性和标志
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  HANDLE                hTemplateFile         <span style=color:#57606a>// 7. 模板文件句柄
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>期望的访问权限：主要传入 <code>GENERIC_READ|GENERIC_WRITE|GENERIC_EXECUTE|0</code></li><li>文件共享模式: 决定其他程序是否可以打开同一个文件。 <code>0|FILE_SHARED_READ|FILE_SHARED_WRITE|FILE_SHARED_DELETE</code></li><li>安全属性: 主要是权限控制</li><li>创建/打开的方式 : 当文件存在或者不存在的时候如何处理。<strong>非常关键</strong><ul><li><code>CREATE_NEW</code> ：创建新文件。如果文件已存在，则失败。</li><li><code>CREATE_ALWAYS</code> ：创建新文件。如果文件已存在，则覆盖并清空。</li><li><code>OPEN_EXISTING</code> ：打开现有文件。如果文件不存在则失败。</li><li><code>OPEN_ALWAYS</code> ：打开现有文件。如果文件不存在则创建。</li></ul></li><li>文件属性和标志：设置隐藏文件、只读文件等等。</li><li>模板文件句柄：按照模板文件来创建文件，继承其属性。</li></ul><h3 id=windows-x64调用约定>Windows x64调用约定</h3><p>在 Windows x64 架构下，微软规定使用 <strong>Fastcall</strong> 调用约定，它要求函数的前四个非浮点数参数通过特定的通用寄存器传递，而不是通过栈传递。</p><div class=table-wrapper><table><thead><tr><th><strong>参数序号</strong></th><th><strong>寄存器</strong></th><th><strong>作用</strong></th><th><strong>WinDbg 伪寄存器</strong></th></tr></thead><tbody><tr><td><strong>第一个参数 (Param 1)</strong></td><td><strong><code>RCX</code></strong></td><td><strong>通用寄存器 C</strong></td><td><code>@rcx</code></td></tr><tr><td><strong>第二个参数 (Param 2)</strong></td><td><strong><code>RDX</code></strong></td><td><strong>通用寄存器 D</strong></td><td><code>@rdx</code></td></tr><tr><td><strong>第三个参数 (Param 3)</strong></td><td><strong><code>R8</code></strong></td><td><strong>通用寄存器 R8</strong></td><td><code>@r8</code></td></tr><tr><td><strong>第四个参数 (Param 4)</strong></td><td><strong><code>R9</code></strong></td><td><strong>通用寄存器 R9</strong></td><td><code>@r9</code></td></tr><tr><td><strong>第五个及后续参数</strong></td><td><strong>栈 (Stack)</strong></td><td>从栈上获取参数</td><td><code>dq @rsp + 0x28</code> / <code>dq @rsp + 0x30</code> 等</td></tr><tr><td>回顾 <code>CreateFileW</code> 的前四个参数：</td><td></td><td></td><td></td></tr></tbody></table></div><ol><li><code>lpFileName</code> $\rightarrow$ <strong><code>@rcx</code></strong> (文件名指针)</li><li><code>dwDesiredAccess</code> $\rightarrow$ <strong><code>@rdx</code></strong> (访问权限 DWORD)</li><li><code>dwShareMode</code> $\rightarrow$ <strong><code>@r8</code></strong> (共享模式 DWORD)</li><li><code>lpSecurityAttributes</code> $\rightarrow$ <strong><code>@r9</code></strong> (安全属性指针)</li></ol><p>因此，您在 WinDbg 中查看参数时，总是使用 <code>du @rcx</code> 或 <code>? @rdx</code> 等命令。</p><h1 id=实操演练>实操演练</h1><p>我们的目标是找到异常写日志的代码。选择一个合适的方式，加载exe启动后，看到如下页面。</p><p>启动对应exe：
<img src=/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763395254791.png loading=lazy alt=WinDbg的初级用法-1763395254791></p><h2 id=初始页面讲解>初始页面讲解</h2><h3 id=模块加载信息>模块加载信息</h3><h4 id=主程序>主程序</h4><pre tabindex=0><code>ModLoad: 00007ff7`f70b0000 00007ff7`f70fa000   image00007ff7`f70b0000
</code></pre><p>加载主程序。名称image后面跟着的是虚拟内存地址，意味着程序被加载到这个内存位置上。主程序永远是第一个被加载的。</p><p>查看主程序模块：</p><pre tabindex=0><code>0:000&gt; lm a 00007ff7`f70b0000
Browse full module list
start             end                 module name
00007ff7`f70b0000 00007ff7`f70fa000   VulkanGLFWDemo C (no symbols)   
</code></pre><ul><li><strong><code>lm</code> (List Modules):</strong> 基本命令，用于显示模块信息。</li><li><strong><code>a</code> (Address):</strong> 这是一个子命令或限定符，意思是**&ldquo;按地址过滤&rdquo;**。它告诉 WinDbg <strong>只显示包含这个特定地址的模块</strong>。</li><li>地址用 $`$ 分隔 : 分隔内存地址的高位和低位部分是为了<strong>提高可读性和清晰度</strong>，尤其是在处理 <strong>64 位 (8 字节)</strong> 地址时 。</li></ul><h4 id=其他模块简要介绍>其他模块简要介绍</h4><ul><li><code>ntdll.dll</code> : <strong>Windows NT 层的核心库</strong>。它提供用户模式程序到内核模式驱动程序和函数的接口，是所有 Windows 进程的基石。</li><li><code>KERNEL32.DLL</code> : 提供基本的 <strong>操作系统服务</strong>，如内存管理、进程和线程管理、文件 I/O 等。它是 Windows 编程中最重要的 DLL 之一。</li><li><code>KERNELBASE.dll</code> : 包含 <code>KERNEL32.DLL</code> 的许多底层函数实现。在现代 Windows 中，许多核心 API 调用被路由到这里。</li><li><code>USER32.dll</code> : 负责管理用户界面元素，如<strong>窗口、菜单、对话框</strong>等。</li><li><code>win32u.dll</code> : 包含底层用户模式的图形和窗口管理函数，是 <code>USER32.dll</code> 和 <code>GDI32.dll</code> 的<strong>更底层实现</strong>。</li><li><code>vulkan-1.dll</code> : 这是一个<strong>图形 API 库</strong>。它表明你的程序正在使用 <strong>Vulkan</strong> 图形 API，这通常用于高性能的 3D 游戏或渲染应用。</li></ul><h4 id=为什么是这个加载顺序>为什么是这个加载顺序？</h4><p>任何 Windows 进程启动，都需要两个最基本的 DLL 来与内核交互和管理自身。因此，它们总是最先被加载，并且顺序非常固定：</p><div class=table-wrapper><table><thead><tr><th><strong>顺序</strong></th><th><strong>模块</strong></th><th><strong>职责和原因</strong></th></tr></thead><tbody><tr><td><strong>1.</strong></td><td><strong>主程序 (<code>VulkanGLFWDemo C</code> / <code>image...</code>)</strong></td><td><strong>原因：</strong> 它是被执行的文件。加载器首先将 EXE 文件映射到进程的虚拟地址空间，并开始解析它的导入表（Import Table）。</td></tr><tr><td><strong>2.</strong></td><td><strong><code>ntdll.dll</code></strong></td><td><strong>原因：</strong> 这是所有用户模式代码访问内核服务（<code>ntoskrnl.exe</code>）的<strong>唯一网关</strong>。任何更高层的 DLL，包括 <code>KERNEL32.DLL</code>，都必须通过 <code>ntdll.dll</code> 来工作。它必须在其他所有依赖内核的模块之前加载。</td></tr><tr><td><strong>3.</strong></td><td><strong><code>KERNEL32.DLL</code></strong></td><td><strong>原因：</strong> 它是提供进程、内存、文件等基本 API 的高级层。它自身依赖于 <code>ntdll.dll</code>。</td></tr><tr><td><strong>4.</strong></td><td><strong><code>KERNELBASE.dll</code></strong></td><td><strong>原因：</strong> 它是 <code>KERNEL32.DLL</code> 的底层实现库。现代 Windows 将 <code>KERNEL32</code> 的许多实际功能移到了 <code>KERNELBASE</code> 中，以提高效率和隔离性。它紧随其后的加载，是为了满足 <code>KERNEL32</code> 启动时的依赖。</td></tr><tr><td>在基础的系统服务加载完成后，加载器会继续加载主程序<strong>导入表</strong>中列出的下一组核心依赖项，通常是与用户界面 (UI) 相关的库：</td><td></td><td></td></tr></tbody></table></div><div class=table-wrapper><table><thead><tr><th><strong>顺序</strong></th><th><strong>模块</strong></th><th><strong>职责和原因</strong></th></tr></thead><tbody><tr><td><strong>5.</strong></td><td><strong><code>USER32.dll</code></strong></td><td><strong>原因：</strong> 主程序是一个图形应用（基于 <code>Vulkan</code>），所以它需要窗口管理 API。<code>USER32.dll</code> 是管理窗口、消息和对话框的关键。</td></tr><tr><td><strong>6.</strong></td><td><strong><code>win32u.dll</code></strong></td><td><strong>原因：</strong> 类似 <code>KERNELBASE</code> 和 <code>KERNEL32</code> 的关系，<code>win32u.dll</code> 是 <code>USER32.dll</code> 的底层实现，用于处理用户模式和内核模式之间的用户界面切换。它在 <code>USER32</code> 之后加载，因为它被 <code>USER32</code> 所依赖。</td></tr><tr><td><strong>7.</strong></td><td><strong><code>GDI32.dll</code></strong></td><td><strong>原因：</strong> 图形设备接口库，负责绘图、字体等。它通常是与 <code>USER32</code> 捆绑在一起加载的，用于提供图形界面所需的基本绘制能力。</td></tr></tbody></table></div><h3 id=ui配置>UI配置</h3><p>页面中的View选项可以调出很多好用的窗口。根据自己的需求配置即可。</p><p><img src=/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763519564490.png loading=lazy alt=WinDbg的初级用法-1763519564490></p><p>随后可以拖拽窗口，dock到自己喜欢的位置上。</p><h3 id=第一个中断>第一个中断</h3><pre tabindex=0><code>(4d30.26a4): Break instruction exception - code 80000003 (first chance)
ntdll!LdrpDoDebuggerBreak+0x35:
00007ff8`9503f5fd cc              int     3
</code></pre><ul><li>进程线程信息：<ul><li><strong><code>4d30</code></strong>: 进程 ID (PID)，十六进制表示。</li><li><strong><code>26a4</code></strong>: 线程 ID (TID)，十六进制表示。</li></ul></li><li>异常类型和状态：<ul><li><strong><code>Break instruction exception</code></strong>: <strong>异常类型：</strong> <strong>中断指令异常</strong>。这意味着 CPU 遇到了一个专门用于触发调试中断的指令。</li><li>code 80000003： <strong>异常代码：</strong> 这是 Windows 中 <strong>硬编码断点</strong>（Hardcoded Breakpoint）的异常代码。这个代码通常是由 <code>int 3</code>（汇编指令）触发的。在 Windows 进程启动或调试器接管时，系统会故意执行这个指令，以确保调试器能在程序真正开始运行前获得控制权。</li></ul></li><li>暂停位置：<ul><li><strong><code>ntdll!LdrpDoDebuggerBreak+0x35</code></strong>: <strong>模块与函数：</strong> 程序当前暂停在 <code>ntdll.dll</code> 模块中的 <code>LdrpDoDebuggerBreak</code> 函数内，偏移量为 <code>+0x35</code>。</li><li><code>00007ff8`9503f5fd</code> : <strong>内存地址：</strong> 异常发生的具体指令地址。</li><li><code>cc</code> 机器码。对应的汇编为 <code>int 3</code></li></ul></li></ul><h3 id=命令窗口-0000>命令窗口 <code>0:000></code></h3><p>命令提示符格式: <code>P:T></code></p><ul><li>P: 代表正在调试的处理器编号（CPU编号）。</li><li>T: 代表正在调试的线程编号</li></ul><p>命令窗口后面可以输出上面我们介绍过的调试指令。</p><h2 id=添加断点>添加断点</h2><p>命令行里输入如下命令</p><pre tabindex=0><code>bp kernel32!CreateFileA;
bp kernel32!CreateFileW;
</code></pre><p>右下角面板可以打开 Breakpoint 选项卡：
<img src=/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763396928280.png loading=lazy alt=WinDbg的初级用法-1763396928280></p><p>随后可以输入命令：</p><pre tabindex=0><code>g
</code></pre><p>启动程序运行。</p><p>注意，断点另一个常见的用法是，后面接中断触发后执行的指令，比如：</p><pre tabindex=0><code>bp kernel32!CreateFileW &#34;du rcx;&#34;
</code></pre><p>这个断点中断后，会以 unicode字符串的方式打印 rcx指针指向的地址。这是非常常用的技巧。</p><h2 id=中断到createfile>中断到CreateFile</h2><p>下面进入我们第一次中断的情况：
<img src=/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763397056640.png loading=lazy alt=WinDbg的初级用法-1763397056640></p><h3 id=寄存器观察>寄存器观察</h3><pre tabindex=0><code>0:000&gt; r
rax=000000000000005c rbx=0000000000000000 rcx=00000073ac18c1b0
rdx=0000000080000000 rsi=0000022a13050f00 rdi=000000000000005c
rip=00007ff893b970f0 rsp=00000073ac18c168 rbp=00000073ac18c270
 r8=0000000000000001  r9=0000000000000000 r10=0000022a13050f5c
r11=00000073ac18c1b0 r12=0000000000000000 r13=00000073ac18c310
r14=0000000000000000 r15=00000073ac18c1b0
iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
KERNEL32!CreateFileW:
00007ff8`93b970f0 ff25ea270300    jmp     qword ptr [KERNEL32!_imp_CreateFileW (00007ff8`93bc98e0)] ds:00007ff8`93bc98e0={KERNELBASE!CreateFileW (00007ff8`922f3ac0)}
</code></pre><p>回忆API接口：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>HANDLE <span style=color:#6639ba>CreateFileW</span><span style=color:#1f2328>(</span>
</span></span><span style=display:flex><span>  LPCWSTR               lpFileName<span style=color:#1f2328>,</span>           <span style=color:#0550ae>//</span> <span style=color:#0550ae>1.</span> <span style=color:#f6f8fa;background-color:#82071e>文件名</span> <span style=color:#1f2328>(</span>W版本使用 LPCWSTR<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  DWORD                 dwDesiredAccess<span style=color:#1f2328>,</span>      <span style=color:#57606a>// 2. 期望的访问权限
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwShareMode<span style=color:#1f2328>,</span>          <span style=color:#57606a>// 3. 文件共享模式
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  LPSECURITY_ATTRIBUTES lpSecurityAttributes<span style=color:#1f2328>,</span> <span style=color:#57606a>// 4. 安全属性
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwCreationDisposition<span style=color:#1f2328>,</span><span style=color:#57606a>// 5. 创建/打开的方式
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwFlagsAndAttributes<span style=color:#1f2328>,</span> <span style=color:#57606a>// 6. 文件属性和标志
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  HANDLE                hTemplateFile         <span style=color:#57606a>// 7. 模板文件句柄
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><p>函数入参：</p><ul><li><code>rcx</code> : 第一个参数。<code>lpFileName</code> (文件名地址)</li><li><code>rdx</code> : 第二个参数。<code>dwDesiredAccess</code> (期望访问权限) 。$0x80000000$ 对应 <code>GENERIC_READ</code>。这表示程序<strong>只请求读取权限</strong>。</li><li><code>r8</code>: 第三个参数： <code>dwShareMode</code> (共享模式)。 <code>0x1</code> 对应 <code>FILE_SHARE_READ</code>。这意味着其他进程在文件打开时<strong>可以同时拥有读取权限</strong>。</li><li><code>r9</code>: 第四个参数： <code>lpSecurityAttributes</code> (安全属性) 。0代表不使用安全属性。</li></ul><p>函数返回：</p><ul><li><code>rax</code> : <strong>返回值寄存器</strong> 。 在调用前，<code>RAX</code> 的值不确定。</li></ul><p>控制/指针寄存器:</p><ul><li><code>rip</code> : <strong>Instruction Pointer (指令指针)</strong>。指向当前 CPU 正在执行的下一条指令的地址，即 <code>KERNEL32!CreateFileW</code> 的入口点。</li><li><code>rsp</code> : <strong>Stack Pointer (栈指针)</strong>。指向当前线程栈的顶部。</li><li><code>rbp</code> : <strong>Base Pointer (基址指针)</strong>。通常用于标记当前函数栈帧的底部。</li></ul><h4 id=易失性和非易失性寄存器>易失性和非易失性寄存器</h4><ul><li><code>rbx</code> : <strong>非易失性（Non-Volatile）寄存器</strong>，也称为<strong>被调用者保存（Callee-Saved）</strong> 寄存器。程序员和编译器通常用 $RBX$ 来存储在整个函数执行过程中需要保持不变的 <strong>重要本地变量</strong>或 <strong>指针</strong> 。</li><li><code>rsi/rdi</code> : 同上。在旧的 x86 架构中，它们传统上用作源索引（Source Index）和目标索引（Destination Index），常用于字符串和内存块操作。x64架构中，则类似 <code>rbx</code> 。</li><li>同样非易失性寄存器有： <code>rbx, rbp, rsi, rdi, r12, r13, r14, r15</code></li><li>而易失性寄存器有： <code>rcx, rdx,r8,r9 r10, r11</code></li></ul><h4 id=状态和段寄存器不太常用>状态和段寄存器（不太常用）</h4><p>状态和段寄存器解读：</p><pre tabindex=0><code>iopl=0         nv up ei pl zr na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
</code></pre><p><strong><code>iopl=0</code></strong></p><ul><li><strong>含义：</strong> <strong>I/O Privilege Level (I/O 特权级别)</strong>。这是一个 2 位的字段，用于控制当前代码是否可以直接执行 I/O 指令。</li><li><strong>值：</strong> $0$ 是最高的特权级别（通常是内核模式，Ring 0）。</li></ul><p><strong>nv &mldr;.</strong></p><ul><li>含义 <strong>RFLAGS</strong> (Registers Flags)，它包含了控制 CPU 操作和指示上次运算结果的各种标志位。</li></ul><div class=table-wrapper><table><thead><tr><th><strong>缩写</strong></th><th><strong>含义</strong></th><th><strong>状态</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>nv</strong></td><td><strong>Overflow Flag</strong></td><td><strong>nv</strong> (No Overflow)</td><td>上一次运算没有发生溢出。</td></tr><tr><td><strong>up</strong></td><td><strong>Direction Flag</strong></td><td><strong>up</strong> (Up)</td><td>字符串操作（如移动数据）的方向是从低地址到高地址（递增）。</td></tr><tr><td><strong>ei</strong></td><td><strong>Interrupt Enable Flag</strong></td><td><strong>ei</strong> (Enable Interrupts)</td><td>CPU <strong>允许</strong>接收外部可屏蔽中断信号。</td></tr><tr><td><strong>pl</strong></td><td><strong>Sign Flag</strong></td><td><strong>pl</strong> (Positive)</td><td>上一次算术运算的结果是非负数（或零）。</td></tr><tr><td><strong>zr</strong></td><td><strong>Zero Flag</strong></td><td><strong>zr</strong> (Zero)</td><td>上一次算术或逻辑运算的结果是<strong>零</strong>。</td></tr><tr><td><strong>na</strong></td><td><strong>Auxiliary Carry Flag</strong></td><td><strong>na</strong> (Not Applicable)</td><td>辅助进位标志，主要用于 BCD (Binary-Coded Decimal) 运算，通常不显示具体状态。</td></tr><tr><td><strong>po</strong></td><td><strong>Parity Flag</strong></td><td><strong>po</strong> (Parity Odd)</td><td>上一次运算结果的低 8 位中，置位（1）的个数是奇数。</td></tr><tr><td><strong>nc</strong></td><td><strong>Carry Flag</strong></td><td><strong>nc</strong> (No Carry)</td><td>上一次算术运算没有产生进位或借位。</td></tr><tr><td><strong>cs=0033 &mldr;</strong></td><td></td><td></td><td></td></tr></tbody></table></div><ul><li>段寄存器（Segment Registers）。x64架构中，主要用于定义<strong>特权级别</strong>和访问一些特殊结构（如线程本地存储）。在x86架构中，段寄存器主要是辅助地址选择。</li></ul><div class=table-wrapper><table><thead><tr><th><strong>寄存器</strong></th><th><strong>值</strong></th><th><strong>含义</strong></th><th><strong>解释 (x64 Windows)</strong></th></tr></thead><tbody><tr><td><strong>cs</strong></td><td><code>0033</code></td><td><strong>Code Segment</strong></td><td>代码段。段选择子 $0x33$ 对应于**用户模式（User Mode, Ring 3）**代码。</td></tr><tr><td><strong>ss</strong></td><td><code>002b</code></td><td><strong>Stack Segment</strong></td><td>栈段。段选择子 $0x2B$ 对应于**用户模式（User Mode, Ring 3）**数据。</td></tr><tr><td><strong>ds</strong></td><td><code>002b</code></td><td><strong>Data Segment</strong></td><td>数据段。与 SS 相同，对应于用户模式数据。</td></tr><tr><td><strong>es</strong></td><td><code>002b</code></td><td><strong>Extra Segment</strong></td><td>附加段。与 SS/DS 相同，对应于用户模式数据。</td></tr><tr><td><strong>fs</strong></td><td><code>0053</code></td><td><strong>FS Segment</strong></td><td><strong>特殊用途</strong>。在 64 位 Windows 中，$FS$ 寄存器指向<strong>线程信息块 (TEB)</strong>，用于访问线程特定的数据（如异常处理、栈限制等）。</td></tr><tr><td><strong>gs</strong></td><td><code>002b</code></td><td><strong>GS Segment</strong></td><td><strong>特殊用途</strong>。在 64 位 Windows 中，$GS$ 寄存器通常指向 <strong>KPCR (内核处理器控制区)</strong>，但用户模式下它的使用较少或被重定义。这里的值 $0x2B$ 可能只是一个占位符。</td></tr></tbody></table></div><h3 id=更多函数参数的观察>更多函数参数的观察</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>HANDLE <span style=color:#6639ba>CreateFileW</span><span style=color:#1f2328>(</span>
</span></span><span style=display:flex><span>  LPCWSTR               lpFileName<span style=color:#1f2328>,</span>           <span style=color:#0550ae>//</span> <span style=color:#0550ae>1.</span> <span style=color:#f6f8fa;background-color:#82071e>文件名</span> <span style=color:#1f2328>(</span>W版本使用 LPCWSTR<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>  DWORD                 dwDesiredAccess<span style=color:#1f2328>,</span>      <span style=color:#57606a>// 2. 期望的访问权限
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwShareMode<span style=color:#1f2328>,</span>          <span style=color:#57606a>// 3. 文件共享模式
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  LPSECURITY_ATTRIBUTES lpSecurityAttributes<span style=color:#1f2328>,</span> <span style=color:#57606a>// 4. 安全属性
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwCreationDisposition<span style=color:#1f2328>,</span><span style=color:#57606a>// 5. 创建/打开的方式
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  DWORD                 dwFlagsAndAttributes<span style=color:#1f2328>,</span> <span style=color:#57606a>// 6. 文件属性和标志
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>  HANDLE                hTemplateFile         <span style=color:#57606a>// 7. 模板文件句柄
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><ol><li><code>lpFileName</code> 下面的值显示为一个字符串。</li></ol></li></ul><pre tabindex=0><code>du @rcx
00000073`ac18c1b0  &#34;C:\WINDOWS\System32\DriverStore\&#34;
00000073`ac18c1f0  &#34;FileRepository\nvmi.inf_amd64_c6&#34;
00000073`ac18c230  &#34;ae241e95feb82d\nv-vk64.json&#34;
</code></pre><ul><li><ol start=2><li><code>dwDesiredAccess</code> : 注意，不能用 dw, db等指令，这些指令会解析参数为地址。如果是直接看寄存器的值，用r指令。下面的值显示为 <code>GENERIC_READ</code></li></ol></li></ul><pre tabindex=0><code>0:000&gt; r @rdx
rdx=0000000080000000
</code></pre><ul><li><ol start=3><li><code>dwShareMode</code> ： <code>r @r8</code> 结果为 <code>0x1</code> 即 <code>FILE_SHARE_READ</code></li></ol></li><li><ol start=4><li><code>lpSecurityAttributes</code> ： 先用r来看地址是否为空。 <code>r @r9</code> 。结果为0。</li></ol></li></ul><h4 id=关于-db-dw-dd-dq>关于 <code>db, dw, dd, dq</code></h4><ul><li><code>BYTE</code> : 8字节 。因此， <code>db</code> 会把内存按照8字节切分。</li><li><code>WORD</code> : 16字节</li><li><code>DWORD</code> : 32字节</li><li><code>QWORD</code> : 64字节</li></ul><h4 id=关于寄存器>关于寄存器</h4><p><strong>WinDbg 默认将寄存器名称视为其</strong>存储的 <strong>值</strong> 。因此比如 <code>dd rcx</code> 实际上将rcx的值作为dd的参数。dd的参数需要使用到一个地址，因此实际会解析 rcx 存储值所指向的地址，而不是rcx的值。</p><p>所以要注意： <strong>寄存器在 windbg 中被当作值来使用；而指令后面的参数常常作为地址来解析</strong></p><h4 id=栈上参数>栈上参数</h4><p>接着，对于5，6，7参数，都保存在栈上。对于栈上来说，约定有：</p><div class=table-wrapper><table><thead><tr><th><strong>相对地址（相对于 RSP）</strong></th><th><strong>长度 (字节)</strong></th><th><strong>含义</strong></th><th><strong>CreateFileW 参数</strong></th></tr></thead><tbody><tr><td>$\mathbf{RSP + 0x00}$</td><td>8</td><td><strong>返回地址</strong>（Return Address）</td><td>N/A</td></tr><tr><td><strong>&mdash; 32 字节阴影空间（Shadow Space）开始 &mdash;</strong></td><td></td><td></td><td></td></tr><tr><td>$\mathbf{RSP + 0x08}$</td><td>8</td><td>阴影空间槽位 1</td><td>（用于保存 $\text{RCX}$ 的副本）</td></tr><tr><td>$\mathbf{RSP + 0x10}$</td><td>8</td><td>阴影空间槽位 2</td><td>（用于保存 $\text{RDX}$ 的副本）</td></tr><tr><td>$\mathbf{RSP + 0x18}$</td><td>8</td><td>阴影空间槽位 3</td><td>（用于保存 $\text{R8}$ 的副本）</td></tr><tr><td>$\mathbf{RSP + 0x20}$</td><td>8</td><td>阴影空间槽位 4</td><td>（用于保存 $\text{R9}$ 的副本）</td></tr><tr><td><strong>&mdash; 32 字节阴影空间（Shadow Space）结束 &mdash;</strong></td><td></td><td></td><td></td></tr><tr><td>$\mathbf{RSP + 0x28}$</td><td>8</td><td><strong>第 5 个参数</strong></td><td><code>dwCreationDisposition</code></td></tr><tr><td>$\mathbf{RSP + 0x30}$</td><td>8</td><td><strong>第 6 个参数</strong></td><td><code>dwFlagsAndAttributes</code></td></tr><tr><td>$\mathbf{RSP + 0x38}$</td><td>8</td><td><strong>第 7 个参数</strong></td><td><code>hTemplateFile</code></td></tr></tbody></table></div><ul><li><p><strong>阴影空间</strong> : 其实是按照规范，所有参数都应该在栈上。不过windows会放入寄存器，因此这些栈上空间就相当于被留空了。（实际会保存副本）</p></li><li><p><strong>调用参数的存储位置</strong> (正偏移): 一般在 <code>rsp</code> 向高地址的方向去找，每次64位（即8byte）</p></li><li><p><strong>局部变量</strong> (负偏移): 一般在 rsp 向低地址的方向去找，每次64位。所以，第一个局部变量位置在 <code>rsp-0x08</code></p></li><li><ol start=5><li><code>dwCreateionDisposition</code> : dw 代表 <code>DWORD</code> ，因此用dd指令。容易看到第一个值为 <code>0x03</code> ，对应 <code>OPEN_EXISTING</code> ，即打开一个文件或设备。如果文件或设备不存在，函数将失败。</li></ol></li></ul><pre tabindex=0><code>0:000&gt; dd rsp+0x28
00000073`ac18c190  00000003 00000073 00000080 00000000
</code></pre><ul><li><ol start=6><li><code>dwCreateionDisposition</code> 从上一步的结果也容易看到这个参数为 <code>0x80</code> (注意，每64bit一个参数，因此 <code>00000073</code> 被跳过，随后是 <code>00000080</code> ，即 <code>0x80</code> ) ，对应值为 <code>FILE_ATTRIBUTE_NORMAL</code></li></ol></li><li><ol start=7><li><code>hTemplateFile</code> ，这个参数是HANDLE类型，通常是指针，在 64位程序中，就是8个字节，用dq命令来看。容易看到结果为空。</li></ol></li></ul><pre tabindex=0><code>0:000&gt; dq @rsp+0x38
00000073`ac18c1a0  00000000`00000000 00000000`00000000
</code></pre><h2 id=函数代码的观察>函数代码的观察</h2><p>断点处，我们可以看到</p><pre tabindex=0><code>KERNEL32!CreateFileW:
00007ff8`93b970f0 ff25ea270300    jmp     qword ptr [KERNEL32!_imp_CreateFileW (00007ff8`93bc98e0)] ds:00007ff8`93bc98e0={KERNELBASE!CreateFileW (00007ff8`922f3ac0)}
</code></pre><p>这个代表下一步要执行的指令。</p><ul><li><code>00007ff8`93b970f0</code> : 当前指令的地址。</li><li>指令 <code>ff25ea270300</code></li></ul><h4 id=指令的解读-ff25ea270300>指令的解读 <code>ff25ea270300</code></h4><p>拆分为:</p><ul><li><code>ff25</code> : <code>jmp qword ptr [RIP+displacement]</code> 这个操作码（OPCODE）。意思是，以当前 <code>RIP</code> （当前指令地址） 作为基地址，叠加 displacement 偏移量后，得到的地址按照QWORD解析，并作为地址进一步跳转到其指向的位置。（因此涉及到一次跳转）<ul><li>这个跳转通常叫做 IAT （操作系统和指令层都实现的概念：Import Address Table，导入地址表）</li><li>IAT这个技术用来做动态链接。提供一个间接层，程序在自己的内存空间设置一张指针表。那么通过IAT跳转指令 <code>jmp qword ptr</code> （间接跳转指令），就会进一步解码这个表中指向的地址，从而实现RIP的计算、解码加跳转。</li></ul></li><li><code>ea270300</code> ：4个byte，偏移量。因为是 Little Endian，所以代表的值为 <code>0x000327ea</code></li><li>计算间接跳转地址 <code>00007ff8`93b970f0</code> + <code>0x000327ea</code> = <code>00007ff8`93bc98e0</code> 。这个地址是IAT表的地址。因此按照里面的值，进一步查找地址，得到 <code>00007ff8`922f3ac0</code></li><li>显示区域的 <code>ds:00007ff8`93bc98e0={KERNELBASE!CreateFileW (00007ff8`922f3ac0)}</code> 显示的是IAT表项的地址。不过并不代表使用了段寄存器，而是反汇编工具的约定，是一个注释，表明它访问的是数据内存（IAT表）</li></ul><h4 id=真正的代码位置>真正的代码位置</h4><p>经过上面的分析，我们知道，真正的要执行的代码的位置在 <code>00007ff8`922f3ac0</code> ，其对应的符号表的符号为 <code>KERNELBASE!CreateFileW</code></p><h4 id=函数地址和符号>函数地址和符号</h4><p>函数地址在调试的时候，经常有与之相关的符号：</p><pre tabindex=0><code>0:000&gt; ln 00007ff8`922f3ac0
Browse module
Set bu breakpoint

(00007ff8`922f3ac0)   KERNELBASE!CreateFileW   |  (00007ff8`922f3ba0)   KERNELBASE!SleepEx
Exact matches:
</code></pre><p>可以看到地址对应的符号为 <code>KERNELBASE!CreateFileW</code></p><p>反之，也可以从符号找到对应的地址：</p><pre tabindex=0><code>0:000&gt; ln KERNELBASE!CreateFileW
Browse module
Set bu breakpoint

(00007ff8`922f3ac0)   KERNELBASE!CreateFileW   |  (00007ff8`922f3ba0)   KERNELBASE!SleepEx
Exact matches:
</code></pre><h4 id=符号和地址如何关联的呢>符号和地址如何关联的呢？</h4><p>答案：通过调试信息文件。windows自己加载了对应的调试信息。</p><pre tabindex=0><code>0:000&gt; lm m kernelbase
Browse full module list
start             end                 module name
00007ff8`922b0000 00007ff8`926a8000   KERNELBASE   (pdb symbols)          C:\ProgramData\Dbg\sym\kernelbase.pdb\8314490F996705E2CF4A8DF59DF277DB1\kernelbase.pdb
</code></pre><h4 id=如何知道我们自己程序的调试符号表有没有加载><strong>如何知道我们自己程序的调试符号表有没有加载？</strong></h4><pre tabindex=0><code>0:000&gt; lm m VulkanGLFWDemo
Browse full module list
start             end                 module name
00007ff7`f70b0000 00007ff7`f70fa000   VulkanGLFWDemo C (no symbols)   
</code></pre><p>可以看到没有加载。这是由于我们用的时release无符号版本的程序。（当然，release也可以配置生成pdb调试信息）</p><h4 id=如何查看具体汇编代码指令方式><strong>如何查看具体汇编代码</strong>（指令方式）</h4><pre tabindex=0><code>0:000&gt; u KERNELBASE!CreateFileW L10
KERNELBASE!CreateFileW:
00007ff8`922f3ac0 488bc4          mov     rax,rsp
00007ff8`922f3ac3 48895808        mov     qword ptr [rax+8],rbx
00007ff8`922f3ac7 48896810        mov     qword ptr [rax+10h],rbp
00007ff8`922f3acb 48897018        mov     qword ptr [rax+18h],rsi
00007ff8`922f3acf 48897820        mov     qword ptr [rax+20h],rdi
00007ff8`922f3ad3 4156            push    r14
00007ff8`922f3ad5 4883ec50        sub     rsp,50h
00007ff8`922f3ad9 448bb42480000000 mov     r14d,dword ptr [rsp+80h]
</code></pre><ul><li><code>u</code> ： unassemble，反汇编</li><li><code>L8</code> : 8行 。注意 L后面跟的是16进制数。</li></ul><p>下面来具体解释这里面的汇编干了什么</p><div class=table-wrapper><table><thead><tr><th><strong>地址</strong></th><th><strong>机器码</strong></th><th><strong>汇编指令</strong></th><th><strong>解释</strong></th><th><strong>目的</strong></th></tr></thead><tbody><tr><td>$\text{922f3ac0}$</td><td>$\text{488bc4}$</td><td><strong><code>mov rax,rsp</code></strong></td><td>将当前的栈指针 $\text{RSP}$ 的值备份到 $\text{RAX}$。</td><td>暂时保存栈指针，以便在 $\text{RSP}$ 被后续指令修改后，仍能通过 $\text{RAX}$ 访问原始栈帧（特别是阴影空间）。</td></tr><tr><td>$\text{922f3ac3}$</td><td>$\text{48895808}$</td><td><strong><code>mov qword ptr [rax+8],rbx</code></strong></td><td>将 $\text{RBX}$ 寄存器的值保存到 $\text{RAX}+0\text{x}08$ 处。</td><td>保存 <strong>非易失性</strong> 寄存器 $\text{RBX}$。该地址是 $\text{RSP}+0\text{x}08$，即<strong>阴影空间</strong>的第一个槽位。</td></tr><tr><td>$\text{922f3ac7}$</td><td>$\text{48896810}$</td><td><strong><code>mov qword ptr [rax+10h],rbp</code></strong></td><td>将 $\text{RBP}$ 的值保存到 $\text{RAX}+0\text{x}10$ 处。</td><td>保存 <strong>非易失性</strong> 寄存器 $\text{RBP}$（基址指针）。这是阴影空间的第二个槽位。</td></tr><tr><td>$\text{922f3acb}$</td><td>$\text{48897018}$</td><td><strong><code>mov qword ptr [rax+18h],rsi</code></strong></td><td>将 $\text{RSI}$ 的值保存到 $\text{RAX}+0\text{x}18$ 处。</td><td>保存 <strong>非易失性</strong> 寄存器 $\text{RSI}$。这是阴影空间的第三个槽位。</td></tr><tr><td>$\text{922f3acf}$</td><td>$\text{48897820}$</td><td><strong><code>mov qword ptr [rax+20h],rdi</code></strong></td><td>将 $\text{RDI}$ 的值保存到 $\text{RAX}+0\text{x}20$ 处。</td><td>保存 <strong>非易失性</strong> 寄存器 $\text{RDI}$。这是阴影空间的第四个槽位。</td></tr><tr><td>$\text{922f3ad3}$</td><td>$\text{4156}$</td><td><strong><code>push r14</code></strong></td><td>将 $\text{R14}$ 寄存器的值压入栈中。</td><td>保存 <strong>非易失性</strong> 寄存器 $\text{R14}$。这会使 $\text{RSP}$ 减去 $0\text{x}08$。</td></tr><tr><td>$\text{922f3ad5}$</td><td>$\text{4883ec50}$</td><td><strong><code>sub rsp,50h</code></strong></td><td>将 $\text{RSP}$ 减去 $0\text{x}50$ ($80$ 字节)。</td><td><strong>分配局部变量和后续函数调用所需的栈帧空间。</strong></td></tr><tr><td>$\text{922f3ad9}$</td><td>$\text{448bb42480000000}$</td><td><strong><code>mov r14d,dword ptr [rsp+80h]</code></strong></td><td>将 $\text{RSP} + 0\text{x}80$ 处的 4 字节数据加载到 $\text{R14D}$（$\text{R14}$ 的低 32 位）。</td><td>访问栈上参数或调用者栈帧中的局部变量。$0\text{x}80$ 是相对于<strong>调整后的 $\text{RSP}$</strong> 的大偏移量。</td></tr></tbody></table></div><p>注：</p><ul><li>类似 <code>r14d</code> ，还有 <code>eax, ebx, ecx</code> 分别代表 <code>rax, rbx, rcx</code> 的低32位</li><li>更多代码内容，从汇编分析，就比较费时间和偏离主题了。</li></ul><h4 id=如何查看具体汇编代码ui方式><strong>如何查看具体汇编代码</strong>（UI方式）</h4><p>可以打开 Disaseembly 面板。（当然如果有源代码+pdb文件，甚至可以直接打开源代码，类似普通在 vscode 中调试一样）</p><p><img src=/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763521358979.png loading=lazy alt=WinDbg的初级用法-1763521358979></p><h1 id=ttd指令>TTD指令</h1><p>time travel 模式下，有一些便捷指令。尤其常用 <code>!tt</code> 和 <code>!tt &lt;position></code></p><pre tabindex=0><code> tt 0                           - Time travel to the beginning of the trace (percentage)
 tt 50                          - Time travel to halfway through the trace (percentage)
 tt 100                         - Time travel to the end of the trace (percentage)
 tt 13.56                       - Time travel to 13.56% through the trace
 tt 1A0:                        - Time travel to position 1A0:0
 tt 1A0:0                       - Time travel to position 1A0:0
 tt 1A0:12F                     - Time travel to position 1A0:12F
 tt 1A0000000000000012F         - Time travel to position 1A0:12F
 tt br rax                      - Time travel to the next write to RAX
 tt br- rax 0x12345678          - Time travel to the previous write to RAX with the value 0x12345678
 tt ba- rw 0x12345678 0x4000    - Find previous position that reads or writes from memory range
                                  [0x12345678 - 0x12345678 + 0x4000).
 tt ba e 0x7fffe0001234 0x30000 - Find next position that executes from specified range. If the
                                  address and range represent the range of ntdll.dll, this command
                                  would find the next position where ntdll.dll is entered.
 tt bm                          - Time travel to the next instruction that is in a different module
                                  than current instruction&#39;s module.
 tt bm- ntdll.dll               - Time travel to the previous instruction that is in ntdll.dll
</code></pre><p>此外，在ttd模式下，还可以用 ：</p><ul><li><code>p-</code> ： 回退一步</li><li><code>g-</code> ： 回退到上一个缎带你</li></ul><h1 id=todo-未来有空再进一步研究>TODO: (未来有空再进一步研究)</h1><ol><li>memory leak调试</li><li>脚本：NatVis</li><li>脚本：javascript</li><li>以及更多学习资料： <a class=link href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-resources target=_blank rel=noopener>https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-resources</a></li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/windbg/>Windbg</a>
<a href=/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/>二进制</a>
<a href=/tags/%E8%B0%83%E8%AF%95/>调试</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=[".main-article",".widget--toc"];e.forEach(e=>{const t=document.querySelector(e);t&&renderMathInElement(t,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/2025/11/17/%E8%AE%B0%E5%BD%95%E8%B0%83%E8%AF%95vulkan%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8D%B0%E5%A5%87%E6%80%AA%E6%97%A5%E5%BF%97%E7%9A%84%E9%97%AE%E9%A2%98/><div class=article-details><h2 class=article-title>记录调试Vulkan程序打印奇怪日志的问题</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2025 crackhopper的技术博客</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.32.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.0fcb739c1f88ce461c9640077fd21d8ce903946f1aef209dd01192827d26a90c.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>