<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="\n本文主要围绕C++内存管理。也会介绍C++的RAII机制，以及其他语言的内存管理（GC）。\n本文内容相对比较深度，对 初级开发人员不友好 。\n"><title>C++内存管理</title><link rel=canonical href=https://crackhopper.github.io/2025/12/16/c-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/><link rel=stylesheet href=/scss/style.min.4d36f8dc1fd48129e1635deb4b8eb2870fa09474f7280c4cb606d40b2526994b.css><meta property='og:title' content="C++内存管理"><meta property='og:description' content="\n本文主要围绕C++内存管理。也会介绍C++的RAII机制，以及其他语言的内存管理（GC）。\n本文内容相对比较深度，对 初级开发人员不友好 。\n"><meta property='og:url' content='https://crackhopper.github.io/2025/12/16/c-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/'><meta property='og:site_name' content='crackhopper的技术博客'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='cpp'><meta property='article:tag' content='memory-management'><meta property='article:tag' content='raii'><meta property='article:tag' content='gc'><meta property='article:published_time' content='2025-12-16T18:16:06+08:00'><meta property='article:modified_time' content='2025-12-16T18:16:06+08:00'><meta name=twitter:title content="C++内存管理"><meta name=twitter:description content="\n本文主要围绕C++内存管理。也会介绍C++的RAII机制，以及其他语言的内存管理（GC）。\n本文内容相对比较深度，对 初级开发人员不友好 。\n"><link rel=stylesheet href=/css/custom.css></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_337fe2b325ec916d.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>crackhopper的技术博客</a></h1><h2 class=site-description>C++, Graphics, Game, AI/ML</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>文章</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于我</span></a></li><li><a href=/projects/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>项目</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky" id=right-sidebar><section class="widget archives toc-widget"><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc id=toc-content><nav id=TableOfContents><ul><li><a href=#c内存管理基础>C++内存管理基础</a><ul><li><a href=#接口概述>接口概述</a></li><li><a href=#c语言接口>C语言接口</a></li><li><a href=#new-operator-c语法>new operator (C++语法)</a></li><li><a href=#operator-newc操作符>operator new(C++操作符)</a></li><li><a href=#placement-newc语法>placement new(C++语法)</a></li><li><a href=#如何用allocator管理对象创建和销毁>如何用allocator管理对象创建和销毁</a></li><li><a href=#stl容器内如何创建和销毁对象>STL容器内如何创建和销毁对象</a></li><li><a href=#进阶pmr-和-memory_resource-c17>进阶：pmr 和 memory_resource (C++17)</a></li><li><a href=#进阶常见-memory_resource-实现>进阶：常见 <code>memory_resource</code> 实现</a><ul><li><a href=#1-new_delete_resource>1. <code>new_delete_resource</code></a></li><li><a href=#2-monotonic_buffer_resource>2. <code>monotonic_buffer_resource</code></a></li><li><a href=#3-unsynchronized_pool_resource>3. <code>unsynchronized_pool_resource</code></a></li><li><a href=#4-synchronized_pool_resource>4. <code>synchronized_pool_resource</code></a></li><li><a href=#自定义实现粒子池>自定义实现(粒子池)</a></li></ul></li></ul></li><li><a href=#资源获取即初始化-raii-resource-acquisition-is-initialization>资源获取即初始化 (RAII, Resource Acquisition Is Initialization）</a><ul><li><a href=#raii-的核心思想>RAII 的核心思想</a></li><li><a href=#raii-的工作机制以-c-为例>RAII 的工作机制（以 C++ 为例）</a><ul><li><a href=#构造函数获取资源>构造函数：获取资源</a></li><li><a href=#析构函数释放资源>析构函数：释放资源</a></li><li><a href=#使用方式>使用方式</a></li></ul></li><li><a href=#raii-与异常安全exception-safety>RAII 与异常安全（Exception Safety）</a></li><li><a href=#raii-的典型应用场景>RAII 的典型应用场景</a><ul><li><a href=#智能指针>智能指针</a></li><li><a href=#锁管理>锁管理</a></li><li><a href=#文件与流>文件与流</a></li><li><a href=#事务管理逻辑资源>事务管理（逻辑资源）</a></li><li><a href=#raii-的设计原则>RAII 的设计原则</a></li></ul></li><li><a href=#go语言如何实现raii>Go语言如何实现RAII</a><ul><li><a href=#defergo-的核心-raii-工具>defer：Go 的核心 RAII 工具</a></li><li><a href=#通过封装实现-raii-风格>通过封装实现 RAII 风格</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#typescript如何实现raii>Typescript如何实现RAII</a><ul><li><a href=#通过类封装--dispose-方法>通过类封装 + dispose 方法</a></li><li><a href=#使用时结合-tryfinally>使用时结合 try/finally</a></li><li><a href=#总结-1>总结</a></li></ul></li></ul></li><li><a href=#智能指针基础>智能指针基础</a><ul><li><a href=#unique_ptr><code>unique_ptr</code></a><ul><li><a href=#核心语义>核心语义</a></li><li><a href=#内存模型>内存模型</a></li><li><a href=#自定义-deleter重点>自定义 deleter（重点）</a></li><li><a href=#使用场景>使用场景</a></li></ul></li><li><a href=#shared_ptr><code>shared_ptr</code></a><ul><li><a href=#核心语义-1>核心语义</a></li><li><a href=#内存模型-1>内存模型</a></li><li><a href=#自定义deleterallocator>自定义deleter/allocator</a></li><li><a href=#循环引用问题重点>循环引用问题（重点）</a></li></ul></li><li><a href=#weak_ptr><code>weak_ptr</code></a><ul><li><a href=#核心语义-2>核心语义</a></li><li><a href=#内存模型-2>内存模型</a></li><li><a href=#使用场景-1>使用场景</a></li></ul></li><li><a href=#如何配合pmrmemory_resource-使用>如何配合<code>pmr::memory_resource</code> 使用？</a><ul><li><a href=#unique_ptr--pmr>unique_ptr + pmr</a></li><li><a href=#shared_ptr--pmr>shared_ptr + pmr</a></li><li><a href=#高性能场景示例对象池>高性能场景示例（对象池）</a></li></ul></li><li><a href=#最佳实践>最佳实践</a></li></ul></li><li><a href=#垃圾回收机制基础-garbage-collection>垃圾回收机制基础 (Garbage Collection)</a><ul><li><a href=#主要的gc算法>主要的GC算法</a><ul><li><a href=#mark-sweep算法>Mark-Sweep算法</a></li><li><a href=#copying算法>Copying算法</a></li><li><a href=#mark-compact算法>Mark-Compact算法</a></li><li><a href=#stop-the-world-stw>Stop-The-World (STW)</a></li></ul></li><li><a href=#精确gc和保守gc>精确GC和保守GC</a></li><li><a href=#标记数据的存储方式>标记数据的存储方式</a><ul><li><a href=#对象头object-header标记>对象头（Object Header）标记</a></li><li><a href=#外部标记表bit-map--side-table>外部标记表（Bit Map / Side Table）</a></li><li><a href=#两种方式结合hybrid>两种方式结合（Hybrid）</a></li></ul></li><li><a href=#boehm-gc>Boehm GC</a><ul><li><a href=#算法过程>算法过程</a></li><li><a href=#标记如何存储>标记如何存储</a></li><li><a href=#如何知道对象的大小>如何知道对象的大小</a><ul><li><a href=#自己记录大小>自己记录大小</a></li><li><a href=#在对象前面加-header可选>在对象前面加 header（可选）</a></li></ul></li><li><a href=#应用>应用</a></li></ul></li><li><a href=#unreal-engine-uobject-gc>Unreal Engine UObject GC</a><ul><li><a href=#算法过程-1>算法过程</a><ul><li><a href=#确定根集-gc-roots>确定根集 (GC Roots)</a></li><li><a href=#标记阶段-marking>标记阶段 (Marking)</a></li><li><a href=#清扫阶段-sweeping>清扫阶段 (Sweeping)</a></li></ul></li><li><a href=#应用与特点>应用与特点</a></li><li><a href=#对比boehm-gc>对比Boehm GC</a></li></ul></li><li><a href=#java的gc>Java的GC</a><ul><li><a href=#safepoint安全点>SafePoint（安全点）</a></li><li><a href=#oopmap对象指针地图-livemap>OopMap（对象指针地图）/ LiveMap</a></li><li><a href=#card-table--remembered-set记忆集>Card Table / Remembered Set（记忆集）</a></li><li><a href=#barrier屏障--特别是读写屏障>Barrier（屏障）- 特别是读写屏障</a></li><li><a href=#三色标记算法-tri-color-marking>三色标记算法 (Tri-color Marking)</a><ul><li><a href=#三种颜色及其含义>三种颜色及其含义</a></li><li><a href=#算法过程-2>算法过程</a></li></ul></li><li><a href=#并发-gc-引入的难题>并发 GC 引入的难题</a></li><li><a href=#解决并发gc问题-屏障技术>解决并发GC问题-屏障技术</a><ul><li><a href=#增量更新-incremental-update>增量更新 (Incremental Update)</a></li><li><a href=#原始快照-snapshot-at-the-beginning-satb>原始快照 (Snapshot At The Beginning, SATB)</a></li><li><a href=#final-remark>final remark</a></li></ul></li></ul></li><li><a href=#其他语言gc选择>其他语言GC选择</a><ul><li><a href=#go>Go</a></li><li><a href=#typescript>TypeScript</a></li><li><a href=#总结-2>总结</a></li></ul></li></ul></li><li><a href=#现代c推荐的内存管理>现代C++推荐的内存管理</a><ul><li><a href=#为什么现代-c-不推崇通用-gc>为什么现代 C++ 不推崇通用 GC</a><ul><li><a href=#c-的设计哲学与-gc-天然不匹配>C++ 的设计哲学与 GC 天然不匹配</a></li><li><a href=#c-已经有非常强的静态内存管理工具链>C++ 已经有非常强的静态内存管理工具链</a></li><li><a href=#性能与可预测性要求>性能与可预测性要求</a></li></ul></li><li><a href=#为什么智能指针--raii--自定义-allocator是主流解法>为什么“智能指针 + RAII + 自定义 Allocator”是主流解法</a><ul><li><a href=#第一层raii根基>第一层：RAII（根基）</a></li><li><a href=#第二层智能指针表达所有权>第二层：智能指针（表达所有权）</a></li><li><a href=#第三层allocator--内存池性能与规模>第三层：Allocator / 内存池（性能与规模）</a></li></ul></li><li><a href=#那-gc-在-c-中完全没价值吗>那 GC 在 C++ 中完全没价值吗？</a><ul><li><a href=#gc-在-c-中的合理使用场景>GC 在 C++ 中的合理使用场景</a></li></ul></li><li><a href=#重要补充避免一个常见误区>重要补充：避免一个常见误区</a></li></ul></li></ul></nav></div></section></aside><button class=toc-float-btn id=toc-float-btn aria-label=展开目录 title=展开目录>
<span class=toc-float-btn-icon></span></button><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/2025/12/16/c-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>C++内存管理</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-12-16T18:16:06+08:00>Dec 16, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>17 minute read</time></div></footer></div></header><section class=article-content><p><img src=/images/C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1765799530743.png loading=lazy alt=C++内存管理-1765799530743></p><p>本文主要围绕C++内存管理。也会介绍C++的RAII机制，以及其他语言的内存管理（GC）。</p><p>本文内容相对比较深度，对 <strong>初级开发人员不友好</strong> 。</p><h1 id=c内存管理基础>C++内存管理基础</h1><p>所谓内存管理，主要是管理堆上的内存。我们先从一些基础原理出发，然后不断深入和展开。</p><h2 id=接口概述>接口概述</h2><p>先看一个总结表：</p><div class=table-wrapper><table><thead><tr><th>分配方式</th><th>内存释放方式</th><th>额外行为</th></tr></thead><tbody><tr><td><code>malloc/calloc/realloc</code></td><td><code>free(ptr)</code></td><td>不调用构造/析构函数</td></tr><tr><td><code>new T</code></td><td><code>delete p</code></td><td>调用对象析构函数</td></tr><tr><td><code>new T[n]</code></td><td><code>delete[] arr</code></td><td>调用每个元素析构函数</td></tr><tr><td><code>operator new</code></td><td><code>operator delete(ptr)</code></td><td>只释放内存，不调用析构函数</td></tr><tr><td>自定义 <code>operator new</code></td><td>对应自定义 <code>operator delete</code></td><td>可控制分配和释放策略</td></tr></tbody></table></div><p>掌握接口是基础中的基础。我们这里仅快速回顾一下。</p><h2 id=c语言接口>C语言接口</h2><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#0550ae>*</span><span style=color:#6639ba>malloc</span><span style=color:#1f2328>(</span><span style=color:#cf222e>size_t</span> size<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>malloc: memory allocation</li><li>在堆上分配指定大小 size（字节）的连续内存空间。</li><li>内存未初始化，里面的内容是 <strong>随机值（垃圾值）</strong>。</li><li>返回指向分配内存的指针，如果分配失败返回 <code>NULL</code>。</li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#0550ae>*</span><span style=color:#6639ba>calloc</span><span style=color:#1f2328>(</span><span style=color:#cf222e>size_t</span> nitems<span style=color:#1f2328>,</span> <span style=color:#cf222e>size_t</span> size<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>calloc: contiguous allocation</li><li>在堆上分配 <code>nitems</code> 个元素，每个元素大小为 <code>size</code> 字节的连续内存，并 <strong>初始化为 0</strong>。</li><li>返回指向分配内存的指针，如果分配失败返回 <code>NULL</code>。</li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#0550ae>*</span><span style=color:#6639ba>realloc</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span> <span style=color:#0550ae>*</span>ptr<span style=color:#1f2328>,</span> <span style=color:#cf222e>size_t</span> new_size<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>调整之前分配的内存块 <code>ptr</code> 的大小为 <code>new_size</code> 字节。<ul><li>如果新大小大于原大小，原有数据保持不变，新增部分未初始化。</li><li>如果 <code>ptr</code> 为 <code>NULL</code>，效果等同于 <code>malloc(new_size)</code>。</li><li>如果 <code>new_size</code> 为 0，效果类似于 <code>free(ptr)</code>。（注意这个是implementation-defined，常见实现等同于free；因此不要用这个特性）</li><li>注意：<strong>如果失败，返回NULL，但是原本的 ptr 仍然有效。</strong></li></ul></li><li>可以扩展或缩小原有内存块。</li><li>可能在堆上移动内存（返回的新指针可能不同于原指针）。</li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#6639ba>free</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> ptr<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>将 之前由动态内存分配函数获得的堆内存 归还 。可以释放由 <code>malloc/calloc/realloc</code> 分配的内存</li><li><code>free</code> <strong>只释放内存</strong></li></ul><h2 id=new-operator-c语法>new operator (C++语法)</h2><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>T<span style=color:#0550ae>*</span> p <span style=color:#0550ae>=</span> <span style=color:#cf222e>new</span> T<span style=color:#1f2328>;</span>           <span style=color:#57606a>// 分配一个 T 类型对象，并调用构造函数
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>T<span style=color:#0550ae>*</span> arr <span style=color:#0550ae>=</span> <span style=color:#cf222e>new</span> T<span style=color:#1f2328>[</span>n<span style=color:#1f2328>];</span>      <span style=color:#57606a>// 分配一个 T 类型数组，并调用每个元素的构造函数
</span></span></span></code></pre></td></tr></table></div></div><ul><li><strong>类型安全</strong>：返回对应类型的指针，无需类型转换。</li><li><strong>构造函数调用</strong>：在分配内存后，会调用对象的构造函数。</li><li><strong>失败行为</strong>：<ul><li>默认情况下，如果分配失败，会抛出 <code>std::bad_alloc</code> 异常。</li></ul></li></ul><p><strong>可以使用 <code>nothrow</code> 版本避免异</strong></p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>T<span style=color:#0550ae>*</span> p <span style=color:#0550ae>=</span> <span style=color:#cf222e>new</span> <span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>nothrow<span style=color:#1f2328>)</span> T<span style=color:#1f2328>;</span>
</span></span></code></pre></td></tr></table></div></div><p>释放方式</p><ul><li>对象：<code>delete p;</code> 会调用析构函数并释放内存。</li><li>数组：<code>delete[] arr;</code> 会调用每个元素析构函数并释放内存。</li></ul><h2 id=operator-newc操作符>operator new(C++操作符)</h2><p>new operator在分配内存的时候，也需要类似C语言调用对应的malloc/calloc/realloc 。在C++中，这个动作被定义为 operator new 。默认标准库在全局作用域提供一个 <code>::operator new</code> 。整个operator new的机制和C++操作符重载机制类似。（因此，operator new 只负责分配内存，并不负责调用构造函数；因此，还有另一个操作，仅负责调用构造函数，不负责分配内存，叫 placement new，下一个小结会讲）</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#57606a>// 全局 operator new。可以被替换
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> <span style=color:#cf222e>operator</span> <span style=color:#6639ba>new</span><span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>size_t size<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>return</span> std<span style=color:#0550ae>::</span>malloc<span style=color:#1f2328>(</span>size<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#cf222e>operator</span> <span style=color:#6639ba>delete</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> ptr<span style=color:#1f2328>)</span> <span style=color:#cf222e>noexcept</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>free<span style=color:#1f2328>(</span>ptr<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57606a>// 某个类的重载
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#cf222e>struct</span> <span style=color:#1f2328>B</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>static</span> <span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> <span style=color:#cf222e>operator</span> <span style=color:#6639ba>new</span><span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>size_t size<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>return</span> std<span style=color:#0550ae>::</span>malloc<span style=color:#1f2328>(</span>size<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>static</span> <span style=color:#cf222e>void</span> <span style=color:#cf222e>operator</span> <span style=color:#6639ba>delete</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> ptr<span style=color:#1f2328>)</span> <span style=color:#cf222e>noexcept</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        std<span style=color:#0550ae>::</span>free<span style=color:#1f2328>(</span>ptr<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// 同样可以定义
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    <span style=color:#57606a>// void* operator new[](size_t size); 
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    <span style=color:#57606a>// void operator delete[](void* ptr); 
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>注意，上面的operator定义必须成对出现。</li><li>仅负责分配和释放内存。不负责调用构造和析构函数。(类似C的malloc和free)</li><li>返回 <code>void*</code>，需要类型转换。（直接调用operator new的时候，少见）</li><li>如果分配失败，默认会抛出 <code>std::bad_alloc</code>。</li></ul><p><strong>注意：现实中还要处理 size == 0、对齐、异常等</strong></p><h2 id=placement-newc语法>placement new(C++语法)</h2><p>如果内存已经分配好，希望在该内存上调用构造函数，必须使用 placement new。</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> buffer <span style=color:#0550ae>=</span> <span style=color:#57606a>/* 已分配好的内存 */</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>T<span style=color:#0550ae>*</span> obj <span style=color:#0550ae>=</span> <span style=color:#cf222e>new</span> <span style=color:#1f2328>(</span>buffer<span style=color:#1f2328>)</span> T<span style=color:#1f2328>(</span>constructor_args<span style=color:#1f2328>...);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>buffer</code>：已经存在、且足够大、对齐正确的内存</li><li><code>T(constructor_args...)</code>：正常调用构造函数</li><li><strong>不会分配内存</strong></li><li><strong>只调用构造函数</strong></li></ul><h2 id=如何用allocator管理对象创建和销毁>如何用allocator管理对象创建和销毁</h2><p>首先，什么是allocator。这里先简单介绍。</p><p>Allocator 是一种将“内存分配策略”与“对象生命周期管理”解耦的抽象机制，用于为容器或组件提供可定制的内存来源。（这个说法仍然很抽象）</p><p>更简单点，可以理解为一个类，包含两个成员函数：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>T<span style=color:#0550ae>*</span> <span style=color:#6639ba>allocate</span><span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>size_t n<span style=color:#1f2328>);</span> <span style=color:#57606a>// n是元素个数
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#cf222e>void</span> <span style=color:#6639ba>deallocate</span><span style=color:#1f2328>(</span>T<span style=color:#0550ae>*</span> p<span style=color:#1f2328>,</span> std<span style=color:#0550ae>::</span>size_t n<span style=color:#1f2328>);</span> <span style=color:#57606a>// n是元素个数
</span></span></span></code></pre></td></tr></table></div></div><ul><li>allocator 只负责 分配和释放原始内存。（因此功能有点像被抽象出单独的类，实现 operator new/delete 的功能）</li><li>allocator 内部实现的时候，可能自己已经创建好了比较大块的内存（比如内存池），或者实现了内存管理算法。因此allocator本身可以用来辅助C++管理内存。</li></ul><p>仅有上面的机制，如何创建和释放C++对象呢？这就用到我们之前学习的基础语法：</p><p>（这里是简化的逻辑）</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>MyAllocator alloc<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57606a>// 创建对象
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> raw <span style=color:#0550ae>=</span> alloc<span style=color:#1f2328>.</span>allocate<span style=color:#1f2328>(</span><span style=color:#cf222e>sizeof</span><span style=color:#1f2328>(</span>T<span style=color:#1f2328>));</span> <span style=color:#57606a>// 调用allocator创建
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>T<span style=color:#0550ae>*</span> p <span style=color:#0550ae>=</span> <span style=color:#cf222e>new</span> <span style=color:#1f2328>(</span>raw<span style=color:#1f2328>)</span> T<span style=color:#1f2328>(</span>args<span style=color:#1f2328>...);</span> <span style=color:#57606a>// placement new
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>
</span></span><span style=display:flex><span><span style=color:#57606a>// 销毁对象
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>p<span style=color:#0550ae>-&gt;~</span>T<span style=color:#1f2328>();</span>              <span style=color:#57606a>// 1. 显式析构
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>alloc<span style=color:#1f2328>.</span>deallocate<span style=color:#1f2328>(</span>p<span style=color:#1f2328>);</span> <span style=color:#57606a>// 2. 释放内存
</span></span></span></code></pre></td></tr></table></div></div><h2 id=stl容器内如何创建和销毁对象>STL容器内如何创建和销毁对象</h2><p>我们只讲比较新版本的C++。答案是利用 <code>allocator_traits</code> 。</p><p>关于什么是 <code>traits</code> 可以参看 <a class=link href=/2025/12/11/c-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/>C++模板元编程初探</a> 。这里简要来说，traits定义了allocator的接口，只要符合traits的要求，那么traits就可以把我们自定义的allocator和C++的标准库容器对接。</p><p>标准库内，如果要创建要创建/销毁对象，对应的调用为：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#57606a>// 创建
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>T<span style=color:#0550ae>*</span> p <span style=color:#0550ae>=</span> alloc<span style=color:#1f2328>.</span>allocate<span style=color:#1f2328>(</span><span style=color:#0550ae>1</span><span style=color:#1f2328>);</span> <span style=color:#57606a>// 实际上这步骤也是调用 std::allocator_traits 的 allocate 函数，转发到这个调用
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>std<span style=color:#0550ae>::</span>allocator_traits<span style=color:#0550ae>&lt;</span>A<span style=color:#0550ae>&gt;::</span>construct<span style=color:#1f2328>(</span>alloc<span style=color:#1f2328>,</span> p<span style=color:#1f2328>,</span> args<span style=color:#1f2328>...);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57606a>// 销毁
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>std<span style=color:#0550ae>::</span>allocator_traits<span style=color:#0550ae>&lt;</span>A<span style=color:#0550ae>&gt;::</span>destroy<span style=color:#1f2328>(</span>alloc<span style=color:#1f2328>,</span> p<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>alloc<span style=color:#1f2328>.</span>deallocate<span style=color:#1f2328>(</span>p<span style=color:#1f2328>,</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>);</span> <span style=color:#57606a>// 实际上这步骤也是调用 std::allocator_traits 的 deallocate 函数，转发到这个调用
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>std::allocator_traits&lt;A>::construct</code> : 相当于调用 placement new。（内部实现也是这样）</li><li><code>std::allocator_traits&lt;A>::destroy</code> ： 相当于调用 <code>~T()</code> 析构函数。</li></ul><p>所以，当</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span>T<span style=color:#1f2328>,</span> MyAlloc<span style=color:#0550ae>&gt;</span> v<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>v<span style=color:#1f2328>.</span>emplace_back<span style=color:#1f2328>(</span>args<span style=color:#1f2328>...);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>此时就是走上面的创建流程。</li></ul><h2 id=进阶pmr-和-memory_resource-c17>进阶：pmr 和 memory_resource (C++17)</h2><p>传统allocator的“类型绑定”过强</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> MyAlloc<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>int</span><span style=color:#0550ae>&gt;&gt;</span> v<span style=color:#1f2328>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>allocator 是 <strong>模板参数</strong> 。改Allocator等于改类型，这导致了接口污染、类型膨胀。</li><li>allocator 类型必须在 <strong>编译期确定</strong>。无法根据运行时策略切换内存来源</li><li>allocator 之间 <strong>难以共享内存池</strong> 。每个 allocator 类型一套逻辑</li></ul><p><strong>pmr（Polymorphic Memory Resource）正是为了解决这些问题而引入的。</strong> 核心思想：</p><ul><li><strong>把“内存策略”从模板参数，变成运行时多态对象。</strong></li></ul><p>pmr 的关键抽象是：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>memory_resource
</span></span></code></pre></td></tr></table></div></div><p>它是一个 <strong>运行时多态的内存分配接口</strong>，本质上类似于：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>struct</span> <span style=color:#1f2328>memory_resource</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>virtual</span> <span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> <span style=color:#6639ba>do_allocate</span><span style=color:#1f2328>(</span>size_t bytes<span style=color:#1f2328>,</span> size_t alignment<span style=color:#1f2328>)</span> <span style=color:#0550ae>=</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>virtual</span> <span style=color:#cf222e>void</span>  <span style=color:#6639ba>do_deallocate</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> p<span style=color:#1f2328>,</span> size_t bytes<span style=color:#1f2328>,</span> size_t alignment<span style=color:#1f2328>)</span> <span style=color:#0550ae>=</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>virtual</span> <span style=color:#cf222e>bool</span>  <span style=color:#6639ba>do_is_equal</span><span style=color:#1f2328>(</span><span style=color:#cf222e>const</span> memory_resource<span style=color:#0550ae>&amp;</span><span style=color:#1f2328>)</span> <span style=color:#cf222e>const</span> <span style=color:#cf222e>noexcept</span> <span style=color:#0550ae>=</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>以字节为单位分配（不是元素个数）</li><li>支持对齐</li><li>使用虚函数 → 运行时多态</li></ul><p>pmr 并没有直接让容器用 <code>memory_resource</code>，而是引入了一个桥接器：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>polymorphic_allocator<span style=color:#0550ae>&lt;</span>T<span style=color:#0550ae>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>对外表现为 allocator</strong></li><li><strong>内部把分配请求转发给 memory_resource</strong></li></ul><p>关系可以理解为：</p><pre tabindex=0><code>STL 容器
   ↓ allocator_traits
polymorphic_allocator&lt;T&gt;
   ↓ 虚函数
memory_resource
</code></pre><p>因此：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>int</span><span style=color:#0550ae>&gt;</span> v<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57606a>// 等价于
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>std<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>int</span><span style=color:#1f2328>,</span> std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>polymorphic_allocator<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>int</span><span style=color:#0550ae>&gt;&gt;</span> v<span style=color:#1f2328>;</span>
</span></span></code></pre></td></tr></table></div></div><p>同时我们可以运行时绑定不同的内存资源。（但是类型是一样的，并没有类型膨胀）</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>monotonic_buffer_resource pool1<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>monotonic_buffer_resource pool2<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>int</span><span style=color:#0550ae>&gt;</span> v1<span style=color:#1f2328>{</span> <span style=color:#0550ae>&amp;</span>pool1 <span style=color:#1f2328>};</span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>int</span><span style=color:#0550ae>&gt;</span> v2<span style=color:#1f2328>{</span> <span style=color:#0550ae>&amp;</span>pool2 <span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><p>如果没有显示传入 <code>memory_resource</code> ，那么使用：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>get_default_resource<span style=color:#1f2328>()</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>默认是 <code>new_delete_resource()</code></li><li>可通过 <code>set_default_resource()</code> 替换（<strong>谨慎使用</strong>）</li></ul><h2 id=进阶常见-memory_resource-实现>进阶：常见 <code>memory_resource</code> 实现</h2><h3 id=1-new_delete_resource>1. <code>new_delete_resource</code></h3><ul><li>底层使用 <code>::operator new/delete</code></li><li>行为接近普通 STL allocator</li><li><strong>默认资源</strong></li></ul><h3 id=2-monotonic_buffer_resource>2. <code>monotonic_buffer_resource</code></h3><p>本质上类似： linear allocator ，或者说 arena/region allocator</p><p>特点：</p><ul><li>只分配，不单独释放</li><li>整个 resource 析构时统一释放</li><li>分配速度快</li></ul><p>适合场景：</p><ul><li>短生命周期对象</li><li>批量创建、整体销毁</li><li>临时计算 / 解析 / 构建阶段</li></ul><h3 id=3-unsynchronized_pool_resource>3. <code>unsynchronized_pool_resource</code></h3><p>可以理解为简化版的 <code>tlsf</code> 内存管理。</p><ul><li>内部维护多个 free list</li><li>适合频繁小对象分配</li><li><strong>非线程安全</strong></li><li>性能优于通用 allocator</li></ul><h3 id=4-synchronized_pool_resource>4. <code>synchronized_pool_resource</code></h3><ul><li>线程安全版本</li><li>有锁，性能略低</li></ul><h3 id=自定义实现粒子池>自定义实现(粒子池)</h3><p>考虑一种自定义内存池：</p><ul><li><strong>对象固定大小</strong>，比如 <code>sizeof(Particle)</code></li><li><strong>快速分配/释放</strong>，O(1) 或接近 O(1)</li><li><strong>复用已释放的内存</strong></li><li><strong>支持 pmr 接口</strong>，即继承 <code>std::pmr::memory_resource</code>
典型做法是 <strong>自由链表（free list）+ 内存块</strong>。</li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#57606a>#include</span> <span style=color:#57606a>&lt;memory_resource&gt;</span><span style=color:#57606a>
</span></span></span><span style=display:flex><span><span style=color:#57606a>#include</span> <span style=color:#57606a>&lt;cstddef&gt;</span><span style=color:#57606a>
</span></span></span><span style=display:flex><span><span style=color:#57606a>#include</span> <span style=color:#57606a>&lt;cassert&gt;</span><span style=color:#57606a>
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>
</span></span><span style=display:flex><span><span style=color:#cf222e>struct</span> <span style=color:#1f2328>Particle</span> <span style=color:#1f2328>{</span> <span style=color:#57606a>/* 粒子数据 */</span> <span style=color:#1f2328>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>class</span> <span style=color:#1f2328>fixed_pool_resource</span> <span style=color:#0550ae>:</span> <span style=color:#cf222e>public</span> std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>memory_resource <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>public</span><span style=color:#0550ae>:</span>
</span></span><span style=display:flex><span>    fixed_pool_resource<span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>size_t object_size<span style=color:#1f2328>,</span> std<span style=color:#0550ae>::</span>size_t capacity<span style=color:#1f2328>,</span>
</span></span><span style=display:flex><span>                        std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>memory_resource<span style=color:#0550ae>*</span> upstream <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>get_default_resource<span style=color:#1f2328>())</span>
</span></span><span style=display:flex><span>        <span style=color:#0550ae>:</span> object_size_<span style=color:#1f2328>(</span>object_size<span style=color:#1f2328>),</span> capacity_<span style=color:#1f2328>(</span>capacity<span style=color:#1f2328>),</span> upstream_<span style=color:#1f2328>(</span>upstream<span style=color:#1f2328>)</span> 
</span></span><span style=display:flex><span>    <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        assert<span style=color:#1f2328>(</span>object_size_ <span style=color:#0550ae>&gt;=</span> <span style=color:#cf222e>sizeof</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span><span style=color:#1f2328>));</span>
</span></span><span style=display:flex><span>        allocate_block<span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>protected</span><span style=color:#0550ae>:</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> do_allocate<span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>size_t bytes<span style=color:#1f2328>,</span> std<span style=color:#0550ae>::</span>size_t alignment<span style=color:#1f2328>)</span> <span style=color:#cf222e>override</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        assert<span style=color:#1f2328>(</span>bytes <span style=color:#0550ae>&lt;=</span> object_size_ <span style=color:#0550ae>&amp;&amp;</span> alignment <span style=color:#0550ae>&lt;=</span> <span style=color:#cf222e>alignof</span><span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>max_align_t<span style=color:#1f2328>));</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>!</span>free_list_<span style=color:#1f2328>)</span> allocate_block<span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> result <span style=color:#0550ae>=</span> free_list_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>        free_list_ <span style=color:#0550ae>=</span> <span style=color:#0550ae>*</span><span style=color:#cf222e>reinterpret_cast</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>void</span><span style=color:#0550ae>**&gt;</span><span style=color:#1f2328>(</span>free_list_<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>return</span> result<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>void</span> <span style=color:#6639ba>do_deallocate</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> p<span style=color:#1f2328>,</span> std<span style=color:#0550ae>::</span>size_t bytes<span style=color:#1f2328>,</span> std<span style=color:#0550ae>::</span>size_t alignment<span style=color:#1f2328>)</span> <span style=color:#cf222e>override</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#0550ae>*</span><span style=color:#cf222e>reinterpret_cast</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>void</span><span style=color:#0550ae>**&gt;</span><span style=color:#1f2328>(</span>p<span style=color:#1f2328>)</span> <span style=color:#0550ae>=</span> free_list_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>        free_list_ <span style=color:#0550ae>=</span> p<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>bool</span> <span style=color:#6639ba>do_is_equal</span><span style=color:#1f2328>(</span><span style=color:#cf222e>const</span> memory_resource<span style=color:#0550ae>&amp;</span> other<span style=color:#1f2328>)</span> <span style=color:#cf222e>const</span> <span style=color:#cf222e>noexcept</span> <span style=color:#cf222e>override</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>return</span> <span style=color:#cf222e>this</span> <span style=color:#0550ae>==</span> <span style=color:#0550ae>&amp;</span>other<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>private</span><span style=color:#0550ae>:</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>void</span> allocate_block<span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>char</span><span style=color:#0550ae>*</span> block <span style=color:#0550ae>=</span> <span style=color:#cf222e>static_cast</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>char</span><span style=color:#0550ae>*&gt;</span><span style=color:#1f2328>(</span>upstream_<span style=color:#0550ae>-&gt;</span>allocate<span style=color:#1f2328>(</span>object_size_ <span style=color:#0550ae>*</span> capacity_<span style=color:#1f2328>,</span> <span style=color:#cf222e>alignof</span><span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>max_align_t<span style=color:#1f2328>)));</span>
</span></span><span style=display:flex><span>        blocks_<span style=color:#1f2328>.</span>push_back<span style=color:#1f2328>(</span>block<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#57606a>// 将 block 划分为 free_list
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>        <span style=color:#cf222e>for</span> <span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>size_t i <span style=color:#0550ae>=</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>;</span> i <span style=color:#0550ae>&lt;</span> capacity_<span style=color:#1f2328>;</span> <span style=color:#0550ae>++</span>i<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>            <span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> ptr <span style=color:#0550ae>=</span> block <span style=color:#0550ae>+</span> i <span style=color:#0550ae>*</span> object_size_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>            <span style=color:#0550ae>*</span><span style=color:#cf222e>reinterpret_cast</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>void</span><span style=color:#0550ae>**&gt;</span><span style=color:#1f2328>(</span>ptr<span style=color:#1f2328>)</span> <span style=color:#0550ae>=</span> free_list_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>            free_list_ <span style=color:#0550ae>=</span> ptr<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>        <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>size_t object_size_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>size_t capacity_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>memory_resource<span style=color:#0550ae>*</span> upstream_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> free_list_ <span style=color:#0550ae>=</span> <span style=color:#cf222e>nullptr</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span><span style=color:#cf222e>void</span><span style=color:#0550ae>*&gt;</span> blocks_<span style=color:#1f2328>;</span> <span style=color:#57606a>// 用于释放整个 pool
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><p>关键逻辑：</p><ul><li><code>alignment &lt;= alignof(std::max_align_t)</code> : 检查内存对齐可以支持。如果更高的内存对齐，需要在 <code>allocate_block</code> 里专门实现。</li><li>链表操作：<strong>每个空闲单元的前 sizeof(void) 字节存放指针</strong><ul><li><code>free_list_ = *reinterpret_cast&lt;void**>(free_list_);</code> 链表向后移动一个位置。</li><li><code>*reinterpret_cast&lt;void**>(p) = free_list_;</code> 把释放的p作为链表头插入进来。</li><li>需要注意，内存只有是free，被管理的时候，我们才使用这个指针。而被allocate之后，对象会覆盖这个指针（但不影响我们管理free）</li></ul></li></ul><p>使用示例：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>int</span> <span style=color:#6639ba>main</span><span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    fixed_pool_resource particle_pool<span style=color:#1f2328>(</span><span style=color:#cf222e>sizeof</span><span style=color:#1f2328>(</span>Particle<span style=color:#1f2328>),</span> <span style=color:#0550ae>1024</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>polymorphic_allocator<span style=color:#0550ae>&lt;</span>Particle<span style=color:#0550ae>&gt;</span> alloc<span style=color:#1f2328>(</span><span style=color:#0550ae>&amp;</span>particle_pool<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>vector<span style=color:#0550ae>&lt;</span>Particle<span style=color:#0550ae>&gt;</span> particles<span style=color:#1f2328>{</span><span style=color:#0550ae>&amp;</span>alloc<span style=color:#1f2328>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// 构造对象
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    Particle<span style=color:#0550ae>*</span> p <span style=color:#0550ae>=</span> alloc<span style=color:#1f2328>.</span>allocate<span style=color:#1f2328>(</span><span style=color:#0550ae>1</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>new</span> <span style=color:#1f2328>(</span>p<span style=color:#1f2328>)</span> Particle<span style=color:#1f2328>();</span>  <span style=color:#57606a>// placement new
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// 销毁对象
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    p<span style=color:#0550ae>-&gt;~</span>Particle<span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span>    alloc<span style=color:#1f2328>.</span>deallocate<span style=color:#1f2328>(</span>p<span style=color:#1f2328>,</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当然这个对新手不友好，可以再封装一层：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>class</span> <span style=color:#1f2328>ParticlePool</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>public</span><span style=color:#0550ae>:</span>
</span></span><span style=display:flex><span>    ParticlePool<span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>size_t capacity<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>        <span style=color:#0550ae>:</span> pool_<span style=color:#1f2328>(</span><span style=color:#cf222e>sizeof</span><span style=color:#1f2328>(</span>Particle<span style=color:#1f2328>),</span> capacity<span style=color:#1f2328>)</span> <span style=color:#1f2328>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// create 对象：分配 + 构造
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    <span style=color:#cf222e>template</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>typename</span><span style=color:#1f2328>...</span> Args<span style=color:#0550ae>&gt;</span>
</span></span><span style=display:flex><span>    Particle<span style=color:#0550ae>*</span> create<span style=color:#1f2328>(</span>Args<span style=color:#0550ae>&amp;&amp;</span><span style=color:#1f2328>...</span> args<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> mem <span style=color:#0550ae>=</span> pool_<span style=color:#1f2328>.</span>allocate<span style=color:#1f2328>(</span><span style=color:#0550ae>1</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>return</span> <span style=color:#6639ba>new</span> <span style=color:#1f2328>(</span>mem<span style=color:#1f2328>)</span> Particle<span style=color:#1f2328>(</span>std<span style=color:#0550ae>::</span>forward<span style=color:#0550ae>&lt;</span>Args<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span>args<span style=color:#1f2328>)...);</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// destroy 对象：析构 + 释放
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    <span style=color:#cf222e>void</span> <span style=color:#6639ba>destroy</span><span style=color:#1f2328>(</span>Particle<span style=color:#0550ae>*</span> p<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>!</span>p<span style=color:#1f2328>)</span> <span style=color:#cf222e>return</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>        p<span style=color:#0550ae>-&gt;~</span>Particle<span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span>        pool_<span style=color:#1f2328>.</span>deallocate<span style=color:#1f2328>(</span>p<span style=color:#1f2328>,</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>private</span><span style=color:#0550ae>:</span>
</span></span><span style=display:flex><span>    fixed_pool_resource pool_<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=资源获取即初始化-raii-resource-acquisition-is-initialization>资源获取即初始化 (RAII, Resource Acquisition Is Initialization）</h1><p>RAII（<strong>Resource Acquisition Is Initialization，资源获取即初始化</strong>）是一种重要的编程范式，最早系统化地出现在 <strong>C++</strong> 中，但其思想对许多现代语言和资源管理机制都产生了深远影响。RAII 的核心目标是：<strong>用对象的生命周期来严格、自动地管理资源的生命周期</strong>，从而避免资源泄漏、状态不一致和异常路径下的管理错误。</p><p>我们这里提到这个，主要是内存管理的时候，为了更好的管理内存资源、以及方便使用。用到RAII也非常常见。</p><h2 id=raii-的核心思想>RAII 的核心思想</h2><p>RAII 的基本原则可以概括为两点：</p><ol><li><strong>资源的获取发生在对象构造阶段</strong></li><li><strong>资源的释放发生在对象析构阶段</strong></li></ol><p>这里的“资源”是一个广义概念，包括但不限于：</p><ul><li>动态内存（<code>new</code> / <code>malloc</code>）</li><li>文件句柄（<code>FILE*</code>、<code>std::fstream</code>）</li><li>互斥锁 / 自旋锁</li><li>网络 socket</li><li>数据库连接</li><li>GPU / OS 句柄等系统资源</li></ul><p>在 RAII 中：</p><ul><li><strong>只要对象存在，资源一定处于有效状态</strong></li><li><strong>对象一旦离开作用域，资源必然被释放</strong></li></ul><p>这使得资源管理与作用域（scope）形成了强绑定关系。</p><h2 id=raii-的工作机制以-c-为例>RAII 的工作机制（以 C++ 为例）</h2><h3 id=构造函数获取资源>构造函数：获取资源</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>class</span> <span style=color:#1f2328>File</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>public</span><span style=color:#0550ae>:</span>
</span></span><span style=display:flex><span>    File<span style=color:#1f2328>(</span><span style=color:#cf222e>const</span> <span style=color:#cf222e>char</span><span style=color:#0550ae>*</span> path<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        fp <span style=color:#0550ae>=</span> fopen<span style=color:#1f2328>(</span>path<span style=color:#1f2328>,</span> <span style=color:#0a3069>&#34;r&#34;</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>!</span>fp<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>            <span style=color:#cf222e>throw</span> std<span style=color:#0550ae>::</span>runtime_error<span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;open failed&#34;</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><p>构造函数要么成功获取资源并建立不变式，要么直接失败（抛异常），<strong>不存在“半初始化”状态</strong>。</p><h3 id=析构函数释放资源>析构函数：释放资源</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#0550ae>~</span>File<span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span>fp<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>            fclose<span style=color:#1f2328>(</span>fp<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>private</span><span style=color:#0550ae>:</span>
</span></span><span style=display:flex><span>    FILE<span style=color:#0550ae>*</span> fp<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><p>析构函数具有以下关键特性：</p><ul><li><strong>自动调用</strong>（离开作用域时）</li><li><strong>异常安全</strong>（不会被绕过）</li><li><strong>与控制流无关</strong>（<code>return</code>、<code>break</code>、<code>throw</code> 均可）</li></ul><h3 id=使用方式>使用方式</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#6639ba>process</span><span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    File f<span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;data.txt&#34;</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// 使用 f
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>}</span> <span style=color:#57606a>// 离开作用域，f 析构，文件自动关闭
</span></span></span></code></pre></td></tr></table></div></div><p>调用者无需关心资源释放逻辑，这正是 RAII 的价值所在。</p><h2 id=raii-与异常安全exception-safety>RAII 与异常安全（Exception Safety）</h2><p>RAII 被认为是 <strong>C++ 异常安全的基石</strong>，原因在于：</p><ul><li>异常会导致栈展开（stack unwinding）</li><li>栈展开过程中，所有已构造完成的对象都会被析构</li><li>RAII 保证析构函数释放资源</li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#6639ba>foo</span><span style=color:#1f2328>()</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>lock_guard<span style=color:#0550ae>&lt;</span>std<span style=color:#0550ae>::</span>mutex<span style=color:#0550ae>&gt;</span> lock<span style=color:#1f2328>(</span>m<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    risky_operation<span style=color:#1f2328>();</span> <span style=color:#57606a>// 即使这里抛异常，锁也会被释放
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><p>无需 try/catch 或 finally，异常路径与正常路径具备完全一致的资源释放语义。</p><h2 id=raii-的典型应用场景>RAII 的典型应用场景</h2><h3 id=智能指针>智能指针</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>unique_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> p<span style=color:#1f2328>(</span><span style=color:#cf222e>new</span> Foo<span style=color:#1f2328>());</span>
</span></span><span style=display:flex><span><span style=color:#57606a>// 离开作用域自动 delete
</span></span></span></code></pre></td></tr></table></div></div><p>智能指针本质上就是“<strong>把裸指针的资源管理 RAII 化</strong>”。</p><h3 id=锁管理>锁管理</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>lock_guard<span style=color:#0550ae>&lt;</span>std<span style=color:#0550ae>::</span>mutex<span style=color:#0550ae>&gt;</span> guard<span style=color:#1f2328>(</span>m<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><p>避免以下错误：</p><ul><li>忘记解锁</li><li>多重 return</li><li>异常路径遗漏解锁</li></ul><h3 id=文件与流>文件与流</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>ofstream out<span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;log.txt&#34;</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    out <span style=color:#0550ae>&lt;&lt;</span> <span style=color:#0a3069>&#34;hello&#34;</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span> <span style=color:#57606a>// 自动 flush + close
</span></span></span></code></pre></td></tr></table></div></div><h3 id=事务管理逻辑资源>事务管理（逻辑资源）</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Transaction <span style=color:#6639ba>tx</span><span style=color:#1f2328>(</span>db<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>tx<span style=color:#1f2328>.</span>commit<span style=color:#1f2328>();</span>
</span></span></code></pre></td></tr></table></div></div><p>析构函数中：</p><ul><li>未提交则自动 rollback</li></ul><p>这属于 <strong>扩展意义上的 RAII</strong>。</p><h3 id=raii-的设计原则>RAII 的设计原则</h3><p>一个“合格的 RAII 类型”通常具备以下特征：</p><ol><li><strong>构造即完全可用</strong></li><li><strong>析构必然释放资源</strong></li><li><strong>析构函数不抛异常</strong></li><li><strong>资源所有权清晰</strong></li><li><strong>禁止或显式定义拷贝 / 移动语义</strong></li></ol><p>例如：</p><ul><li>禁止拷贝，只允许移动（<code>unique_ptr</code>）</li><li>明确共享语义（<code>shared_ptr</code>）</li></ul><h2 id=go语言如何实现raii>Go语言如何实现RAII</h2><p>因为Go也是我主力语言。这里简单增加一些内容。</p><h3 id=defergo-的核心-raii-工具>defer：Go 的核心 RAII 工具</h3><p><code>defer</code> 用于在函数退出时执行清理操作。特点：</p><ul><li><strong>执行时机确定</strong>：函数返回（正常或 panic）时自动调用。</li><li><strong>顺序栈</strong>：多个 defer 语句按 <strong>后进先出</strong> 执行。</li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>func</span><span style=color:#fff> </span><span style=color:#6639ba>readFile</span><span style=color:#1f2328>(</span><span style=color:#1f2328>path</span><span style=color:#fff> </span><span style=color:#cf222e>string</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#cf222e>error</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>f</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#1f2328>os</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Open</span><span style=color:#1f2328>(</span><span style=color:#1f2328>path</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>if</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#0550ae>!=</span><span style=color:#fff> </span><span style=color:#cf222e>nil</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>return</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>defer</span><span style=color:#fff> </span><span style=color:#1f2328>f</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Close</span><span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#57606a>// 离开函数时自动关闭</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#57606a>// 使用文件</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>data</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#6639ba>make</span><span style=color:#1f2328>([]</span><span style=color:#cf222e>byte</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0550ae>100</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>_</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#1f2328>=</span><span style=color:#fff> </span><span style=color:#1f2328>f</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Read</span><span style=color:#1f2328>(</span><span style=color:#1f2328>data</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>return</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=通过封装实现-raii-风格>通过封装实现 RAII 风格</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>type</span><span style=color:#fff> </span><span style=color:#1f2328>File</span><span style=color:#fff> </span><span style=color:#cf222e>struct</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#0550ae>*</span><span style=color:#1f2328>os</span><span style=color:#1f2328>.</span><span style=color:#1f2328>File</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>func</span><span style=color:#fff> </span><span style=color:#6639ba>OpenFile</span><span style=color:#1f2328>(</span><span style=color:#1f2328>path</span><span style=color:#fff> </span><span style=color:#cf222e>string</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span><span style=color:#1f2328>File</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#cf222e>error</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>f</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#1f2328>os</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Open</span><span style=color:#1f2328>(</span><span style=color:#1f2328>path</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>if</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#0550ae>!=</span><span style=color:#fff> </span><span style=color:#cf222e>nil</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>return</span><span style=color:#fff> </span><span style=color:#cf222e>nil</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>return</span><span style=color:#fff> </span><span style=color:#0550ae>&amp;</span><span style=color:#1f2328>File</span><span style=color:#1f2328>{</span><span style=color:#1f2328>f</span><span style=color:#1f2328>},</span><span style=color:#fff> </span><span style=color:#cf222e>nil</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>func</span><span style=color:#fff> </span><span style=color:#1f2328>(</span><span style=color:#1f2328>f</span><span style=color:#fff> </span><span style=color:#0550ae>*</span><span style=color:#1f2328>File</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#6639ba>Close</span><span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>f</span><span style=color:#1f2328>.</span><span style=color:#1f2328>File</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Close</span><span style=color:#1f2328>()</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#57606a>// 使用</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#cf222e>func</span><span style=color:#fff> </span><span style=color:#6639ba>process</span><span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#cf222e>error</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>f</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#6639ba>OpenFile</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;data.txt&#34;</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>if</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#0550ae>!=</span><span style=color:#fff> </span><span style=color:#cf222e>nil</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>        </span><span style=color:#cf222e>return</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>defer</span><span style=color:#fff> </span><span style=color:#1f2328>f</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Close</span><span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#57606a>// 类似 RAII 的析构释放</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#57606a>// 使用 f</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#cf222e>return</span><span style=color:#fff> </span><span style=color:#cf222e>nil</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=总结>总结</h3><p>在 Go 中可以总结为：</p><ol><li><strong>构造函数负责获取资源</strong></li><li><strong>Close/Release 方法负责释放资源</strong></li><li><strong>函数作用域结束时，用 <code>defer</code> 调用释放方法</strong></li></ol><h2 id=typescript如何实现raii>Typescript如何实现RAII</h2><p>同样，Typescript也是我的主力语言。这里补充一些说明。</p><h3 id=通过类封装--dispose-方法>通过类封装 + dispose 方法</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#cf222e>class</span> <span style=color:#1f2328>FileResource</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>private</span> <span style=color:#1f2328>handle</span>: <span style=color:#cf222e>any</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>constructor</span><span style=color:#1f2328>(</span><span style=color:#1f2328>path</span>: <span style=color:#cf222e>string</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#57606a>// 模拟打开文件
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>        <span style=color:#1f2328>console</span><span style=color:#1f2328>.</span><span style=color:#1f2328>log</span><span style=color:#1f2328>(</span><span style=color:#0a3069>`Opening file: </span><span style=color:#0a3069>${</span><span style=color:#1f2328>path</span><span style=color:#0a3069>}</span><span style=color:#0a3069>`</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>this</span><span style=color:#1f2328>.</span><span style=color:#1f2328>handle</span> <span style=color:#0550ae>=</span> <span style=color:#1f2328>{</span> <span style=color:#1f2328>path</span> <span style=color:#1f2328>};</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>read() {</span>
</span></span><span style=display:flex><span>        <span style=color:#1f2328>console</span><span style=color:#1f2328>.</span><span style=color:#1f2328>log</span><span style=color:#1f2328>(</span><span style=color:#0a3069>`Reading file: </span><span style=color:#0a3069>${</span><span style=color:#cf222e>this</span><span style=color:#1f2328>.</span><span style=color:#1f2328>handle</span><span style=color:#1f2328>.</span><span style=color:#1f2328>path</span><span style=color:#0a3069>}</span><span style=color:#0a3069>`</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>dispose() {</span>
</span></span><span style=display:flex><span>        <span style=color:#1f2328>console</span><span style=color:#1f2328>.</span><span style=color:#1f2328>log</span><span style=color:#1f2328>(</span><span style=color:#0a3069>`Closing file: </span><span style=color:#0a3069>${</span><span style=color:#cf222e>this</span><span style=color:#1f2328>.</span><span style=color:#1f2328>handle</span><span style=color:#1f2328>.</span><span style=color:#1f2328>path</span><span style=color:#0a3069>}</span><span style=color:#0a3069>`</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>this</span><span style=color:#1f2328>.</span><span style=color:#1f2328>handle</span> <span style=color:#0550ae>=</span> <span style=color:#cf222e>null</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=使用时结合-tryfinally>使用时结合 try/finally</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#cf222e>function</span> <span style=color:#1f2328>processFile</span><span style=color:#1f2328>(</span><span style=color:#1f2328>path</span>: <span style=color:#cf222e>string</span><span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>const</span> <span style=color:#1f2328>file</span> <span style=color:#0550ae>=</span> <span style=color:#cf222e>new</span> <span style=color:#1f2328>FileResource</span><span style=color:#1f2328>(</span><span style=color:#1f2328>path</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>try</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#1f2328>file</span><span style=color:#1f2328>.</span><span style=color:#1f2328>read</span><span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span>        <span style=color:#57606a>// 其他操作
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    <span style=color:#1f2328>}</span> <span style=color:#cf222e>finally</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#1f2328>file</span><span style=color:#1f2328>.</span><span style=color:#1f2328>dispose</span><span style=color:#1f2328>();</span> <span style=color:#57606a>// 确保资源释放
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1f2328>processFile</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;data.txt&#34;</span><span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=总结-1>总结</h3><ul><li><strong>构造函数负责获取资源</strong></li><li><strong><code>dispose()</code> 方法负责释放资源</strong></li><li><strong>作用域结束用 <code>try/finally</code> 调用 <code>dispose()</code></strong></li></ul><h1 id=智能指针基础>智能指针基础</h1><p>智能指针是基于RAII对动态内存管理的一种实践。目标是：</p><ul><li>明确 <strong>对象所有权</strong></li><li>自动释放资源</li><li>提供异常安全保证</li><li>与 STL 容器、算法良好协作</li></ul><p>掌握智能指针的使用，基本是C++最基础的基础功。我们这篇文章讲解上则要相对更深入一些。</p><h2 id=unique_ptr><code>unique_ptr</code></h2><h3 id=核心语义>核心语义</h3><p><strong>独占所有权（Exclusive Ownership）</strong></p><p>同一时刻，只能有一个 <code>unique_ptr</code> 拥有对象。<strong>不可拷贝，但可以移动</strong> 。（关于C++移动语义，是现代C++的核心特性，本身也有较多的内容，等有空再补充对应的文章吧。可以简单理解为 <strong>移动=内存的复用</strong> ，这个机制主要用来解决C++语言定义下大量临时对象所有权转移产生的开销。而rust受此印象，以转移语义为基础设计了语言）</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>unique_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> p<span style=color:#1f2328>(</span><span style=color:#cf222e>new</span> Foo<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>unique_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> p1 <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>make_unique<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>unique_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> p2 <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>move<span style=color:#1f2328>(</span>p1<span style=color:#1f2328>);</span> <span style=color:#57606a>// OK
</span></span></span></code></pre></td></tr></table></div></div><h3 id=内存模型>内存模型</h3><p><code>unique_ptr</code> <strong>几乎等价于一个裸指针 + deleter</strong></p><ul><li>不含引用计数</li><li>零额外堆分配（默认）</li><li>通常可以被优化为 <strong>零成本抽象</strong><ul><li>注：如果自定义deleter，则还额外包含一个deleter的指针。</li></ul></li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>template</span><span style=color:#0550ae>&lt;</span><span style=color:#cf222e>class</span> <span style=color:#1f2328>T</span><span style=color:#1f2328>,</span> <span style=color:#cf222e>class</span> <span style=color:#1f2328>Deleter</span><span style=color:#0550ae>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>class</span> <span style=color:#1f2328>unique_ptr</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    T<span style=color:#0550ae>*</span> ptr<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    Deleter del<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><p>注意： <strong>Deleter 是 <code>unique_ptr</code> 类型的一部分</strong> 会影响 sizeof</p><h3 id=自定义-deleter重点>自定义 deleter（重点）</h3><p>可以使用函数对象（lambda）定义deleter：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>auto</span> deleter <span style=color:#0550ae>=</span> <span style=color:#1f2328>[](</span>Foo<span style=color:#0550ae>*</span> p<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>cout <span style=color:#0550ae>&lt;&lt;</span> <span style=color:#0a3069>&#34;custom delete</span><span style=color:#0a3069>\n</span><span style=color:#0a3069>&#34;</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>delete</span> p<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>unique_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#1f2328>,</span> <span style=color:#cf222e>decltype</span><span style=color:#1f2328>(</span>deleter<span style=color:#1f2328>)</span><span style=color:#0550ae>&gt;</span> p<span style=color:#1f2328>(</span><span style=color:#cf222e>new</span> Foo<span style=color:#1f2328>,</span> deleter<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><p>适配非 <code>new/delete</code> 资源</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>unique_ptr<span style=color:#0550ae>&lt;</span>FILE<span style=color:#1f2328>,</span> <span style=color:#cf222e>decltype</span><span style=color:#1f2328>(</span><span style=color:#0550ae>&amp;</span>fclose<span style=color:#1f2328>)</span><span style=color:#0550ae>&gt;</span> fp<span style=color:#1f2328>(</span>fopen<span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;a.txt&#34;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#34;r&#34;</span><span style=color:#1f2328>),</span> fclose<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>注：这里 <code>fopen</code> 返回的是 <code>FILE*</code> 类型。</li></ul><h3 id=使用场景>使用场景</h3><ul><li>单一持有者</li><li>容器中存放</li><li>高性能</li><li>不共享生命周期</li></ul><h2 id=shared_ptr><code>shared_ptr</code></h2><h3 id=核心语义-1>核心语义</h3><p><strong>共享所有权（Shared Ownership）</strong></p><ul><li>包含引用计数</li><li>对象在 <strong>最后一个 <code>shared_ptr</code> 销毁时释放</strong>。</li></ul><h3 id=内存模型-1>内存模型</h3><p><code>shared_ptr</code> 的关键在于 <strong>控制块</strong>（Control Block） 。每个具体指针(ptr) 的 <code>shared_ptr</code> 会共享一个控制块。同时 <code>shared_ptr</code> 为了符合多线程模型，对控制块的操作定义了原子操作。</p><p>控制块通常包含：</p><ul><li>强引用计数（use_count）</li><li>弱引用计数（weak_count）</li><li>deleter</li><li>allocator（可能）</li></ul><p>内存结构：</p><pre tabindex=0><code>┌────────────┐        ┌─────────────────┐
│ shared_ptr │ ────▶  │ control block   │
└────────────┘        │  strong count   │ (control block 也有大概率内嵌object)
            │         │  weak count     │
            │         │  deleter        │
	        │         └─────────────────┘
		    │
		    ▼
		  ┌────────┐
		  │ object │
		  └────────┘
</code></pre><p>解释：</p><ol><li>control block 再第一次创建 <code>shared_ptr</code> 的时候，和对象内存同时创建。因此创建到一起只会有一次内存分配。因此，control block这个模板类提供了一个封装，通常会内嵌一个object。（尤其是通过 <code>make_shared</code> 和 <code>allocate_shared</code> 创建的 <code>shared_ptr</code> ；当然如果是传入的裸指针，那么不在额外分配对象的内存)<ol><li>但是随后基于同一个智能指针创建的 <code>shared_ptr</code> ，会共享这个control block。</li><li>注意：<strong>基于同一个裸指针创建的shared_ptr，并不会共享control block</strong> ，因为要支持这个操作明显需要查表，性能上不会允许这么做。这样的用法也是错误用法。</li></ol></li><li>如果创建的时候指定了 allocator，那么allocator的引用（指针）也会保存在 control block中。 <code>shared_ptr</code> 会在释放的时候调用allocator。</li><li>如果创建的时候指定了 <code>deleter</code> ，类似allocator，也是在释放的时候使用。</li></ol><h3 id=自定义deleterallocator>自定义deleter/allocator</h3><p>自定义deleter，类似 <code>unique_ptr</code> ，但要注意 <code>make_shared</code> 调用无法自定义deleter。</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>shared_ptr<span style=color:#0550ae>&lt;</span>FILE<span style=color:#0550ae>&gt;</span> fp<span style=color:#1f2328>(</span>
</span></span><span style=display:flex><span>    fopen<span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;a.txt&#34;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#34;r&#34;</span><span style=color:#1f2328>),</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>[](</span>FILE<span style=color:#0550ae>*</span> f<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span>f<span style=color:#1f2328>)</span> fclose<span style=color:#1f2328>(</span>f<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>shared_ptr&lt;T></code> <strong>始终持有的是 <code>T*</code></strong></li><li>deleter：<ul><li>只存 <strong>一份</strong>（在 control block 中）</li><li>被 <strong>所有共享该 control block 的 shared_ptr 使用</strong></li></ul></li><li>当 <code>use_count == 0</code> 时：<ul><li>control block 调用 deleter 销毁对象</li></ul></li></ul><p>注意： <strong>deleter 被 类型擦除（type-erased）</strong> 即deleter的类型并不会让 <code>shared_ptr</code> 的类型发生改变（即该模板参数不影响模板类型定义）。这个做法和 <code>unique_ptr</code> 是不一样的，这是因为 <code>shared_ptr</code> 要支持赋值语义，为了更方便支持跟不包含deleter定义的ptr兼容，必须要擦除掉deleter的类型。deleter具体的实现方式是通过虚函数或函数指针表 ，具体这里不展开。</p><p>此外，<code>shared_ptr</code> 还支持传入allocator：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>allocator<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> alloc<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>shared_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> sp<span style=color:#1f2328>(</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>new</span> Foo<span style=color:#1f2328>,</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>[](</span>Foo<span style=color:#0550ae>*</span> p<span style=color:#1f2328>)</span> <span style=color:#1f2328>{</span> <span style=color:#cf222e>delete</span> p<span style=color:#1f2328>;</span> <span style=color:#1f2328>},</span>
</span></span><span style=display:flex><span>    alloc
</span></span><span style=display:flex><span><span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>重要语义（必须理解）</strong></p><ul><li>allocator <strong>只用于 control block</strong></li><li><strong>不负责 object</strong></li><li>object 的释放由 deleter 决定</li></ul><p>更加推荐的用法 <code>allocate_shared</code>:</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#57606a>// template&lt;class T, class A, class... Args&gt;
</span></span></span><span style=display:flex><span><span style=color:#57606a>// shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>polymorphic_allocator<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> alloc<span style=color:#1f2328>{</span>resource<span style=color:#1f2328>};</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>auto</span> sp <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>allocate_shared<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span>alloc<span style=color:#1f2328>,</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>allocator用于同时创建 control block 和 object 。且仅进行1次分配。</li><li>异常安全。</li></ul><p>常见误区：</p><ul><li>误区 1：allocator 控制 object 生命周期 （正解：仅控制control block，除非用 <code>allocate_shared</code>）</li><li>误区 2：每个 shared_ptr 都有自己的 deleter / allocator （正解：每个control block一份）</li><li>误区 3：make_shared 比 shared_ptr(p, d) 慢： （正解：通常更快，因为仅一次分配）</li></ul><p>使用建议：</p><div class=table-wrapper><table><thead><tr><th>需求</th><th>推荐方案</th></tr></thead><tbody><tr><td>普通共享对象</td><td><code>make_shared</code></td></tr><tr><td>需要自定义释放</td><td><code>shared_ptr(p, deleter)</code></td></tr><tr><td>高性能内存管理</td><td><code>allocate_shared</code> + pmr</td></tr><tr><td>管理 C 资源</td><td><code>shared_ptr&lt;T>(p, deleter)</code></td></tr><tr><td>对象池</td><td>自定义 deleter</td></tr></tbody></table></div><h3 id=循环引用问题重点>循环引用问题（重点）</h3><p>因为 <code>shared_ptr</code> 靠引用计数管理，因此，循环引用会造成内存泄露。</p><p>假设我们有三个对象 A, B, C，每个对象都持有 <code>shared_ptr</code> 指向下一个对象：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>auto</span> a <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>make_shared<span style=color:#0550ae>&lt;</span>Node<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;A&#34;</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>auto</span> b <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>make_shared<span style=color:#0550ae>&lt;</span>Node<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;B&#34;</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>auto</span> c <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>make_shared<span style=color:#0550ae>&lt;</span>Node<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;C&#34;</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// 构建循环引用：A -&gt; B -&gt; C -&gt; A
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>    a<span style=color:#0550ae>-&gt;</span>next <span style=color:#0550ae>=</span> b<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    b<span style=color:#0550ae>-&gt;</span>next <span style=color:#0550ae>=</span> c<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    c<span style=color:#0550ae>-&gt;</span>next <span style=color:#0550ae>=</span> a<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// 离开作用域
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>当创建结束时，每个对象引用计数是1</li><li>当互相持有时，每个对象引用计数是2</li><li>离开作用域时：（仅减少自身计数）<ul><li>于是，A，B，C引用计数均减1，最后仍然有1个引用计数。导致内存泄露。</li></ul></li></ul><p>而如果没有构成循环，比如 <code>A->B->C</code> 的情况下：</p><ul><li>A引用计数1，B和C引用计数为2.</li><li>离开作用域时:<ul><li>A计数归零，导致A节点被析构</li><li>此时才会触发 <code>a->next</code> 被析构，从而进一步降低B的引用计数，最终整体都成功析构</li></ul></li></ul><p>上面的根本原因是： <strong>循环引用阻碍了对象自身的析构，而对象自身析构又是触发成员 shared_ptr 析构的前提，因此成员 shared_ptr 永远不会被释放，从而导致内存泄漏。</strong></p><p>如何解决这个问题？避免互相持有的语义，而使用 <code>weak_ptr</code> 的引用语义。严格区分什么时候持有，什么时候引用。</p><h2 id=weak_ptr><code>weak_ptr</code></h2><h3 id=核心语义-2>核心语义</h3><p><strong>观察者，不拥有对象</strong></p><ul><li>不增加强引用计数</li><li>用于打破循环引用</li></ul><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#57606a>// 可以通过 shared_ptr 直接创建
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>std<span style=color:#0550ae>::</span>weak_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> wp <span style=color:#0550ae>=</span> sp<span style=color:#1f2328>;</span> <span style=color:#57606a>// 拷贝初始化 copy-initialization。（不一定调用拷贝构造函数，同时一般也不会拷贝，因为有copy elision；所以说这个初始化名字确实很误导人；这个用法和使用参数初始化用法没有本质区别）
</span></span></span><span style=display:flex><span><span style=color:#57606a></span>
</span></span><span style=display:flex><span><span style=color:#57606a>// 可以通过 lock 返回 shared_ptr
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span><span style=color:#cf222e>auto</span> sp <span style=color:#0550ae>=</span> wp<span style=color:#1f2328>.</span>lock<span style=color:#1f2328>())</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    sp<span style=color:#0550ae>-&gt;</span>do_something<span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当然因为其不拥有对象，所以不涉及到 deleter 和 allocator 的设定。</p><h3 id=内存模型-2>内存模型</h3><p>和 <code>shared_ptr</code> 一样共享 control block。只不过使用的是weak count。</p><p>当然只有存在了 <code>shared_ptr</code> 才能创建 <code>weak_ptr</code></p><h3 id=使用场景-1>使用场景</h3><div class=table-wrapper><table><thead><tr><th>场景</th><th>用途</th></tr></thead><tbody><tr><td>父子节点</td><td>子引用父</td></tr><tr><td>缓存</td><td>非拥有引用</td></tr><tr><td>观察者模式</td><td>observer</td></tr></tbody></table></div><h2 id=如何配合pmrmemory_resource-使用>如何配合<code>pmr::memory_resource</code> 使用？</h2><h3 id=unique_ptr--pmr>unique_ptr + pmr</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>struct</span> <span style=color:#1f2328>PmrDeleter</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>memory_resource<span style=color:#0550ae>*</span> res<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>void</span> <span style=color:#6639ba>operator</span><span style=color:#1f2328>()(</span>Foo<span style=color:#0550ae>*</span> p<span style=color:#1f2328>)</span> <span style=color:#cf222e>noexcept</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>        p<span style=color:#0550ae>-&gt;~</span>Foo<span style=color:#1f2328>();</span>
</span></span><span style=display:flex><span>        res<span style=color:#0550ae>-&gt;</span>deallocate<span style=color:#1f2328>(</span>p<span style=color:#1f2328>,</span> <span style=color:#cf222e>sizeof</span><span style=color:#1f2328>(</span>Foo<span style=color:#1f2328>),</span> <span style=color:#cf222e>alignof</span><span style=color:#1f2328>(</span>Foo<span style=color:#1f2328>));</span>
</span></span><span style=display:flex><span>    <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>};</span>
</span></span></code></pre></td></tr></table></div></div><p>使用：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#cf222e>void</span><span style=color:#0550ae>*</span> mem <span style=color:#0550ae>=</span> res<span style=color:#0550ae>-&gt;</span>allocate<span style=color:#1f2328>(</span><span style=color:#cf222e>sizeof</span><span style=color:#1f2328>(</span>Foo<span style=color:#1f2328>),</span> <span style=color:#cf222e>alignof</span><span style=color:#1f2328>(</span>Foo<span style=color:#1f2328>));</span>
</span></span><span style=display:flex><span>Foo<span style=color:#0550ae>*</span> f <span style=color:#0550ae>=</span> <span style=color:#cf222e>new</span> <span style=color:#1f2328>(</span>mem<span style=color:#1f2328>)</span> Foo<span style=color:#1f2328>(</span><span style=color:#0550ae>1</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#0550ae>::</span>unique_ptr<span style=color:#0550ae>&lt;</span>Foo<span style=color:#1f2328>,</span> PmrDeleter<span style=color:#0550ae>&gt;</span> p<span style=color:#1f2328>(</span>f<span style=color:#1f2328>,</span> <span style=color:#1f2328>{</span>res<span style=color:#1f2328>});</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=shared_ptr--pmr>shared_ptr + pmr</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>polymorphic_allocator<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span> alloc<span style=color:#1f2328>{</span>resource<span style=color:#1f2328>};</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>auto</span> p <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>allocate_shared<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span>alloc<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=高性能场景示例对象池>高性能场景示例（对象池）</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>unsynchronized_pool_resource pool<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>auto</span> alloc <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>pmr<span style=color:#0550ae>::</span>polymorphic_allocator<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span><span style=color:#0550ae>&amp;</span>pool<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>auto</span> p <span style=color:#0550ae>=</span> std<span style=color:#0550ae>::</span>allocate_shared<span style=color:#0550ae>&lt;</span>Foo<span style=color:#0550ae>&gt;</span><span style=color:#1f2328>(</span>alloc<span style=color:#1f2328>);</span>
</span></span></code></pre></td></tr></table></div></div><p>适用于：</p><ul><li>游戏引擎</li><li>高频交易</li><li>实时系统</li></ul><p>局限性和注意：</p><ul><li><strong>对象大小不固定时效率下降</strong><ul><li><code>unsynchronized_pool_resource</code> 内部使用多个 block size</li><li>对象大小大于 block → heap fallback</li><li>对象非常小 → 内存可能浪费</li></ul></li><li><strong>缺少固定大小对象池的确定性</strong><ul><li>对固定大小对象池：<ul><li>分配/释放非常快，O(1)</li><li>内存紧凑，没有分块浪费</li><li>可控内存上限，避免 heap 扩张</li></ul></li><li><code>unsynchronized_pool_resource</code> 更通用，但可能有少量 overhead</li></ul></li><li><strong>多线程需要注意</strong><ul><li><code>unsynchronized_pool_resource</code> <strong>不是线程安全的</strong></li><li>多线程共享必须使用 <code>synchronized_pool_resource</code> 或自定义同步</li></ul></li></ul><h2 id=最佳实践>最佳实践</h2><div class=table-wrapper><table><thead><tr><th>场景 / 特点</th><th>推荐智能指针</th></tr></thead><tbody><tr><td>单一所有权、局部对象</td><td><code>unique_ptr</code></td></tr><tr><td>多处共享、生命周期复杂</td><td><code>shared_ptr + weak_ptr</code></td></tr><tr><td>临时访问共享对象</td><td><code>weak_ptr</code></td></tr><tr><td>高频分配 / 内存池 / 对象内嵌控制块</td><td><code>allocate_shared + PMR</code></td></tr></tbody></table></div><p>一种常见的做法：</p><ul><li>高层对象持有低层对象 ，使用 <code>unique_ptr</code> / shared_ptr （尽可能更多使用 <code>unique_ptr</code>）</li><li>低层对象引用高层对象 ，使用 <code>weak_ptr</code></li></ul><h1 id=垃圾回收机制基础-garbage-collection>垃圾回收机制基础 (Garbage Collection)</h1><p>垃圾回收机制（Garbage Collection，简称 <strong>GC</strong>）是计算机科学中的一种内存管理技术，它的核心目标是<strong>自动回收</strong>程序中不再使用的内存空间。</p><p>GC机制通过<strong>自动判断</strong>哪些内存是“垃圾”（即程序后续不会再访问的对象），并将其清理掉，从而避免了这些问题，极大地减轻了开发者的负担。</p><p>在 C++ 中，<strong>原生语言并不自带 GC</strong>，内存管理主要依靠手动管理 (<code>new/delete</code>) 或智能指针（如 <code>std::shared_ptr</code>、<code>std::unique_ptr</code>）。</p><p>但为了应对复杂对象图、循环引用等问题，也有一些 C++ GC 框架或技术存在（如 <strong>Boehm GC</strong> 或 Unreal Engine 的 UObject GC）。</p><p>基本思路仍与传统 GC 相似：<strong>标记可达对象、回收不可达对象</strong>。</p><h2 id=主要的gc算法>主要的GC算法</h2><h3 id=mark-sweep算法>Mark-Sweep算法</h3><p><strong>Mark-Sweep</strong> 是最基础的垃圾回收算法，原理如下：</p><ol><li><strong>Mark（标记阶段）</strong><br>从根对象（stack/global/static）出发，递归标记所有可达对象。</li><li><strong>Sweep（清扫阶段）</strong><br>扫描堆中所有对象，将未被标记的对象回收。</li></ol><p>优缺点：</p><ul><li><strong>优点:</strong> 实现简单。</li><li><strong>缺点:</strong> 会产生大量的<strong>内存碎片</strong>，导致后续分配大对象时可能没有足够的连续空间。</li></ul><h3 id=copying算法>Copying算法</h3><p>将内存分为大小相等的两块，每次只使用其中一块。当这块用完时，将<strong>存活对象</strong>复制到另一块上，然后清空当前块。</p><p>优缺点：</p><ul><li>优点: 不产生碎片，回收效率高。</li><li>缺点: 内存利用率低，永远只有一半内存可用。常用于对象生命周期很短的新生代。</li></ul><h3 id=mark-compact算法>Mark-Compact算法</h3><p>分为“标记”和“整理”两个阶段：</p><ol><li><strong>标记</strong>所有可达对象。</li><li><strong>整理</strong>（移动）所有存活对象，使其向一端移动，然后清理掉边界以外的内存。</li></ol><p>优缺点：</p><ul><li>优点: 不产生碎片。</li><li>缺点: 移动对象需要进行大量的引用更新，效率较低。常用于对象生命周期较长的老年代。</li></ul><h3 id=stop-the-world-stw>Stop-The-World (STW)</h3><p>在执行 GC 时，为了保证数据的一致性，有时需要暂停所有的应用线程，直到垃圾回收工作完成，这个现象称为 Stop-The-World (STW)。</p><p>STW 是所有 GC 机制都无法避免的，但现代 GC 算法（如 G1、ZGC、Shenandoah）通过并发（与应用线程同时运行）和增量（分小片执行）等技术，已经将 STW 的时间降到极低，从而减少对用户程序的影响。</p><h2 id=精确gc和保守gc>精确GC和保守GC</h2><ul><li><strong>精确式 GC (Accurate/Precise GC)</strong> :<ul><li>在内存中，每个对象通常包含<strong>字段</strong>，这些字段可能是：对象引用（指针）或原始数据。</li><li>精确GC的特点是：GC <strong>完全知道</strong>对象中哪些字段是指针，哪些是非指针值</li><li>在标记阶段，只跟踪指针字段来判断可达对象</li><li>非指针字段（整数、浮点数）不会被当作指针误判</li><li>通常有rootset，从rootset的对象出发，进行mark标记。</li></ul></li><li><strong>保守式 GC (Conservative GC)</strong> : Boehm GC 运行在 C/C++ 这样的环境中<ul><li>无法完全确定内存中的一个值是否真的是一个指针。</li><li>一个 32 位的整数和一个恰好指向堆内存的地址值在位模式上可能是完全相同的。</li><li>保守策略：任何看起来像指针的值，<strong>都会被当作指针来处理</strong>。 （会导致一些整数有一定概率被当作堆上的指针，从而让对应的指针被mark，而不被释放）</li></ul></li></ul><h2 id=标记数据的存储方式>标记数据的存储方式</h2><h3 id=对象头object-header标记>对象头（Object Header）标记</h3><p>大多数 JVM 和一些 C++ GC（如 UE GC）在<strong>每个对象头</strong>存储一个或几个标志位，用于记录对象是否被标记。</p><ul><li>优点：<ul><li>内存访问局部化</li><li>标记直接在对象上修改，快速</li></ul></li><li>缺点：<ul><li>每个对象增加头部开销（通常 1–2 字节）</li><li>并发 GC 需要注意写屏障，防止覆盖标记</li></ul></li></ul><p><strong>示例（Java 对象头）</strong>：</p><pre tabindex=0><code>[Mark Word | Klass Pointer | Fields...]
Mark Word 可以包含：
- hashcode
- GC 标记位
- 偏向锁标志等
</code></pre><h3 id=外部标记表bit-map--side-table>外部标记表（Bit Map / Side Table）</h3><p>GC 维护一张单独的<strong>位图（bitmap）</strong> 或数组， 每个堆对象对应一位或几位表示是否被标记 。</p><ul><li>优点：<ul><li>不修改对象头，适合只读或不可修改对象</li><li>并发 GC 易于管理，多线程安全</li></ul></li><li>缺点：<ul><li>需要额外内存</li><li>访问对象标记需要间接索引 ： 可能降低访问效率</li></ul></li></ul><p>当然仅靠这个表也不够，因为不知道对象在堆上具体占有的空间大小。通常还要配合对象头，或者额外的其他信息表才行。</p><h3 id=两种方式结合hybrid>两种方式结合（Hybrid）</h3><p>JVM 一些实现（如 HotSpot）：</p><ul><li>对象头存放部分标记信息（快速、短期标记）</li><li>对于并发或增量 GC，额外使用 bit map / remembered set 保存标记变化</li></ul><h2 id=boehm-gc>Boehm GC</h2><p>Boehm-Demers-Weiser Garbarge Collector（简称 <strong>Boehm GC</strong>）是一个非常独特且具有历史意义的垃圾回收器。</p><p>Boehm GC 采用标准的<strong>可达性分析</strong>来判断对象存活，但其根集（GC Roots）的确定方式是保守的：</p><h3 id=算法过程>算法过程</h3><ul><li><p><strong>确定根集 (Roots):</strong></p><ul><li><strong>全局变量区 (Static Data):</strong> 扫描所有静态/全局变量的值。</li><li><strong>栈 (Stack):</strong> 扫描当前所有线程的栈帧中的值。</li><li><strong>寄存器 (Registers):</strong> 扫描所有 CPU 寄存器中的值。</li></ul></li><li><p><strong>保守扫描 (Conservative Scan):</strong></p><ul><li>在上述所有根集区域中，如果一个内存地址中的值 $V$ 落在当前的堆分配区域内（即 $V$ 是一个有效的堆地址），则<strong>保守地认为 $V$ 是一个指向堆对象的指针</strong>。</li><li>即使 $V$ 实际上是一个非指针数据，它指向的对象也会被标记为存活。</li></ul></li><li><p><strong>标记过程 (Marking):</strong></p><ul><li>从所有被识别的“指针”开始，递归地遍历和标记它们所指向的对象及其所有内部字段。</li><li><strong>内部指针 (Interior Pointers):</strong> Boehm GC 允许一个指针指向一个对象的<strong>内部</strong>（比如 C++ 中指向数组中间元素的指针）。因此，它需要维护一个数据结构来快速查找：给定一个地址，它是哪个对象的内部？（通常使用平衡树或哈希表来实现）。</li></ul></li></ul><h3 id=标记如何存储>标记如何存储</h3><ul><li><p><strong>位图（Bitmap）</strong></p><ul><li>堆被分割成 <strong>分配块（allocation blocks）</strong> 或 <strong>页面（page）</strong>。</li><li>每个块对应一个位或几个位，用来表示块内对象是否被标记。</li><li>当对象被扫描到时，对应的位被置为“已标记（marked）”。</li><li>位图通常在 <strong>堆管理结构中维护</strong>，而不是在对象本身。</li></ul></li><li><p><strong>对象头（Object Header）</strong></p><ul><li>对于需要额外信息的对象（例如可移动或需要快速大小查找的对象），Boehm GC 会在对象前面保留一个小的 <strong>header</strong>。</li><li>Header 通常包含：<ul><li>对象大小</li><li>类型信息（可选）</li><li>标记位（有时用于快速扫描）</li></ul></li><li>但是 Boehm GC 的默认策略是 <strong>尽量不修改对象布局</strong>，所以大部分标记信息是在 GC 内部的数据结构中维护的，而不是每个对象中。</li></ul></li><li><p><strong>内部数据结构</strong></p><ul><li>Boehm GC 会维护一个 <strong>哈希表或平衡树</strong> 来快速查找堆对象及其状态：<ul><li>给定一个内存地址，判断它是否属于堆。</li><li>判断对象是否已经被标记。</li></ul></li><li>这样在 <strong>保守扫描</strong>时，找到一个可能的指针，就可以在内部结构中标记对应对象。</li></ul></li></ul><h3 id=如何知道对象的大小>如何知道对象的大小</h3><h4 id=自己记录大小>自己记录大小</h4><p><strong>每次分配时（<code>GC_malloc</code>）</strong>，Boehm GC 会在内部维护：</p><ul><li>对象起始地址</li><li>对象大小
这可以通过 <strong>哈希表/平衡树/链表</strong> 实现</li></ul><p>当扫描到一个可能的指针时：查找哈希表， 得到对象起始地址， 再得到大小</p><p>这也是处理 <strong>内部指针（interior pointer）</strong> 的关键：</p><ul><li>如果指针指向对象中间，GC 会查找该地址对应的整个对象，从而知道对象的边界和大小。</li></ul><h4 id=在对象前面加-header可选>在对象前面加 header（可选）</h4><p>对象前面存一个小 header，记录对象大小。</p><p>对于 C/C++，Boehm GC 尽量不做，因为会改变对象布局，影响程序。</p><p>大部分情况下，GC 使用自己的堆元信息（heap metadata）来存储大小，而不是对象本身。</p><h3 id=应用>应用</h3><p>由于 Boehm GC 是一个稳定且经过充分测试的<strong>保守式</strong> GC，它被用作许多早期的或跨平台运行时环境的基础，尤其是那些需要在原生代码上运行的语言：</p><ul><li><p><strong>早期的 Unity/Mono 运行时:</strong></p><ul><li>在 Unity 引擎的早期版本（如 1.x 到 2.x，以及一些通过 <strong>IL2CPP</strong> 编译的 Unity 工程）中，Mono 虚拟机（Microsoft .NET 移植平台）最初使用的是 <strong>Boehm GC</strong> 作为其托管堆的垃圾回收器。</li><li>后来，Mono 切换到了更现代的 <strong>SGen GC</strong>，但 Boehm GC 在这个领域留下了深远影响。</li></ul></li><li><p><strong>GNU Java 编译器运行时环境 (GCJ):</strong></p><ul><li>GCJ 是 GNU 编译器集合（GCC）的一部分，它能够将 Java 源代码编译成本地机器代码。在它的运行时环境中，Boehm GC 被用于管理 Java 对象的内存。</li></ul></li><li><p><strong>D 语言:</strong></p><ul><li><strong>D 语言</strong>是一种旨在结合 C++ 性能和 Java/C# 安全性的系统级编程语言。在其早期实现中，Boehm GC 是其默认的垃圾回收器。</li></ul></li><li><p><strong>各种脚本语言和解释器:</strong></p><ul><li>一些需要在 C/C++ 核心上实现的脚本语言（如一些 Lisp、Scheme 或 Smalltalk 的实现），可能会选择使用 Boehm GC 来快速为其提供内存管理能力。</li></ul></li></ul><p>总结： <strong>Boehm GC，更加适用于开发一个语言编译器或者解释器的时候，采用的简单技术</strong> 。后续迭代的时候，则需要完善语言的对象系统，从而嵌入更加高级的GC，比如SGen GC</p><h2 id=unreal-engine-uobject-gc>Unreal Engine UObject GC</h2><p>Unreal Engine (UE) 的垃圾回收系统专为游戏的高性能和确定性需求设计。它主要针对继承自 <code>UObject</code> 类的对象进行管理，采用<strong>非自动的引用计数机制（<code>TWeakObjectPtr</code>, <code>TSoftObjectPtr</code>）<strong>与</strong>精确的 Mark-Sweep 机制</strong>相结合的方式。</p><h3 id=算法过程-1>算法过程</h3><p>UE 的 GC 流程与传统的 Mark-Sweep 类似，但其触发和根集确定与 C++ 环境高度集成。</p><h4 id=确定根集-gc-roots>确定根集 (GC Roots)</h4><p>UE 的 GC Roots 是<strong>精确</strong>的，而不是保守的。它依赖于 UE 对象系统（<code>UObject</code>）和其特殊的指针类型（<code>TArray</code>, <code>TMap</code>, <code>UPROPERTY</code> 宏等）来精确识别哪些对象被持有。</p><p><strong>全局根集 (Global Roots):</strong></p><ul><li>所有<strong>当前正在引用的</strong>（例如，通过 <code>AddToRoot()</code> 或作为全局结构的一部分）对象。</li><li><strong>Persistent Roots:</strong> 如 <code>UWorld</code>、<code>UGameInstance</code> 等顶级对象。</li><li>任何嵌入在 <code>UObject</code> 的 UPROPERTY 成员指针也间接形成可达链，但根对象本身通常是这些全局/持久对象。</li></ul><p><strong>栈/局部变量 (Stack/Local Variables):</strong></p><ul><li><strong><code>UObject</code> 指针的局部变量通常不会被视为 GC Roots</strong>。UE GC 是<strong>不安全</strong>的，因为它不会扫描 C++ 栈或寄存器。（因此这个GC无法支持多线程）</li><li><strong>唯一例外</strong>：通过 <code>TGuardValue</code> 或特定的 GC 保护机制（如 <strong>Fast Path</strong>）显式添加到根集的对象。</li></ul><p><strong>属性引用 (Property References):</strong></p><ul><li>通过反射系统（<strong>Reflection System</strong>）识别，所有被 <code>UPROPERTY()</code> 宏标记的指针字段，指向的对象都被视为可达。</li></ul><p>从这部分描述可以看出，UEGC本身被触发的时候，大部分运行栈应该已经退出，GC运行在更底层的栈上。因此不用考虑栈上的对象是否要添加到RootSet中。下面是AI的补充：</p><ul><li>栈上的局部变量确实不自动成为根，但如果你在 <code>AddReferencedObjects</code> 或 <code>FGCObject::AddReferencedObjects</code> 中引用了它们，它们就会被 GC 遍历。</li><li>所以在复杂系统中，如果临时对象需要在 GC 扫描期间存活，你必须用显式机制保护它。</li></ul><h4 id=标记阶段-marking>标记阶段 (Marking)</h4><p>从根集开始，GC 递归地遍历所有可达的 <code>UObject</code>。</p><ul><li><strong>遍历机制：</strong> GC 使用 <strong>Reflection</strong> 获得对象的类结构，并只沿着被 <code>UPROPERTY()</code> 宏标记的指针（属性）进行深度遍历。</li><li><strong>标记存储：</strong> 每个 <code>UObject</code> 的<strong>对象头（Header）<strong>中都包含一个</strong>标记位（Mark Bit）</strong>。当对象被遍历到时，该标记位会被设置（通常在 <code>GUObjectArray</code> 这个全局数据结构中）。</li></ul><h4 id=清扫阶段-sweeping>清扫阶段 (Sweeping)</h4><p>清扫阶段会遍历 GUObjectArray（全局对象列表），并处理所有未被标记的对象。</p><ul><li>未标记对象： 未被标记的对象被视为垃圾。<ul><li>首先，调用对象的 BeginDestroy() 生命周期方法，进行资源释放前的清理工作。</li><li>然后，对象的内存被释放，并从 GUObjectArray 中移除。</li></ul></li><li>被标记对象： 清除标记位，等待下一轮 GC。</li></ul><h3 id=应用与特点>应用与特点</h3><p>UE GC 是一个为<strong>游戏开发</strong>高度优化的 GC 系统。</p><ul><li><strong>精确性和可控性：</strong> GC 仅通过 <strong>Reflection</strong> 识别的指针进行遍历，因此它是<strong>精确</strong>的。GC 周期是<strong>可控</strong>的，不会在关键帧自动触发，而是由开发者在安全点（如关卡加载、帧结束等）手动或定时触发。</li><li><strong>性能优化：</strong> 标记和清扫可以进行**增量（Incremental）**操作，将工作分散到多帧中，以避免在游戏运行时造成卡顿（Stuttering）。</li><li><strong>处理循环引用：</strong> 传统的引用计数无法处理循环引用，但 UE GC 使用 <strong>Mark-Sweep</strong> 机制，能够优雅地回收相互引用的垃圾对象（A 引用 B，B 引用 A，但两者都不可达）。</li></ul><h3 id=对比boehm-gc>对比Boehm GC</h3><div class=table-wrapper><table><thead><tr><th><strong>特点</strong></th><th><strong>Boehm GC</strong></th><th><strong>Unreal Engine UObject GC</strong></th></tr></thead><tbody><tr><td><strong>解决的根本问题</strong></td><td>在 <strong>原生 C/C++ 环境</strong> 中，没有对象系统，栈和寄存器中可能的值类型不可知，<strong>如何安全地进行自动内存管理</strong>。</td><td>在 <strong>有反射的 C++ 框架</strong> 中，如何提供<strong>可控、增量、高性能</strong>的 GC，以避免游戏卡顿。</td></tr><tr><td><strong>GC 根集的复杂度</strong></td><td><strong>极高。</strong> 需要保守地扫描所有寄存器和栈上的内存地址，并判断其是否指向堆。这是<strong>实现最困难</strong>的部分，因为它跨越了 GC 和 CPU/OS 边界。</td><td><strong>低/中等。</strong> 根集是<strong>精确</strong>的，只扫描 <code>GUObjectArray</code> 和 <code>UPROPERTY</code> 标记的指针。复杂度在于<strong>集成 C++ 的反射系统</strong>。</td></tr><tr><td><strong>GC 触发与控制</strong></td><td>自动触发（<strong>Automatic</strong>）。当内存分配失败或达到阈值时运行，GC 暂停时间不可控。</td><td>手动或定时触发（<strong>Controlled</strong>）。由开发者决定何时运行，支持<strong>增量运行</strong>，需要复杂的调度系统。</td></tr><tr><td><strong>对象信息依赖</strong></td><td><strong>不依赖</strong>对象本身。所有元数据（大小、标记）都在 GC 内部的<strong>哈希表或平衡树</strong>中维护。</td><td><strong>高度依赖</strong> UE 的 <strong>Reflection System</strong> 和 <code>UObject</code> 的对象头。没有反射系统，GC 就无法工作。</td></tr><tr><td><strong>系统兼容性</strong></td><td><strong>高。</strong> 目标是尽可能不修改 C/C++ 程序的布局和语义。</td><td><strong>低。</strong> 仅适用于继承自 <code>UObject</code> 的对象，且必须使用 UE 的宏和指针类型。</td></tr></tbody></table></div><h2 id=java的gc>Java的GC</h2><p>为了确保 GC 能够准确、安全地工作，JVM 在代码编译、即时编译（JIT）和运行时中，会额外添加以下关键机制：</p><h3 id=safepoint安全点>SafePoint（安全点）</h3><p><strong>定义与目的：</strong> SafePoint 是 JVM 代码执行流中，一个允许 GC <strong>安全地</strong>和<strong>精确地</strong>检查所有线程栈和寄存器中 GC Root 引用位置的“暂停点”。</p><p>JVM 提供的机制：</p><ul><li><strong>指令插入：</strong> JVM 的 JIT 编译器（如 C2）会在方法调用、循环回跳（Loop Back Edge）、异常处理等<strong>非叶子方法</strong>的关键位置<strong>插入 SafePoint 检查指令</strong>。</li><li><strong>状态切换：</strong> 当 GC 准备运行时，它会发出请求，所有线程在执行到下一个 SafePoint 时，必须<strong>主动暂停</strong>（自愿合作）。</li></ul><p>为什么提供？</p><ul><li><strong>实现 STW (Stop-The-World)：</strong> GC 需要在短时间内冻结所有用户线程，以便进行<strong>精确</strong>的可达性分析和内存整理。SafePoint 是实现这一暂停的基础。</li><li><strong>保证引用可见性：</strong> 只有在 SafePoint 处，线程的执行状态是<strong>已知</strong>的（即所有 Java 引用都在明确的位置，如栈帧或寄存器中），GC 才能准确扫描。在其他任意位置暂停，可能导致 Java 引用被藏在 CPU 管道或临时寄存器中，GC 无法找到。</li></ul><h3 id=oopmap对象指针地图-livemap>OopMap（对象指针地图）/ LiveMap</h3><p><strong>定义与目的：</strong> OopMap（在 HotSpot JVM 中通常也称为 LiveMap 或 GC Map）是一种由 JIT 编译器生成的<strong>元数据</strong>，它描述了在特定 SafePoint 处，<strong>栈帧和寄存器中哪些值是 Java 对象指针（Oop, Ordinary Object Pointer）</strong>。</p><p>JVM 提供的机制：</p><ul><li><strong>编译期生成：</strong> JIT 编译器在生成机器码的同时，会为每个 SafePoint 生成一个 OopMap。</li><li><strong>运行时查询：</strong> 当一个线程在 SafePoint 暂停时，GC 线程会查阅该 SafePoint 对应的 OopMap。</li></ul><p>为什么提供？</p><ul><li><strong>实现精确 GC：</strong> OopMap 是 JVM 实现<strong>精确 GC</strong> 的关键。它告诉 GC ：“在这个线程的当前栈帧中，地址 $A$ 上的值是一个对象引用，地址 $B$ 上的值是一个整数，请只扫描 $A$。”</li><li><strong>避免保守扫描：</strong> 这与 Boehm GC 的<strong>保守扫描</strong>形成了鲜明对比。通过 OopMap，JVM 避免了猜测，从而保证了回收的<strong>正确性</strong>和<strong>高效性</strong>。</li></ul><h3 id=card-table--remembered-set记忆集>Card Table / Remembered Set（记忆集）</h3><p><strong>定义与目的：</strong> 这是 JVM 为了优化<strong>跨代引用</strong>（老年代对象引用了新生代对象）扫描而引入的机制，主要用于实现高效的<strong>分代 GC</strong>。</p><p>JVM 提供的机制：</p><ul><li><strong>写屏障（Write Barrier）插入：</strong> 在代码中执行<strong>指针赋值操作</strong>（例如 <code>a.field = b</code>）时，JIT 编译器会<strong>额外插入指令</strong>，将引用方的内存区域标记为“脏（Dirty）”。</li><li><strong>Card Table 维护：</strong> Card Table 是一个位图数组，代表老年代的内存块（Card）。如果老年代中的 Card 引用了新生代的对象，那么对应的位会被设置为脏。</li></ul><p>为什么提供？</p><ul><li><strong>加速 Young GC：</strong> 在进行新生代 GC (Minor GC) 时，GC 不需要扫描整个老年代来寻找跨代引用。它只需要扫描 Card Table 中被标记为“脏”的少数 Card，大大<strong>减少了根集的扫描范围</strong>，是分代 GC 高效运行的核心。</li></ul><h3 id=barrier屏障--特别是读写屏障>Barrier（屏障）- 特别是读写屏障</h3><p><strong>定义与目的：</strong> 屏障是一种特殊的、由编译器（JIT）或解释器在<strong>对象字段访问操作</strong>前后插入的底层代码指令。它们是实现复杂并发 GC（如 CMS、G1、ZGC、Shenandoah）的关键。</p><p><strong>JVM 提供的机制：</strong> 插入额外的代码或指令来跟踪对象的引用关系变化。</p><ul><li><strong>写屏障 (Write Barrier):</strong> 在<strong>引用赋值</strong>时插入。<ul><li>会在写入操作前增加一个 <code>write_barrier(A, C);</code> 的内联代码，判断要不要触发额外逻辑。（比如额外着色逻辑）。有多种类别的写屏障。</li></ul></li><li><strong>读屏障 (Read Barrier):</strong> 在<strong>读取对象字段</strong>时插入。<ul><li>同上类似，读取操作前内联一部分代码。比如像 <strong>ZGC/Shenandoah</strong> 这种<strong>并发移动</strong>的 GC，以确保用户线程在对象被 GC 移动时能拿到<strong>新的转发地址</strong>。 （通常并不会有锁，同时虽然有地址的差异，但程序上不可见，因为java语言访问不到物理地址）</li></ul></li></ul><p>为什么提供？</p><ul><li><strong>实现并发标记：</strong> 屏障让 GC 线程可以在用户线程运行时同时进行标记，通过记录用户线程对对象引用图的修改，来确保并发标记的正确性。</li><li><strong>实现并发整理：</strong> 读屏障使得 GC 可以在不暂停用户线程的情况下移动对象，解决了并发 GC 中最难的<strong>并发移动</strong>问题，从而实现了极低的 GC 暂停时间。</li></ul><h3 id=三色标记算法-tri-color-marking>三色标记算法 (Tri-color Marking)</h3><h4 id=三种颜色及其含义>三种颜色及其含义</h4><div class=table-wrapper><table><thead><tr><th><strong>颜色</strong></th><th><strong>含义</strong></th><th><strong>GC 状态</strong></th></tr></thead><tbody><tr><td><strong>白色 (White)</strong></td><td><strong>不可达对象</strong>。该对象尚未被 GC 访问，或最终被证明是不可达的。在标记阶段结束后，所有白色对象都是<strong>垃圾</strong>，将被回收。</td><td>待访问/垃圾</td></tr><tr><td><strong>灰色 (Gray)</strong></td><td><strong>正在访问的对象</strong>。该对象本身是活的，但它的<strong>引用字段（其包含的指针）还没有全部被扫描</strong>。灰色对象会继续被 GC 访问，直到其所有子对象都被处理完。</td><td>正在扫描</td></tr><tr><td><strong>黑色 (Black)</strong></td><td><strong>已访问对象</strong>。该对象是活的，且<strong>其所有引用字段（子对象）都已经被扫描完毕</strong>。黑色对象在本次 GC 周期内不会再被访问。</td><td>存活/已完成</td></tr></tbody></table></div><h4 id=算法过程-2>算法过程</h4><p>从 GC 根集（GC Roots）开始：</p><ol><li><strong>初始状态：</strong> 所有对象都是 <strong>白色</strong>。</li><li><strong>根集标记：</strong> 从 GC Roots 开始，将所有直接被根集引用的对象标记为 <strong>灰色</strong>。</li><li><strong>并发遍历：</strong> GC 线程从 <strong>灰色</strong> 集合中取出一个对象 $A$，将其所有引用的子对象（它们此刻还是 <strong>白色</strong>）全部标记为 <strong>灰色</strong>。</li><li><strong>转为黑色：</strong> 对象 $A$ 的所有子对象都被处理完毕后，对象 $A$ 本身被标记为 <strong>黑色</strong>，并放回堆中。</li><li><strong>循环结束：</strong> 重复步骤 3 和 4，直到 <strong>灰色</strong> 集合为空。</li></ol><h3 id=并发-gc-引入的难题>并发 GC 引入的难题</h3><p>在 GC 标记阶段，由于用户线程（Mutator）也在同时运行，对象图的引用关系可能会被修改。并发 GC 必须解决两个问题，否则会破坏三色标记的正确性：</p><ol><li><strong>漏标 (Lost Objects)：</strong> 将一个<strong>存活对象</strong>错误地标记为 <strong>白色</strong>，导致它被回收。这是<strong>致命的错误</strong>。</li><li><strong>浮动垃圾 (Floating Garbage)：</strong> 将一个<strong>已死亡对象</strong>错误地标记为 <strong>黑色</strong> 或 <strong>灰色</strong>，导致它在本次 GC 中无法被回收。这是<strong>性能问题</strong>，需要等到下一次 GC 才能被清理。</li></ol><p>考虑漏标问题，导致漏标的充要条件：</p><ol><li><strong>用户线程插入了新的引用：</strong> 一个 <strong>黑色</strong> 对象 $A$ 引用了一个 <strong>白色</strong> 对象 $C$</li><li>并且 ，所有从 <strong>灰色</strong> 对象到 $C$ 的引用都不存在（或被删除）。</li></ol><h3 id=解决并发gc问题-屏障技术>解决并发GC问题-屏障技术</h3><h4 id=增量更新-incremental-update>增量更新 (Incremental Update)</h4><p>侧重解决条件 1， <strong>代表 GC：</strong> <strong>CMS (Concurrent Mark-Sweep)</strong></p><ul><li><strong>机制：</strong> <strong>写屏障 (Write Barrier)</strong>。当 <strong>黑色</strong> 对象 $A$ 尝试引用新的 <strong>白色</strong> 对象 $C$ 时（即满足条件 1），写屏障会拦截该操作，<strong>将 $C$ 标记为 灰色</strong>。</li><li><strong>效果：</strong> 即使 $C$ 的所有旧引用被删除（条件 2 发生），由于 $C$ 已经被标记为 <strong>灰色</strong>，GC 会在后续扫描中重新访问它，防止漏标。</li></ul><h4 id=原始快照-snapshot-at-the-beginning-satb>原始快照 (Snapshot At The Beginning, SATB)</h4><p>侧重解决条件 2，<strong>代表 GC：</strong> <strong>G1 (Garbage-First)</strong></p><ul><li><strong>机制：</strong> <strong>写屏障 (Write Barrier)</strong>。当 <strong>灰色</strong> 对象 $B$ 尝试删除对 <strong>白色</strong> 对象 $C$ 的引用时（即满足条件 2），写屏障会拦截该操作，<strong>记录旧的引用 $C$</strong>。 （意思是，这个node只要在并发GC开始前可达，那么就一直保证其可达）</li><li><strong>效果：</strong> GC 仍然会像并发开始时一样，扫描所有被记录的旧引用。这意味着只要 $C$ 在并发开始时是存活的，它就会被标记为活的（即使它在并发期间死亡），从而<strong>防止漏标</strong>。</li></ul><p><strong>SATB 的代价：</strong> SATB 倾向于保留更多的<strong>浮动垃圾</strong>，因为即使对象 $C$ 很快死亡，它也会被记录下来并在本次 GC 中存活。但由于它只需要记录旧引用，屏障的开销通常比增量更新小。</p><h4 id=final-remark>final remark</h4><p>即使有写屏障 / 读屏障保障，在并发 GC 的最终回收阶段仍需短暂 Stop-The-World（STW），以避免用户线程创建的新引用未被捕获。<br>在 STW 期间，GC 会：</p><ol><li><strong>进行最终 mark</strong>，扫描根集、线程栈和队列中尚未标记的对象</li><li><strong>进行回收（Sweep / Reclaim）</strong>，释放不可达对象</li></ol><p>通过这种方式，即便在并发阶段有新引用出现，也能保证不会漏标或回收活对象。</p><h2 id=其他语言gc选择>其他语言GC选择</h2><p>理解了java语言GC的机制，其他语言上基本类似或者是简化的版本。</p><h3 id=go>Go</h3><ul><li><p><strong>GC 类型</strong>：Go 使用 <strong>并发标记-清除（Concurrent Mark-and-Sweep）</strong> GC。</p></li><li><p><strong>特点</strong>：</p><ul><li>自动内存管理，无需手动释放对象。</li><li>并发 GC 能在用户 Goroutine 执行时进行标记，减少 STW 暂停时间。</li><li>使用 <strong>写屏障（Write Barrier）</strong> 保证并发标记的正确性，类似 Java 的 SATB 机制。</li><li>Go 的 GC 设计注重 <strong>低延迟和较小暂停时间</strong>，但吞吐量略低于完全 STW GC。</li></ul></li><li><p><strong>简化说明</strong>：没有 SafePoint/OopMap 等复杂机制，Goroutine 调度和栈扫描结合实现并发标记。</p></li></ul><h3 id=typescript>TypeScript</h3><ul><li><strong>GC 类型</strong>：主要由运行时（如 V8）实现 <strong>分代 GC + 精确标记-清除</strong>。</li><li><strong>特点</strong>：<ul><li>自动内存管理，开发者无需手动释放。</li><li>分代回收：<strong>新生代对象</strong>采用快速复制（Scavenge）算法，<strong>老年代对象</strong>采用标记-清除或标记-整理。</li><li>使用 <strong>精确 GC</strong>，跟踪对象引用，无需像 C/C++ 那样保守扫描。</li><li>GC 暂停通常较短，但高密度对象分配仍可能造成小幅 STW。</li></ul></li><li><strong>简化说明</strong>：JavaScript GC 更依赖运行时优化，开发者不直接接触线程或屏障机制。</li></ul><p><strong>单线程执行模型</strong></p><ul><li>JavaScript 在浏览器或 Node.js 中是 <strong>单线程运行</strong>（主线程执行用户代码）。</li><li>用户代码（Mutator）和 GC 线程不会同时操作堆，也就是说，<strong>GC 运行时可以假设用户线程处于暂停状态</strong>。</li><li>因此，不需要写屏障或读屏障来捕获用户线程对对象引用的修改，因为<strong>在 GC 开始时，用户代码已经停止</strong>。</li></ul><h3 id=总结-2>总结</h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Java</strong></th><th><strong>Go</strong></th><th><strong>TypeScript / JavaScript (V8)</strong></th></tr></thead><tbody><tr><td><strong>GC 类型</strong></td><td>分代 GC + 并发/并行 GC（如 G1, CMS, ZGC）</td><td>并发标记-清除（Concurrent Mark-and-Sweep）</td><td>分代 GC + 标记-清除 / 标记-整理</td></tr><tr><td><strong>主要机制</strong></td><td>SafePoint, OopMap, Card Table, 写/读屏障, 三色标记</td><td>写屏障, Goroutine 栈扫描, 三色标记</td><td>分代扫描, 精确标记, 新生代快速复制, 老年代标记清除</td></tr><tr><td><strong>暂停策略</strong></td><td>STW + 并发标记（短暂停）</td><td>并发标记 + 小幅 STW</td><td>短暂停（STW）</td></tr><tr><td><strong>并发支持</strong></td><td>支持并发标记和部分并发整理</td><td>支持并发标记，写屏障保证标记正确性</td><td>支持并发，但依赖运行时优化</td></tr><tr><td><strong>分代支持</strong></td><td>新生代 + 老年代</td><td>有概念上的新生代/老生代，但实现更简化</td><td>分代（新生代/老年代）</td></tr><tr><td><strong>写屏障/读屏障</strong></td><td>写屏障（增量更新/SATB）、读屏障用于并发移动</td><td>写屏障（类似 SATB）</td><td>无明确屏障机制，GC 内部处理</td></tr><tr><td><strong>特点</strong></td><td>精确 GC，支持高并发、低延迟</td><td>简化机制，重视低延迟和可预测暂停</td><td>轻量级，运行时自动管理，无需开发者关注 GC</td></tr></tbody></table></div><h1 id=现代c推荐的内存管理>现代C++推荐的内存管理</h1><p><strong>现代 C++ 的主流实践并不推荐引入通用 GC（垃圾回收），而是以 RAII 为核心，配合智能指针、明确的对象所有权语义，以及在需要时使用自定义 allocator / 内存池来解决内存管理问题。</strong><br>但这个结论有<strong>明确的前提和边界条件</strong>，并非“GC 在 C++ 中永远不合理”。</p><h2 id=为什么现代-c-不推崇通用-gc>为什么现代 C++ 不推崇通用 GC</h2><h3 id=c-的设计哲学与-gc-天然不匹配>C++ 的设计哲学与 GC 天然不匹配</h3><p>C++ 的核心理念包括：</p><ul><li><strong>确定性资源管理（deterministic destruction）</strong></li><li><strong>零成本抽象（zero-cost abstraction）</strong></li><li><strong>资源 ≠ 内存</strong>（文件、锁、socket、GPU 资源等）</li></ul><p>而 GC 的典型特征是：</p><ul><li>对象释放时间 <strong>不确定</strong></li><li>需要运行时跟踪对象可达性</li><li>通常只管理“内存”，不管理其他资源</li></ul><p>这与 C++ 的 RAII 模型存在根本冲突。</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#0550ae>::</span>lock_guard<span style=color:#0550ae>&lt;</span>std<span style=color:#0550ae>::</span>mutex<span style=color:#0550ae>&gt;</span> lock<span style=color:#1f2328>(</span>m<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#57606a>// 临界区
</span></span></span><span style=display:flex><span><span style=color:#57606a></span><span style=color:#1f2328>}</span> <span style=color:#57606a>// 作用域结束，立即释放锁
</span></span></span></code></pre></td></tr></table></div></div><p>GC 语言无法表达这种“作用域即生命周期”的语义。</p><h3 id=c-已经有非常强的静态内存管理工具链>C++ 已经有非常强的静态内存管理工具链</h3><p>现代 C++（C++11 之后）在内存管理方面已经发生质变：</p><p>1）明确的所有权语义</p><ul><li><code>std::unique_ptr</code>：独占所有权</li><li><code>std::shared_ptr</code>：共享所有权（带引用计数）</li><li><code>std::weak_ptr</code>：打破循环引用</li></ul><p>这使得<strong>对象生命周期在类型系统层面是可表达的</strong>。</p><p>2）RAII 是语言级模式</p><ul><li>析构函数是确定性调用</li><li>与异常机制完美配合</li><li>无需运行时扫描堆</li></ul><p>3）编译期即可验证大量错误</p><ul><li>double free</li><li>泄漏（大部分场景）</li><li>use-after-free（配合 sanitizers / 静态分析）</li></ul><p>GC 则把问题推迟到运行期。</p><h3 id=性能与可预测性要求>性能与可预测性要求</h3><p>在很多 C++ 的核心应用领域中：</p><ul><li>游戏引擎</li><li>实时系统</li><li>高频交易</li><li>操作系统 / 驱动</li><li>嵌入式系统</li></ul><p><strong>暂停不可接受</strong>，哪怕是毫秒级。</p><p>GC 的问题不只是“慢”，而是：</p><ul><li><strong>暂停时间不可控</strong></li><li>内存访问局部性变差</li><li>与 CPU cache / NUMA / 对象布局冲突</li></ul><p>而 RAII + 自定义 allocator 可以做到：</p><ul><li>完全可预测</li><li>cache-friendly</li><li>与业务模型紧密贴合</li></ul><h2 id=为什么智能指针--raii--自定义-allocator是主流解法>为什么“智能指针 + RAII + 自定义 Allocator”是主流解法</h2><p>本质上是<strong>分层内存管理模型</strong>：</p><h3 id=第一层raii根基>第一层：RAII（根基）</h3><ul><li>生命周期绑定作用域</li><li>统一管理“所有资源”</li></ul><p>这是现代 C++ 的根。</p><h3 id=第二层智能指针表达所有权>第二层：智能指针（表达所有权）</h3><ul><li><strong>不是为了“自动释放”</strong></li><li>而是为了<strong>表达语义</strong></li></ul><p>现代 C++ 的共识是：</p><blockquote><p>“先设计所有权模型，再决定是否需要智能指针。”</p></blockquote><h3 id=第三层allocator--内存池性能与规模>第三层：Allocator / 内存池（性能与规模）</h3><p>当出现以下情况时，引入自定义 allocator 是合理的：</p><ul><li>大量小对象频繁分配/释放</li><li>对象生命周期高度一致（arena / region）</li><li>需要减少碎片</li><li>需要与硬件/平台特性匹配</li></ul><p>典型模式包括：</p><ul><li>Pool allocator</li><li>Arena allocator</li><li>Frame allocator</li><li>TLSF、jemalloc、tcmalloc</li><li><code>pmr::*</code>（C++17）</li></ul><h2 id=那-gc-在-c-中完全没价值吗>那 GC 在 C++ 中完全没价值吗？</h2><h3 id=gc-在-c-中的合理使用场景>GC 在 C++ 中的合理使用场景</h3><ul><li>原型系统 / 快速验证</li><li>复杂图结构、难以定义清晰所有权</li><li>上层脚本化系统（如游戏脚本层）</li><li>学术 / 实验性项目</li></ul><p>例如：</p><ul><li>Boehm GC</li><li>LLVM/Clang 内部某些子系统（有限场景）</li></ul><p>但这些都是<strong>局部、可选、非语言级</strong>的 GC。</p><h2 id=重要补充避免一个常见误区>重要补充：避免一个常见误区</h2><p><strong>现代 C++ ≠ 到处用 <code>shared_ptr</code></strong></p><ul><li><code>shared_ptr</code> 是“最后的手段”</li><li>默认应使用：<ul><li>栈对象</li><li>值语义</li><li><code>unique_ptr</code></li></ul></li><li>allocator 是架构级决策，不是“随手优化”</li></ul><p>GC 和 <code>shared_ptr</code> 的滥用，本质上是同一类问题：<strong>逃避所有权建模</strong>。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/cpp/>Cpp</a>
<a href=/tags/memory-management/>Memory-Management</a>
<a href=/tags/raii/>Raii</a>
<a href=/tags/gc/>Gc</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=[".main-article",".widget--toc"];e.forEach(e=>{const t=document.querySelector(e);t&&renderMathInElement(t,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/2025/12/11/c-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/><div class=article-details><h2 class=article-title>C++模板元编程初探</h2></div></a></article><article><a href=/2025/11/26/c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B0%E7%89%B9%E6%80%A7/><div class=article-details><h2 class=article-title>C++字符串新特性</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2025 crackhopper的技术博客</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.32.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.0fcb739c1f88ce461c9640077fd21d8ce903946f1aef209dd01192827d26a90c.js defer></script><script type=text/javascript src=/ts/custom.fb6397326fc458b8ae775aee18e0a0ae80628aec9c216e7e90c79bb0486cb0e3.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>