<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://localhost:4000').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="一个做算法的技术宅">
<meta property="og:type" content="website">
<meta property="og:title" content="crackhopper的博客">
<meta property="og:url" content="http://localhost:4000/index.html">
<meta property="og:site_name" content="crackhopper的博客">
<meta property="og:description" content="一个做算法的技术宅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="crackhopper">
<meta property="article:tag" content="shadoc">
<meta property="article:tag" content=" hoppe">
<meta property="article:tag" content=" crackhopper">
<meta property="article:tag" content=" developer">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://localhost:4000/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>crackhopper的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">crackhopper的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">分享，积累，进步</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/09/06/%E5%85%B3%E4%BA%8E%E7%94%A8emacs%E8%AE%B0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/%E5%85%B3%E4%BA%8E%E7%94%A8emacs%E8%AE%B0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">关于用emacs记笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-06 21:51:21 / Modified: 22:13:19" itemprop="dateCreated datePublished" datetime="2020-09-06T21:51:21+08:00">2020-09-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/09/06/%E5%85%B3%E4%BA%8E%E7%94%A8emacs%E8%AE%B0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/06/%E5%85%B3%E4%BA%8E%E7%94%A8emacs%E8%AE%B0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大概是2011年左右，对于学习知识方面的需求，我对笔记工具做了深入调研和学习。主要选<br>择的工具是emacs+org-mode，当时比较年轻，做选择的时候只追求功能强大，效率极致。其<br>他的都不在考虑范围内。</p>
<p>可以说emacs深入影响了我。从全局快键、org-mode、latex、emacs-lisp、到插件debug。<br>最终我的工作栈稳定在：linux系统下、基于spacemacs、配合部分lisp脚本增强org-mode的<br>工作方式。目前我主要学习笔记以及工作日程都是org-mode管理，而写代码相关的开发工作<br>则迁移到了VSCode上。</p>
<p>从普通用户角度来看，linux+emacs+org-mode+lisp非常不友好：文档散乱且大部分只有英<br>文、知识量庞大。大部分用户可能需要在有“导师”的引导下，学习半年左右；有天赋的人，<br>自学也需要半年左右，才能够基本上手。</p>
<p>这种突破天际的上手难度，对于当今很多接触到IDE的人来说，是不可接受的。大家都已经<br>脱离学生阶段，开始工作；而快速解决工作需要才是第一位的，很难有人可以沉得住气去学<br>习怎么使用编辑器。</p>
<p>那么类似emacs的这类工具是否可以做得更友好呢？我认为VSCode就是这方面最完美的尝试。<br>当然之前还有sublime, atom之类的。我也大概都使用了一下，非常不错：</p>
<ul>
<li>高频需求都被简单化的管理了</li>
<li>全局快键也有对应的插件可以控制</li>
</ul>
<p>除了org-mode这种非常复杂的模式(同时小众)没有被很好迁移外，我的其他工作主要也切换<br>到了VSCode上。当然，在命令行端，emacs和vim仍然有比较大的优势；而vim的随发行版自<br>动安装，也让其普及性更佳。可以预见的是，随着市场的发展，VSCode+Vim的模式应该是一<br>个更加常见的技能组合。而由于emacs和vim的快键极大程度的不兼容性，emacser和vimer之<br>间很难互相转化。至此，emacs的式微看起来难以避免。emacs社区曾经也就这个问题展开过<br>深入探讨；可能更好的办法还是更加简便的文档，以及培养更多致力于传道的emacser。</p>
<p>不过，对于资深emacser来说，发行版缺失emacs并不是大的问题。如果只是简单的远程配置<br>修改，使用vim操作非常简单，也是每个linuxer的必备技能。而涉及到远程复杂开发，额外<br>安装emacs反而也不是很大的负担了。现如今的工作环境，需要完全全程开发的工作其实比<br>较少，大部分开发都是在桌面系统的VSCode下进行的，再通过git等版本控制工具进行代码<br>同步和CI/CD。同时，emacs和vim的快键方式也均被各大主流编辑器支持。</p>
<p>另一方面，忽略一些配置起来的不方便的因素，emacs工具体系整体是处于效率的顶峰的：</p>
<ul>
<li>全局快键</li>
<li>和大部分软件有一定兼容性的快键</li>
<li>更改control的位置更加有效率的利用caplock键</li>
<li>极其强大的扩展性和扩展语言 emacs-lisp</li>
<li>无比强大的org-mode和其扩展(尤其是内置latex显示)。</li>
</ul>
<p>在这些细节上只有vim才能和emacs接近，但重度配置化的vimer可能比emacser更加罕见，大<br>部分人只是浅尝则止。不过，即使是重度配置化的vimer和重度配置化的emacser，也常常互<br>相看不惯对方的编辑器，在社区开战。</p>
<p>当然，我还是坚定的emacser，毕竟emacser的那玩意会更长一些。所以我选emacs。</p>
<p>如果以后有更多的精力，我会整理一个一键化的emacs安装配置以及工作流。为emacser的布<br>道贡献自己的力量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/09/06/%E5%AF%B9%E5%B9%B8%E7%A6%8F%E7%9A%84%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/%E5%AF%B9%E5%B9%B8%E7%A6%8F%E7%9A%84%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">对幸福的思考</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-06 12:14:26 / Modified: 19:26:03" itemprop="dateCreated datePublished" datetime="2020-09-06T12:14:26+08:00">2020-09-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/09/06/%E5%AF%B9%E5%B9%B8%E7%A6%8F%E7%9A%84%E6%80%9D%E8%80%83/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/06/%E5%AF%B9%E5%B9%B8%E7%A6%8F%E7%9A%84%E6%80%9D%E8%80%83/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从钱出发"><a href="#从钱出发" class="headerlink" title="从钱出发"></a>从钱出发</h1><p>网上有个段子：“When I was young I thought that money was the most important<br>thing in life; now that I am old I know that it is.” </p>
<p>翻译过来就是，“当我年轻的时候，我曾以为钱是我生命中最重要的东西。如今我老了，我<br>知道钱确实是最重要的东西”。</p>
<p>这种明显的毒鸡汤，确实是很多人都感同身受的。不可否认，“钱”是影响我们大多数人生活<br>的最重要的因素。正如一些网友所言， “有钱幸福不幸福我不知道，但是没钱不幸福这个事<br>情我是知道的”。当然，关于没钱带来的不幸感，我也是知道的。</p>
<p>看起来，人们对幸福生活定义的必要条件就是“有钱”。同样，很多人也相信，只要财富自由<br>了，那么自己就离幸福更近了。</p>
<p>那么财富自由是什么呢？简单来说，就是想花多少钱就花多少钱；不用考虑钱的问题。这当<br>然是个理想的状态，实际很多人心中的财富自由更多的指的是：<strong>资产性收入可以覆盖生活<br>成本</strong>。用一个词来概括就是：“可以不劳而获！”</p>
<h1 id="不劳而获"><a href="#不劳而获" class="headerlink" title="不劳而获"></a>不劳而获</h1><p>“不劳而获”乍一听是一个很诱人的想法，那么“不劳而获”能不能得到幸福呢？</p>
<p>作为一个拥有“社会主义核心价值观”的好青年，什么“不劳而获”，我肯定是不为所动的！不<br>过，我可以假设自己“不劳而获”，推导一下我能不能幸福？</p>
<p>那么第一个问题是，如果我不劳而获了，我会做什么？</p>
<ul>
<li>不工作。想怎么睡就怎么睡。</li>
<li>到处旅游。想去哪儿玩就去哪儿玩。</li>
<li>买买买。想要的都买来。</li>
<li>吃吃吃。吃最好吃的，到处吃各种吃。</li>
<li>玩玩玩。组团玩，花钱请人一起玩。</li>
</ul>
<p>好像也没啥了，天天这么过，估计时间长了，1-2年左右也差不多腻了。然后呢？</p>
<p><strong>然后呢？</strong></p>
<p>所有想得到的都得到之后，怎么办呢？</p>
<ul>
<li>自由地做点自己想做的事情。</li>
</ul>
<p><strong>等等！</strong></p>
<p>我万一去做事情。这算不算“劳”呢？这不就是违背了我不劳而获的行为主旨了么？</p>
<p>如果什么都不去做，什么都得到了。那人生已经到达尽头，活着也没有什么意义。所以哪怕<br>没有收获，也需要让自己做点事情，不是么？</p>
<p>显然，不劳而获永远不可能成为一个人一生的终点。它的作用仅仅是给你可以选择做什么的<br>自由。而享乐是有尽头的，最终人们还是会回到做事情这条路上。</p>
<p><strong>为什么做事会作为一个人最终的选择呢？</strong></p>
<ul>
<li>有成就感；而且做不同的事，有不同的成就感。</li>
<li>做的事儿能够帮助更多的人，就有更大的成就感。</li>
<li>事儿越难做，别人越做不到，越有成就感。</li>
</ul>
<p>成就感才是真正持续带来幸福的动力源泉。</p>
<p>最终，在“不劳而获”的假设下，想要达到幸福，最终需要“劳而有所获”。</p>
<h1 id="劳而有所获"><a href="#劳而有所获" class="headerlink" title="劳而有所获"></a>劳而有所获</h1><p>有了对不劳而获的分析，我们可以得出下面的结论：</p>
<ul>
<li>幸福不是 “不劳而获”</li>
<li>幸福可能是 “劳而有所获”</li>
</ul>
<p>自己做的饭，吃起来更好吃，这是因为付出了劳动得到的成果；自己努力健身，最终瘦下来<br>且更加健康，自己也更加自信，这也是付出了努力得到的结果。</p>
<p>生活中大大小小的事情告诉我们，付出了劳动，最终得到超出自己期望的结果，会有更大更<br>持久的幸福感。古人们也说过“没有耕耘没有收获”。既，没有付出的劳动，也就不会有达成<br>收获时这份额外的欣喜感和满足感。</p>
<p>这样看来，只要努力付出，达到自己的结果。人就可以活得幸福。这就是“获取幸福”这个问<br>题最终的答案。可是答案有这么简单么？</p>
<h1 id="劳而无所获"><a href="#劳而无所获" class="headerlink" title="劳而无所获"></a>劳而无所获</h1><p>劳而有所获，自然是完美的情况。但现实往往是残酷的，劳而无所获是常态。</p>
<ul>
<li>很努力地把所有时间都放在学习上，但仍然无法取得好成绩。</li>
<li>很努力地对一个人好，但却无法得到对方的回应。</li>
<li>很努力地把精力都放在工作上，但却没有办法达到自己想要的收入。</li>
</ul>
<p>现实会告诉你，付出不一定会有收获，而要达到自己想要的收获则往往更难。尤其是当你的<br>期望高出你能力的时候。一次一次的失败，也让人们学会了保护自己：不再尝试竭尽所能，<br>有限度的付出行动，不再对目标抱有强烈的期待。</p>
<p><strong>的确，失败不是最可怕的，最可怕的是竭尽所能后，迎来的仍然是失败。</strong></p>
<p>而不去竭尽所能，还可以保留对未来的期待。因为自己还有潜力，自己还没“认真”，只要还<br>没“认真”，还没全力以赴，自己就不算输。</p>
<p>可是，现在不去全力以赴的人，没道理将来会全力以赴，不是么？</p>
<p>还有的人，则完全丢弃了勇气。不对未来抱有美好的期待，只按照现在的状态，保持不变坏<br>就可以了。不去渴求，不求期待，自然也不必付出努力。虽然无法得到“劳有所获”所带来的<br>强烈的成就感和满足感，但也避免了“劳无所获”所带来的强烈的痛苦感。</p>
<p>可这样的活着，算真正的活着么？生命只有一次，难道你不想尽可能地体验其中的酸甜苦乐，<br>体会命运的波澜壮阔么？难道你不想在这有限的一生里尽可能地挣扎，用行动见证自己的生<br>命的力量么？</p>
<p>“人最宝贵的是生命，生命每个人只有一次。人的一生应该这样度过：当他回首往事的时候，<br>不因虚度年华而悔恨，也不因碌碌无为而羞愧；这样，在临死的时候他就能够说： ‘我的整<br>个生命和全部精力。都献给了世界上最壮丽的事业——为人类的解放而斗争。’”</p>
<p>这只有一次的生命，你可以选择像勇士一样活着，也可以选择懦弱地抱着幻想活着。</p>
<p>但如果你想不后悔的活一辈子，那还是做一名勇士吧。</p>
<h1 id="以勇士之姿活下去"><a href="#以勇士之姿活下去" class="headerlink" title="以勇士之姿活下去"></a>以勇士之姿活下去</h1><p>屠龙的勇士，最终可能成为恶龙。只有永远在屠龙路上的勇士，才会是真正的勇士。因此想<br>要成为真正的勇士，就不要屠龙，而是要一直行走在屠龙的道路上。</p>
<p><strong>身为勇士，你需要有使命，需要有一个自己可以无限地追求的愿望</strong>。这样的你才会是一<br>个真正的勇士，而不会化身成为恶龙。比如说，“让社会的高科技能够更好的改善人们的生<br>活”。这种可以无限追求的目标意味着任何一次失败都不会是本质的失败；同样任何一次成<br>功，也都不是停止奋斗的理由。</p>
<p>决定了你的使命后，接下来的是朝着愿望规划出一个个可以实现的目标。去一步一步的达成<br>这些切实的目标，同时做好竭尽全力仍然一败涂地的准备。</p>
<p>当你竭尽所能仍然彻头彻尾的失败时：</p>
<ul>
<li>问自己：你的使命是什么？</li>
<li>问自己：你是否在追求自己使命的道路上前行？</li>
<li>问自己：当前的失败教会了你什么？这种收获是不是让你离屠龙的愿望更近？</li>
<li>告诉自己：失败只会让自己更加顽强。并不会改变什么。</li>
<li>告诉自己：屠龙的路是漫长的，不要急躁。整理好心情，继续上路。</li>
</ul>
<p>当你可以像勇士一样的活下去，可以跨过一个个艰难困阻。那么生活的本身，你经历过的所<br>有事情，就是你追求的幸福。而你即将做的事情，也注定给你带来幸福。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/06/14/think-in-start-up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/think-in-start-up/" class="post-title-link" itemprop="url">关于创业的思考</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-14 21:53:46" itemprop="dateCreated datePublished" datetime="2020-06-14T21:53:46+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-06 09:21:16" itemprop="dateModified" datetime="2020-09-06T09:21:16+08:00">2020-09-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/06/14/think-in-start-up/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/think-in-start-up/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创业者需要什么？"><a href="#创业者需要什么？" class="headerlink" title="创业者需要什么？"></a>创业者需要什么？</h1><p>互联网时代是一个传奇的时代。在这里，没什么背景的普通人，都可以拥有传奇般的人生经<br>历，赚取普通人一辈子都赚不到的金钱。而互联网发展也让更广大的人们连接到了一起，让<br>人们看到了很多普通人是如何实现自己的“财富自由”的：做app，做网站，开网店，做主播，<br>做代购等等等等，也让人们看到了惊人的财富被赚取到这些普通人的手中。在巨大的财富收<br>益刺激下，很多人都萌生了创业的念头，想要辞掉工作进入商海，说不定下一个成功的人就<br>是自己。也有很多人开始相信，普通人通过努力也可以成为大富豪。</p>
<p>事实真的是这样么？普通人可以努力开创自己的事业，实现财富自由么？答案取决于怎么去<br>定义“普通”。如果“普通”指的是“不具备巨大的财富”、“不具备惊人的人脉关系”、或者说<br>“不具备较高的知识素养”，那么这样的一个“普通”人也是有机会创业成功的。但这不意味着<br>这些人真的“普通”，他们往往具备其他人所不具备的东西。</p>
<p>在这里，我想谈谈我对“创业者需要的品质”这句话的思考。我个人认为一个创业者需要具备<br>五个条件：“运气”、“头脑”、“决心”、“毅力”、“行动力”。</p>
<h1 id="创业者的五个条件"><a href="#创业者的五个条件" class="headerlink" title="创业者的五个条件"></a>创业者的五个条件</h1><h2 id="运气"><a href="#运气" class="headerlink" title="运气"></a>运气</h2><p>“运气”这个东西，看不见摸不着。你怎么能保证自己有个好“运气”呢？就算你各种的条件都<br>具备，就是没有运气怎么办？比如买彩票，就是有人中奖有人不中奖。相信很多人都有这些<br>类似的想法。</p>
<p>但我们可以更深入的思考：<strong>定义“运气”为“好事情”发生的概率</strong> 。在人生这条时间轴上，<br>假设“好事情”会让人事业进步，“坏事情”会让人事业退步。对所有发生的事情，好坏的影响<br>加和，就是这个人一生的运气。</p>
<p>那么，运气是 <strong>注定的</strong> 还是可以 <strong>改变的</strong> 呢？首先，讨论注定的还是改变的，这种<br>问题已经是哲学问题了。建议大家可以看看“决定论”和“自由意志”这两个概念的哲学辩论。<br>我个人还是倾向于“自由意志”的。也就是说，运气会随着自由意志带来的行动发生改变。</p>
<p>没人知道自己的运气好还是运气不好。但可以影响运气的因素有很多，比如一个人的家庭、<br>教育、圈子等等。这些变量刻画了运气的分布，因此每个人由于条件不同，每类人都处在不<br>同的 <strong>条件运气分布</strong> 下。从概率的角度来看，就是我们可以通过努力，比如提升学识，<br>让运气从一个条件概率分布(学识低的分布)变为另一个条件概率分布(学识高的分布**。</p>
<p>运气是个很玄学的东西。在有的人眼里，它是希望；但在有的人眼里，它是绝望。我认为一<br>个合格的创业者应该理解运气、相信运气、努力去争取运气。</p>
<h2 id="头脑"><a href="#头脑" class="headerlink" title="头脑"></a>头脑</h2><p>头脑是个极其复杂的东西。极其聪明、过分自信、过分使用头脑的人，都可能对创业所做的<br>事情过于“不专注”，因为他们总能想到“新”的机会可以试试。反之，愚笨的人、自卑的人、<br>不用头脑，则会过于“专注”，因为他们总是能在一条路上撞的头破血流也不去思考变通。总<br>之这两类人其实本质上都不适合创业。</p>
<p>如果让我来描述创业需要的头脑，我觉得应该是“聪明自信”但也有点“傻气的坚持”。知道什<br>么时候不可为，但也会拼尽力气坚持和探索。比起聪明这个词，具备智慧的思维是更准确的<br>描述。</p>
<p>不过，“智慧”的头脑往往需要沉淀。因此，很多年轻人其实并不适合创业；同样，循规蹈矩<br>生活了很多年的人，也不适合创业。</p>
<h2 id="决心"><a href="#决心" class="headerlink" title="决心"></a>决心</h2><p>决心是一个创业人内在的力量。可以简单的理解一个人为了达成自己的愿望愿意付出的努力。</p>
<p>我前段时间见过一个创业的朋友聊了很久。这个朋友其实是个很聪明的人，在职场积累了几<br>年，又在创业中摸爬滚打了两年。虽然他暂时创业失败，但我其实对他还是有点信心的。和<br>他的交流，更多的也是想了解创业需要什么，创业失败的原因又是什么。而其实交流的过程<br>并不愉快，我们有很多观点不一致；同时有很多观点我并没有思考的那么深入，一时也反驳<br>不了什么。</p>
<p>事后的回顾，我发现我们之前最大的分歧在于：“决心和目标到底重要不重要”。我觉得他决<br>心不够，体现在目标不明确。当我问他到底想做什么的时候，他的看法是找到市场的机会去<br>做一个市值超10亿的公司。说实话，在我心里这根本算不上一个目标。而在这样的目标下，<br>他又会有怎么样的决心呢？他失败后最核心的感悟就是：应该融更多的资，钱只要足够多没<br>有做不成的事情。不可否认的是，资金确实是创业中强大的力量和因素。但过分依赖资金，<br>其实也暴露了他的“决心不够”和“目标不明确”。</p>
<p>有一个问题他问我问得很好：“假设市场上的竞争对手，具备和你一样甚至比你更有优势的<br>资金、技术、渠道和人脉，同时他和你一样聪明。那么你靠什么战胜他？”他的答案是“找到<br>更多的资金”，而我的答案是“靠你的决心”。不好说谁对谁错，但我觉得有决心的人，也一<br>定会努力找资金，而找不到资金也不会轻易放弃，因为商战是一个综合的事情；而只想找资<br>金的人，如果找不到，那他就只有放弃了。我反问了一下“如果找不到怎么办？”他的回答果<br>不其然就是放弃。</p>
<p>对于他放弃的选择，我是十分反对的。要知道，决心并不是由外部因素赋予的。而它往往又<br>有着至关重要的力量。想想看，是什么让共产党最终统一了中国？是什么让很多幼小的公司<br>成长为巨头？历史上有太多太多以弱胜强的例子了，难道全都归纳为强者的失误，弱者只是<br>运气好？</p>
<p>人心的力量是最不能估量的，也是你生死存亡的时候能活下去的原因。拥有非同寻常的决心<br>的人是一只狼，而没有内在力量的人只是一只羊。要知道，吃饱的羊也是战胜不了饥饿的狼<br>的。而在这个世界上，是不会有一个地方可以让羊永远无忧无虑的生活下去的。</p>
<p>记住，<strong>决心是一个创业人内在的力量。一个有决心的人，愿意为了愿望付出非比寻常的努<br>力。</strong></p>
<h2 id="毅力"><a href="#毅力" class="headerlink" title="毅力"></a>毅力</h2><p>毅力是一个不需要怎么解释，大家也能理解的东西。因此可以说它是最简单的条件。而很多<br>人都不具备毅力，因此他也可以说是最难的条件。其实毅力是一个相对的东西，当你的短板<br>是毅力的时候，那么你需要去努力形成它。形成的办法就是：从内因上，养成习惯，体会其<br>中的乐趣；从外因上，被迫强制去做某个事情。</p>
<p>毅力在创业中，最大的要求是，不能作为你的短板出现；其次的要求是，你要超过竞争对手<br>的毅力水平。</p>
<p>毅力是可以磨练的。不过听起来是个很诡异的事情就是：磨练毅力也需要毅力。可以的做一<br>些对自己长期有好处的事情。如果失败了，想方设法化解掉负面情绪，靠鸡汤再次站起来。<br>久而久之，毅力就被提升起来了。</p>
<p>但一定要注意，这个东西不是万能的。比如你的目标是百米3秒，这不是你能靠毅力能达到<br>的。就算目标是人类能达到的，但毅力只是其中的原因之一，其他方面仍然很重要。</p>
<h2 id="行动力"><a href="#行动力" class="headerlink" title="行动力"></a>行动力</h2><p>行动力在我看来是所有五条里最容易的了。但他和其他点配合起来，才有真正的威力。甚至<br>任何一项和行动力结合，不能说会成功，但也会有莫大的收获。</p>
<p>行动力的关键就是： <strong>做</strong> 。</p>
<p>即使你有十万个“不去做”的理由，但你仍然想到一个理由，然后去“做”了。这就是行动力。</p>
<p>当你知道了做一件事要面临的重重困难，同时要想周全应对的手段，即使这样，最终仍然要<br>靠运气来决定成败。在这样的前提下，“行动起来”其实是一个很困难的决定，是需要一个人<br>有强大的内心力量的。</p>
<p>而啥都没思考就去做，其实不是什么难事。只不过面临失败和挫折的打击，会让人怀疑人生，<br>甚至丧失思考能力。而受到打击后，“要不要做下去”，又是非常艰难的选择。</p>
<p>如果无论在合适都能“做”下去，那么无疑你是一个适合创业的人。</p>
<h1 id="木桶理论"><a href="#木桶理论" class="headerlink" title="木桶理论"></a>木桶理论</h1><p>最后，我想要补充一点木桶理论。作为一个创业者，你需要运气、头脑、决心、毅力和行动<br>力。而创业失败，你只需要其中一项具有致命弱点就可以了。</p>
<ol>
<li>运气。一个人运气就是不好，那又有什么办法呢？但毕竟运气不好是小概率事件，而且<br>你还可以努力改变自己的运气的。</li>
<li>头脑。自负，固执，不专注。都会让你品尝失败的苦果。如何合理的权衡，则需要你在<br>实践中进行学习。很多创业的人常说：当你没办法的时候，你应该停止行动，换个方向<br>思考。</li>
<li>决心。没有决心，那么你最终会被狼吃掉。</li>
<li>毅力。没有毅力，那么你是玩票而已。</li>
<li>行动力。没有行动力，那么上面的都属于空想。</li>
</ol>
<h1 id="一些关于创业者的例子"><a href="#一些关于创业者的例子" class="headerlink" title="一些关于创业者的例子"></a>一些关于创业者的例子</h1><p>下面直接针对一些常见的片面的观点举例子。</p>
<h2 id="创业者要有钱"><a href="#创业者要有钱" class="headerlink" title="创业者要有钱"></a>创业者要有钱</h2><ul>
<li>马云创建阿里巴巴的时候，并不是一个有钱人。</li>
<li>王思聪创建直播公司的时候，很有钱，但没成功。(头脑问题，不是说王思聪笨，而是说<br>他知识和经验不够，外加过度自信)</li>
<li>大量小本买卖，基本看天吃饭；多的时候能赚到很多，少的时候则少得可怜。(运气，头<br>脑，决心、毅力、行动力都有但都不强；主要靠运气带动收益)</li>
</ul>
<h2 id="创业者要有逆天的运气"><a href="#创业者要有逆天的运气" class="headerlink" title="创业者要有逆天的运气"></a>创业者要有逆天的运气</h2><ul>
<li>华为创建的时候，路由器市场已经形成巨头垄断；而且任正非属于工作失误被辞退。运气<br>跟逆天没有半点关系。但有人说他后来遇到贵人什么的，但如果不坚持会有后来么？</li>
<li>常常会有人中彩票，运气逆天了。但照样泯灭于社会。(头脑、决心、毅力、行动力都不<br>行)</li>
<li>在线出行时代，OFO是有好的运气，风口、热点、头部公司，然而濒临破产。(头脑问题：<br>缺乏经验，同时过度自信。资本本身也是有弊端的，不是么)</li>
<li>大量融到大笔良性资本，但没实现盈利的企业。(决心问题、行动力问题、部分头脑问题)</li>
</ul>
<h2 id="当今的时代，创业者需要xxxx"><a href="#当今的时代，创业者需要xxxx" class="headerlink" title="当今的时代，创业者需要xxxx"></a>当今的时代，创业者需要xxxx</h2><p>既然结论是“当今的时代”，那么就不是一个普遍的结论，也不是一个本质的结论。</p>
<p>举几个例子：</p>
<ul>
<li>很多人觉得，当今的时代，创业者选择服装这么传统的行业没什么可做的了。 <strong>那快消<br>品牌怎么做起来的？</strong></li>
<li>很多人觉得，当今的时代，创业者选择巨头所在的行业是自找灭亡。<strong>那华为怎么做起来<br>的？</strong></li>
<li>很多人觉得，当今的时代，创业者必须融资。<strong>没融资做起来的企业比比皆是。</strong></li>
</ul>
<p>时代在变，但除了最基本最核心的对创业人的要求以外，没什么是真正需要的。不要局限住<br>自己。当你认为某个东西是“某个时代”才可行的，“这个时代”是不可行的，那么往往就是你<br>没看透本质。</p>
<h2 id="创业者需要有好的背景-最好是大厂出身"><a href="#创业者需要有好的背景-最好是大厂出身" class="headerlink" title="创业者需要有好的背景(最好是大厂出身)"></a>创业者需要有好的背景(最好是大厂出身)</h2><ul>
<li>大厂创业失败的例子太多了。比如，物联网泡沫期，几乎全行业阵亡。</li>
<li>没有什么背景成功的例子也太多了。比如，老干妈。</li>
</ul>
<h2 id="创业者需要有广泛的人脉"><a href="#创业者需要有广泛的人脉" class="headerlink" title="创业者需要有广泛的人脉"></a>创业者需要有广泛的人脉</h2><ul>
<li>王思聪创建直播公司的时候，很有人脉，但没成功。</li>
<li>马云并不是很有人脉的人，只是做着做着渐渐有了人脉。</li>
<li>很多创始人是草根出身，人脉都是熬的足够久，运气中的好事情发生，逐渐积累起来的。</li>
</ul>
<h2 id="创业者需要有渊博的知识"><a href="#创业者需要有渊博的知识" class="headerlink" title="创业者需要有渊博的知识"></a>创业者需要有渊博的知识</h2><ul>
<li>很多教授创立的公司很成问题。</li>
<li>哪怕是知名MBA教授创立的公司，目前也算不上世界上最伟大的公司的行列。</li>
</ul>
<p>但不可否认，有知识的人创立的公司，下限比较高。</p>
<h2 id="创业者要是一个偏执狂"><a href="#创业者要是一个偏执狂" class="headerlink" title="创业者要是一个偏执狂"></a>创业者要是一个偏执狂</h2><p>较正常人来说的偏执是需要的。否则你连产品都做不好，各处得过且过。所有的加到一起就<br>岌岌可危了。</p>
<p>但“偏执狂”就过了。真正很多成功的公司，也完成过大转型。</p>
<ul>
<li>Intel公司本来是存储硬件的领军者，后来不得不转为买CPU。</li>
<li>3M公司本来是打算经营一个矿场，提供金刚沙，后来却转为提供各种制作的产品。</li>
</ul>
<p>按照偏执狂的设定，那么这些公司就应该坚持做存储，坚持采矿。那么也就不会有现在伟大<br>的公司。偏执是需要的，灵活变通也是需要的。真正不变的，应该是决心里的远景。</p>
<h2 id="创业者要是个追求完美主义的人"><a href="#创业者要是个追求完美主义的人" class="headerlink" title="创业者要是个追求完美主义的人"></a>创业者要是个追求完美主义的人</h2><p>较正常人来说的完美主义是需要的。但过分的追求“完美主义”，会让你根本就做不出产品来。<br>更别提盈利了。不盈利的公司，谈不上创业成功。</p>
<h2 id="创业者需要是个天才"><a href="#创业者需要是个天才" class="headerlink" title="创业者需要是个天才"></a>创业者需要是个天才</h2><p>搞科研才需要真正的天才，很多人的思辨能力和灵感，是难以解释的。天才，往往能通过很<br>小的努力就得到巨大的收益。</p>
<p>创业者需要的是努力，做好充足的准备，能够把握住运气的降临。</p>
<h2 id="创业者需要有领袖气质"><a href="#创业者需要有领袖气质" class="headerlink" title="创业者需要有领袖气质"></a>创业者需要有领袖气质</h2><p>“领袖气质”是个很主观的东西。因此你觉得自己没有，可能其他人觉得你有。而你觉得自己<br>有，其他人也会觉得你没有。</p>
<p>模糊的东西，仅仅值得研究，可能里面有潜在的规律。但并不会是创业者所必须的，也并不<br>会是成功的主要因素。（如果领袖气质是主要因素，那么这个词就不会如此模糊，也不会在<br>对领袖气质的判断上，很多人都无法达成共识。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/06/14/let-us-write-compiler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/let-us-write-compiler/" class="post-title-link" itemprop="url">小白学写编译器：1.编译基础概念</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-14 21:49:51 / Modified: 22:07:43" itemprop="dateCreated datePublished" datetime="2020-06-14T21:49:51+08:00">2020-06-14</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/06/14/let-us-write-compiler/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/let-us-write-compiler/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><p>我们知道CPU是计算机的大脑，也知道计算机只认识由0和1组成的二进制码，比如<br>“1001010110101010” 这样的。具体来说，当计算机的CPU遇到一个这样的二进制码时，会做<br>出相应的动作：读取内存、写入内存、执行加法、执行乘法、向其他设备发送IO指令(读取<br>键盘、写入显示器)等等。每个CPU都有自己所识别的二进制码，我们称之为 <strong>机器指令</strong><br>(machine code) 。将一系列机器指令组合成一个集合，那么计算机就可以完成很多复杂的<br>计算和行为，这种机器指令的集合，我们称呼为 <strong>程序</strong> (program)。当计算机运行一个<br>程序的时候，我们会说计算机正在执行一个 <strong>任务</strong>(task) 或 <strong>进程</strong> (process) 。</p>
<p>最早的程序员是使用机器语言编写程序的。比如早期的大家用纸带编写程序，通过对纸带上<br>是否打孔来区分是0还是1，从而识别出机器指令，让CPU执行计算。而如今随着技术的发展，<br>开发程序的工作即被便利化也被复杂化了。大家不再使用二进制开发程序，而是使用编程语<br>言(programming language)。</p>
<p>机器指令插图</p>
<h1 id="编程语言和编译器"><a href="#编程语言和编译器" class="headerlink" title="编程语言和编译器"></a>编程语言和编译器</h1><p>二进制代码太难以记忆，并且编写的程序很难阅读。因此人们首先开发了叫做 <strong>汇编</strong><br>(assembly) 的 <strong>编程语言</strong> (programming language)，用英文字母来代替机器指令。汇<br>编语言是比机器指令更容易理解的指令集，也更容易开发程序。但英文字母并不能被CPU理<br>解，因此需要由 <strong>汇编器</strong> (assembler) 把汇编代码翻译成机器指令。</p>
<p>后来人们发现这种方式非常有效果。因此发明了更多好用的编程语言，也更加接近自然语言<br>的表达方式，比如Fortran，Lisp，C语言等等。由编程语言编写的代码称为 <strong>源代码</strong><br>(source code) ，机器指令的集合称为 <strong>目标代码</strong> (object code) 。而把源代码翻译成<br>目标代码的工具，称为 <strong>编译器</strong> (compiler)</p>
<p>编译器的图示</p>
<p>编译器本身是一个非常复杂的程序。而开发编译器也是一个非常复杂的工程。编译器的作用<br>是生产程序，而编译器本身也是程序。因此编译器也是由编程语言开发的。那么困惑的点来<br>了，如果编译器是由编程语言开发的，那么编译器的源代码由谁来翻译？实际上，第一版编<br>译器是由机器指令开发的，实现了简单的汇编语言；随后用汇编语言再次开发了最初版本的<br>C语言；随后由C语言本身开发C语言的编译器。当一个语言可以用自己开发自己的编译器，<br>这种语言我们说它实现了 <strong>自举</strong>(bootstrap)。和编译器工程特别相似的就是机械领域的<br>大部分机床，第一代机床都是手工制作的；随后各代机床利用前代机床生产的零件，提升自<br>己的性能。大部分发达国家的技术垄断都是这种需要多轮迭代的技术。</p>
<p>和编译器相似的一个概念叫做 <strong>解释器(interpreter)</strong> 。解释器并不会产生目标程序，<br>而是直接将源代码一句一句的转化为机器指令进行执行。</p>
<p>解释器的图示</p>
<p>举两个例子：</p>
<ul>
<li>C语言由它的编译器——gcc进行编译，生成机器二进制码组成的程序，由CPU直接执行。类<br>似C语言这种编译生成由CPU直接执行的机器指令的语言，我们叫做 <strong>编译型语言</strong> 。</li>
<li>javascript语言由它的解释器——浏览器进行解释执行。javascript语言并不会生成程序，<br>真正被CPU执行的程序仍然是浏览器。而浏览器将javascript代码动态的转化为机器指令。<br>这种由其他程序(解释器)作为宿主，解释执行的语言，我们叫做 <strong>解释型语言</strong> 。</li>
</ul>
<p>实际上，很多现代的编程语言可以说是编译型和解释型相混合的。典型的例子就是java。<br>java会把源代码翻译成一种叫中间代码的文件(.class文件)，中间代码并不能被CPU理解，<br>但是可以被一个叫做JVM的程序理解并执行。可以看到下图中，java的编译器既包含编译器<br>也包含解释器。这里面的解释器有另一个名字，叫做 <strong>虚拟机</strong>(Virtual Machine)，因为<br>它像一个虚拟的机器一样。</p>
<p>java编译器的图示。</p>
<p>也许有人会说java最终是被解释执行的。但其实在java中也引入了一个叫JIT(Just In Time<br>Compiler)的技术，这个技术会将高频使用的中间代码在运行时动态地编译成机器代码。在<br>这样的情况下，就更难说java是编译型还是解释型了。</p>
<h1 id="编译器的构造"><a href="#编译器的构造" class="headerlink" title="编译器的构造"></a>编译器的构造</h1><p>接下来，我们较为浅显的看一下编译器的构造。</p>
<h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><p>从简单粗暴的方式来看，编译器主要是两个部分：</p>
<ul>
<li>分析部分：分析源代码，形成一个中间结构（中间代码）</li>
<li>综合部分：从中间结构，翻译成目标代码（机器代码）</li>
</ul>
<p>其中，分析部分也叫做编译器前端(front end)，综合部分也叫做编译器后端(back end)。</p>
<p>宏观视角图</p>
<h2 id="微观视角"><a href="#微观视角" class="headerlink" title="微观视角"></a>微观视角</h2><p>如果更加细节的看编译器的构造，可以分为以下部分：</p>
<ol>
<li>词法分析：将源代码转化为token序列 (类似于把一篇文章，按照单词拆分开)</li>
<li>语法分析：将token序列组织成语法树 (类似于把单词，按照语法组合成句子)</li>
<li>语义分析：验证语法树上的元素，做一些转换 (类似于把句子的语法格式标准化)</li>
<li>中间代码生成器：将语法树转化为 某种更基础格式的代码序列 (类似于把一个标准化的中文句子<br>翻译成标准化的英文句子)</li>
<li>机器无关代码优化：对中间代码优化（类似于将英文句子写的更加优美）</li>
<li>代码生成器：把中间代码转化为目标代码 (类似于将英文句子转化为某种方言下的英文，<br>比如美式英文)</li>
<li>机器相关代码优化：对目标代码优化（类似与对美式英文的文章进行润色）</li>
</ol>
<p>微观视角图</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们举一个龙书上的例子，考虑下面的语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">position</span> = initial+rate*<span class="number">60</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/let-us-write-compiler/compile.png" alt="赋值语句的编译"></p>
<ol>
<li>词法分析：将代码中的代词分离成一个个token。其中id代表标识符(identifier)。每个<br>标识符被存入到对应的符号表中。词法分析输出了token序列。</li>
<li>语法分析：把token按照结构组织起来。先做乘法再做加法，最终进行赋值。语法分析的<br>主要结果就是形成了语法树(syntax tree)。</li>
<li>语义分析：假设rate是浮点类型，60是整数类型，由于他们在内存中表达形式不一样，<br>无法直接做乘法运算。于是语义分析中，将60转化为了浮点类型。语义分析主要就是校<br>验语法树。</li>
<li>中间代码生成：我们将语句转化为更接近机器能理解的语句。常用的一种格式叫做三地<br>址代码 (three-address code) 。即一个语句中最多有三个变量。</li>
<li>代码优化器：对代码进行化简，让代码数量变得更少。</li>
<li>代码生成器：形成机器代码。</li>
</ol>
<h2 id="将多个步骤组合成趟-pass"><a href="#将多个步骤组合成趟-pass" class="headerlink" title="将多个步骤组合成趟(pass)"></a>将多个步骤组合成趟(pass)</h2><p>之前我们对编译器的拆解是逻辑拆解。在实际实现的时候，多个逻辑步骤会组合到一起，形<br>成一个 <strong>趟</strong> (pass/phrase) 。每趟读入一个输入文件并产生一个输出文件。比如前端步<br>骤中的词法、语法、语义以及中间代码生成可以组合成一趟；代码优化可以单独组合成一趟。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们浅显地讲解了程序的概念，程序是由机器指令构成的集合。讲解了程序是如何制作的，<br>程序是编译器将源代码编译成目标代码，从而制作出来的。</p>
<p>进一步的，我们探索了编译器的构造。了解了编译器的前端的组成部分：词法分析、语法分<br>析、语义分析和中间代码生成；编译器后端的组成部分：机器无关代码优化，机器相关代码<br>优化，生成目标代码。此外，将一系列步骤组合到一起，从一个输入文件产生一个输出文件<br>的过程叫做趟。</p>
<p>后续，我们将从编译器的构造一步一步展开讨论。下一节我们讨论的是词法分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/02/15/cmake-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/15/cmake-tutorial/" class="post-title-link" itemprop="url">cmake入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-15 20:48:22" itemprop="dateCreated datePublished" datetime="2020-02-15T20:48:22+08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-23 13:04:31" itemprop="dateModified" datetime="2020-02-23T13:04:31+08:00">2020-02-23</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/15/cmake-tutorial/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/15/cmake-tutorial/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CMake是一个主要用来管理C++项目的工具。主要特点是：更好的解决C++项目跨平台编译带<br>来的配置问题。</p>
<p>CMake提供很多实用的功能，本文简单介绍我项目里常用的一些特性。</p>
<p>如何安装CMake这里就不介绍了，可以自行搜索。安装好后要确保在命令行可以执行cmake命<br>令。</p>
<h1 id="编译一个可执行文件"><a href="#编译一个可执行文件" class="headerlink" title="编译一个可执行文件"></a>编译一个可执行文件</h1><h2 id="Hello-World项目"><a href="#Hello-World项目" class="headerlink" title="Hello World项目"></a>Hello World项目</h2><p>CMake通过找寻目录下的 <code>CMakeLists.txt</code> 文件，读取文件里的内容对项目进行构建。使<br>用方式是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake &lt;project_dir&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;project_dir&gt;</code> 是 <code>CMakeLists.txt</code> 所在的文件夹。cmake的工作流程如下：</p>
<ol>
<li>cmake读取 <code>&lt;project_dir&gt;</code> 文件夹下面的 <code>CMakeLists.txt</code> 文件。</li>
<li>执行平台解析，基础库解析，依赖库查找。如果有错误则暴露错误，如果成功则生成一<br>系列用来构建的文件。其中最重要的一个文件叫 <code>Makefile</code> 。</li>
<li>用户通过执行 make ，读取  <code>Makefile</code> 对项目进行构建。</li>
</ol>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>看一个简单的例子，目录层级如下：<br><img src="/images/cmake-tutorial/hello-world.png" alt="最简单的cmake"></p>
<p>其中，两个文件的内容：</p>
<p><strong>helloworld.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CMakeLists</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">9</span>)</span><br><span class="line"><span class="keyword">project</span> (hello)</span><br><span class="line"><span class="keyword">add_executable</span>(hello helloworld.cpp)</span><br></pre></td></tr></table></figure>

<p>这里解释一下 <code>CMakeLists.txt</code> 的内容。</p>
<ul>
<li>第1行指定最低的cmake版本</li>
<li>第2行指定项目名称</li>
<li>第3方添加一个任务，生成可执行文件 <code>hello</code> 。生成这个文件需要用到<br><code>helloworld.cpp</code> 。</li>
<li>cmake不区分命令的大小写 。</li>
</ul>
<h3 id="构建helloworld"><a href="#构建helloworld" class="headerlink" title="构建helloworld"></a>构建helloworld</h3><p><img src="/images/cmake-tutorial/make-hello-world-s.png" alt="最简单的cmake"></p>
<p>解释一下： </p>
<ul>
<li><code>cmake .</code> 运行cmake命令，查找目录为 <code>.</code> (即当前目录) 。这个命令会生成一系列文<br>件。包括一个重要的 <code>Makefile</code> 文件</li>
<li><code>make</code> 会在当前文件夹查找 <code>Makefile</code> 文件 ，然后对项目进行编译，最终产生了二进<br>制 <code>hello</code></li>
<li><code>./hello</code> 运行这个编译好的二进制文件</li>
</ul>
<h2 id="项目外构建"><a href="#项目外构建" class="headerlink" title="项目外构建"></a>项目外构建</h2><p>cmake提供了一个非常好用的特性，就是 <strong>项目外构建</strong> 。简单来说，cmake支持在自定义<br>的位置对项目进行构建。这样就避免了构建时生成的临时文件把原本的项目弄的非常混乱。</p>
<p>比如说刚才的例子，我们在项目里创建一个build文件夹，在里面构建。</p>
<p><img src="/images/cmake-tutorial/out-build.png" alt="外部构建"></p>
<p>构建好了之后:<br><img src="/images/cmake-tutorial/out-build-res.png" alt="外部构建结果"></p>
<p>我们可以看到生成的文件都在build文件夹中。进入到里面，进行make即可编译。</p>
<p><img src="/images/cmake-tutorial/out-build-make.png" alt="外部构建make过程"></p>
<h1 id="编译一个静态库文件"><a href="#编译一个静态库文件" class="headerlink" title="编译一个静态库文件"></a>编译一个静态库文件</h1><h2 id="静态库机制"><a href="#静态库机制" class="headerlink" title="静态库机制"></a>静态库机制</h2><p>说静态库首先要说什么是编译。</p>
<p>编译就是把 <strong>源代码</strong> 转化为 <strong>目标代码</strong> 的过程。而什么是 <strong>目标代码</strong> 呢？就是<br>机器可以执行的二进制代码，一般来说都是要符合某种规范的，比如linux下的elf格式，<br>windows下的pe格式。这里就不细展开了。</p>
<p>有的代码具备很强的通用性，比如计算绝对值的函数。我们希望在多个项目里都使用这个函<br>数。那么一个方式就是把你的源代码编译成库文件 （也是一种二进制格式），当你写程序<br>需要的时候，链接器可以 <strong>链接</strong> 到这个库文件中，找到对应函数的二进制，“注入”到你<br>写的程序中。</p>
<p>因此我们通常常见的项目构建都分两步：编译、链接。</p>
<ul>
<li>编译：负责源代码转换为目标代码</li>
<li>链接：负责找到程序的入口（main函数），并把二进制组装起来，生成可执行格式（elf<br>或pe）</li>
</ul>
<p>那么如何把代码构建成一个静态库呢？</p>
<h2 id="静态库项目"><a href="#静态库项目" class="headerlink" title="静态库项目"></a>静态库项目</h2><p>我们先看一下 <code>CMakeLists.txt</code> 的写法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(abs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(abs STATIC abs.cpp)</span><br></pre></td></tr></table></figure>

<p>对应的cpp文件如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v&gt;<span class="number">0</span> ? v : -v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们尝试构建一下：<br><img src="/images/cmake-tutorial/static-lib-s.png" alt="静态库构建"></p>
<p>构建后的结果：<br><img src="/images/cmake-tutorial/static-lib-res.png" alt="静态库构建结果"></p>
<p>注意到，libabs.a文件，即为我们构造出的静态库文件。</p>
<h1 id="编译一个动态库文件"><a href="#编译一个动态库文件" class="headerlink" title="编译一个动态库文件"></a>编译一个动态库文件</h1><h2 id="动态库机制"><a href="#动态库机制" class="headerlink" title="动态库机制"></a>动态库机制</h2><p>静态库引入代码复用的能力后，有一个新的问题出现了：比如abs代码，在多个程序里都有<br>使用，而且这多个程序可能都在系统上执行，这样abs的代码就被系统内存加载了多次。这<br>无疑是一种浪费。</p>
<p>动态库提供了一种机制：库的代码并不会“注入”到编译产出的二进制文件中，而是由操作系<br>统加载对应的库，在程序加载到内存的过程中，操作系统自动把对应的动态库调用进行重定<br>向。这样abs的代码只会在内存中出现一次。</p>
<p>动态库技术是一个非常广泛使用的技术，操作系统大部分的api都是通过动态库提供的。</p>
<p>构建动态库和构建静态库一样简单。我们看一下例子：</p>
<h2 id="动态库项目"><a href="#动态库项目" class="headerlink" title="动态库项目"></a>动态库项目</h2><p>延用静态库的例子，我们只需要把 <code>CMakeLists.txt</code> 修改一下即可。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(abs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(abs SHARED abs.cpp)</span><br></pre></td></tr></table></figure>
<p>构造的结果会产生一个 <code>libabs.so</code> 文件。读者可以自行尝试一下。</p>
<p>如果要同时构建静态库和动态库，cmake的写法需要一点技巧：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(abs)</span><br><span class="line"><span class="keyword">add_library</span>(abs SHARED abs.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(abs_static STATIC abs.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(abs_static PROPERTIES OUTPUT_NAME <span class="string">"abs"</span>)</span><br></pre></td></tr></table></figure>
<p>这是因为cmake中不允许target有相同的名字，所以我们需要用不同的名字，同时修改target的输出。</p>
<h1 id="引入库文件"><a href="#引入库文件" class="headerlink" title="引入库文件"></a>引入库文件</h1><h2 id="引入子模块"><a href="#引入子模块" class="headerlink" title="引入子模块"></a>引入子模块</h2><p>使用 <code>add_subdirectory</code> 函数，可以把子文件夹中的 <code>CMakeLists.txt</code> 引入到当前<br><code>CMakeLists.txt</code> 中。</p>
<p>举个例子：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(helloworld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(./ ./hello ./world)<span class="comment">#添加多目录的路径</span></span><br><span class="line"><span class="comment"># Add block directories</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(hello)<span class="comment">#添加hello文件夹中的hello库</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(world)<span class="comment">#添加world文件夹中的world库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(helloworld main.cpp)</span><br><span class="line"><span class="comment">#将多目录下的hello库和world库链接上可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(helloworld hello world)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>add_subdirectory</code> 会把对应文件夹中的 <code>CMakeLists.txt</code> 引入进来，包括内部的<br>target。这里假定了 <code>hello</code> 文件夹的target是 <code>hello</code> ， 这里假定了 <code>world</code> 文件<br>夹的target是 <code>world</code> 。</li>
<li><code>target_link_libraries</code> 用来对 <code>helloworld</code> 这个target进行更多的描述：描述这个<br>target完成过程中，需要对 <code>hello</code> 以及 <code>world</code> 两个target进行链接（这两个target<br>必须是库）</li>
</ul>
<p>完整的目录结构：<br><img src="/images/cmake-tutorial/multi-cmake.png" alt="多目录CMake结构"></p>
<h2 id="引入第三方库"><a href="#引入第三方库" class="headerlink" title="引入第三方库"></a>引入第三方库</h2><p>由于大量开源模块都是使用cmake进行构建的，因此存在大量的开源脚本方便你快速把第三<br>方库引入到你的项目里。</p>
<p>我们这里以引入opencv为例。</p>
<p>编写一个使用opencv的程序， <code>hello_cv.cpp</code> 。</p>
<ul>
<li>复制官方文档的代码：<br><a href="https://docs.opencv.org/3.2.0/d0/d2a/contours2_8cpp-example.html">https://docs.opencv.org/3.2.0/d0/d2a/contours2_8cpp-example.html</a></li>
</ul>
<p>想要让这个程序运行起来，有以下几个条件：</p>
<ul>
<li>本地需要安装opencv开发环境。使用命令 <code>sudo apt-get install libopencv-dev</code></li>
<li>检测opencv是否安装成功 <code>dpkg -L libopencv-dev</code> 。这个命令会显示上面安装的包里<br>的文件都被安装到什么位置了。在我的系统里，文件主要被安装在 <code>/usr/bin</code> ,<br><code>/usr/include</code> , <code>/usr/lib/x86_64-linux-gnu</code>, <code>/usr/share/OpenCV</code> 这几个文件夹<br>中。</li>
</ul>
<p>接着，我们创建cmake配置文件：</p>
<ul>
<li>告诉cmake去那里找头文件，显然是要在 <code>/usr/include</code> 里找</li>
<li>告诉cmake去那里找库文件，显然是要在 <code>/usr/lib/x86_64-linux-gnu</code> 里找</li>
<li>告诉cmake应该链接哪些库文件，显然是 <code>libopencv_core.so</code> 、<br><code>libopencv_highgui.so</code> 和 <code>libopencv_imgproc.so</code> </li>
</ul>
<p>于是我们的 <code>CMakeLists.txt</code> 如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定查找头文件的目录                                                                                                                                 </span></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 指定查找库文件的目录                                                                                                                                 </span></span><br><span class="line"><span class="keyword">link_directories</span>(/usr/lib/x86_64-linux)</span><br><span class="line"><span class="comment"># 指定项目的target，产生一个二进制                                                                                                                     </span></span><br><span class="line"><span class="keyword">add_executable</span>(hellocv hello_cv.cpp)</span><br><span class="line"><span class="comment"># 指定链接库，优先链接动态库                                                                                                                           </span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hellocv opencv_core opencv_highgui opencv_imgproc)</span><br></pre></td></tr></table></figure>

<p>最后得到的结果：<br><img src="/images/cmake-tutorial/opencv.png" alt="opencv编译"></p>
<p>运行结果：<br><img src="/images/cmake-tutorial/opencv-demo.png" alt="opencv demo"></p>
<h2 id="使用find-package"><a href="#使用find-package" class="headerlink" title="使用find_package"></a>使用find_package</h2><p>引入opencv非常容易，但有一个新问题。不同的平台上，opencv的安装地址可能不一样。如<br>何才能更加通用的探测各个平台的opencv，并正确的链接呢？</p>
<p>cmake为了解决这个问题，要求所有兼容cmake的包，都编写对应的cmake模块。比如opencv<br>包安装文件，就包含了对应的cmake模块：<br><img src="/images/cmake-tutorial/opencv-cmake-s.png" alt="opencv cmake"></p>
<p>这里的.cmake文件被安装到 <code>/usr/share</code> 文件夹下。这个是cmake会搜索模块的路径之一。</p>
<ul>
<li>具体参见：<a href="https://cmake.org/cmake/help/v3.0/command/find_package.html">https://cmake.org/cmake/help/v3.0/command/find_package.html</a></li>
</ul>
<p>因此，我们只需要很简单的修改我们的cmake文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 OpenCVConfig.cmake 里面的注释，可以知道用法：</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定二进制和链接库</span></span><br><span class="line"><span class="keyword">add_executable</span>(hellocv hello_cv.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hellocv <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样即保证了跨平台，又很简单。赶快试一下吧！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">crackhopper</p>
  <div class="site-description" itemprop="description">一个做算法的技术宅</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crackhopper</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'CgYmCkO7FRljeD1Y1MRPlOnN-gzGzoHsz',
      appKey: 'Dufr6C96FrKMfcvai8LqRTNt',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
