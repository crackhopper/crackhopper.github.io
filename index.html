<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://localhost:4000').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="一个做算法的技术宅">
<meta property="og:type" content="website">
<meta property="og:title" content="crackhopper的博客">
<meta property="og:url" content="http://localhost:4000/index.html">
<meta property="og:site_name" content="crackhopper的博客">
<meta property="og:description" content="一个做算法的技术宅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="crackhopper">
<meta property="article:tag" content="shadoc">
<meta property="article:tag" content=" hoppe">
<meta property="article:tag" content=" crackhopper">
<meta property="article:tag" content=" developer">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://localhost:4000/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>crackhopper的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">crackhopper的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">分享，积累，进步</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/06/14/think-in-start-up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/think-in-start-up/" class="post-title-link" itemprop="url">思考：什么人适合创业</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-14 21:53:46" itemprop="dateCreated datePublished" datetime="2020-06-14T21:53:46+08:00">2020-06-14</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/06/14/think-in-start-up/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/think-in-start-up/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创业者需要的5个素质"><a href="#创业者需要的5个素质" class="headerlink" title="创业者需要的5个素质"></a>创业者需要的5个素质</h1><p>互联网时代是一个传奇的时代。在这里，没什么背景的普通人，都可以拥有传奇般的人生经<br>历，赚取普通人一辈子都赚不到的金钱。而互联网发展也让更广大的人们连接到了一起，让<br>人们看到了很多普通人是如何实现自己的“财富自由”的：做app，做网站，开网店，做主播，<br>做代购等等等等，也让人们看到了惊人的财富被赚取到这些普通人的手中。在巨大的财富收<br>益刺激下，很多人都萌生了创业的念头，想要辞掉工作进入商海，说不定下一个成功的人就<br>是自己。也有很多人开始相信，普通人通过努力也可以成为大富豪。</p>
<p>事实真的是这样么？普通人可以努力开创自己的事业，实现财富自由么？答案取决于怎么去<br>定义“普通”。如果“普通”指的是“不具备巨大的财富”、“不具备惊人的人脉关系”、或者说<br>“不具备较高的知识素养”，那么这样的一个“普通”人也是有机会创业成功的。但这不意味着<br>这些人真的“普通”，他们往往具备其他人所不具备的东西。从我个人的观察和思考来看，这<br>些东西是：“运气”、“头脑”、“决心”、“毅力”、“行动力”，基本上缺一不可。</p>
<h2 id="运气"><a href="#运气" class="headerlink" title="运气"></a>运气</h2><p>“运气”这个东西，看不见摸不着。你怎么能保证自己有个好“运气”呢？就算你各种的条件都<br>具备，就是没有运气，那你也无法做成事情啊？如果运气是主要的，为什么不去赌博，去买<br>彩票？如果你的想法是上面这些疑问，那么你并不适合创业。</p>
<p>知道创业成功一定是有“运气”成分，这个很重要。而深入理解“运气”是什么，也很重要。</p>
<p>所谓“运气”，其实就是“好事情”发生的概率。在人生这条时间轴上，好事情会让人进步，坏<br>事情会让人退步。对所有发生的事情，好坏的影响加和，就是这个人一生的运气。而一生的<br>运气，往往会符合正太分布。这其实就是概率学里著名的中心极限定理。</p>
<p>更深入的解释这个均值，就会发现它代表的含义很多。从个人的角度来看：“平均富裕程度”，<br>“平均知识水平”，“平均努力程度”等等。为什么努力会跟运气有关呢？其实一个人的知识地<br>位水平越高，那么对他而言机会也就越多，好运气自然也就越多；这个是社会自动进步带来<br>的机制。从更宏观的角度来看：“社会的平均进步水平”，“行业的平均发展水平”这些都能影<br>响一个人的运气。</p>
<p>运气是可以改变的。因为概率是可以改变的。改变的方式就是让概率变成条件概率。即让普<br>通的正态分布，变成某个条件下的分布，往往就不是原来的正态分布了（比如均值偏大，好<br>运偏多）。简单来说，我们知道行业的平均发展水平往往会影响一个创业人拥有的运气；越<br>是蓬勃的行业，越有“运气”。于是我们选择一个蓬勃的行业来创业，这样我们就得到了运气<br>更好的起点。创业人也有另一个说法叫“选择一个大的市场”，越大的市场，机会空间越大，<br>发展潜力也越大，其实也就提高了运气的平均水平。</p>
<p>但你要知道，运气是像概率一样的东西；无论你研究的多么深入，都不能百分百保证好运。<br>而你也不应该在提升“运气”这个事情上，不断的研究。因为还有一个很重要的因素，那就<br>是————时间。你需要用更多的时间去创业，做创业该做的事情。</p>
<p>好事情的发生是随机的遍布时间轴的，因此要碰到更多的好事情，就需要坚持创业足够长的<br>时间。时间越长那么发生好事的概率越大。这就是很多创业书籍都告诉你要“坚持到底”的原<br>因。但同样你要注意到，时间坚持的越长，发生坏事的概率也越大。因此采取手段有效避免<br>坏事的影响，对创业来说也是至关重要的。比如：学习知识，总结历史，总结他人的经验，<br>累积自己的经验。</p>
<p>你要相信运气是个随机分布。你也要深入理解随机不代表都一样，你的选择会影响概率本身<br>的变化。合适并合理的选择，是创业的第一步。</p>
<h2 id="头脑"><a href="#头脑" class="headerlink" title="头脑"></a>头脑</h2><p>“头脑很重要，不聪明的人无法创业”，“头脑是天生的，我不爱学习，改变不了头脑”，“我<br>很聪明，很有头脑，我智商远高于普通人”，“我相信我的头脑，我要专注的做自己认为重要<br>的事情”，“我不相信自己的头脑，我要多听取别人的意见”。上面任意一个想法，只要你觉<br>得说的很对很正确，那么你并不具备创业需要的“头脑”。</p>
<p>头脑是个极其复杂的东西。极其聪明和愚笨的人、过分自信或自卑的人、不用头脑和过分使<br>用头脑的人，都可能对创业所做的事情过于“专注”，或者过于“不专注”。过于“专注”，会在<br>撞死在南墙上，由于选择了均值极低的分布，往往也等不到运气来临的那天。过于“不专注”，<br>就会同时做太多事情，在每个事情上坚持的时间太短，就是就相当于在原地转圈，虽然选择<br>了很多运气分布，但每个运气分布的均值都很低，最终一事无成。</p>
<p>如果要我说创业需要什么样的头脑。我认为，创业需要一个能容纳矛盾观点同时合理存在的<br>“头脑”：灵活但有耐心，谦虚但有自信，相信理论同时也要结合实际。要真正的做到这六点，<br>而不是做表面功夫。比如假装谦虚实际听不进建议，假装有耐心实际很焦躁，假装认可理论<br>实则不屑一顾，或者假装脚踏实地实则觉得不符合预想的理论也没啥前景。</p>
<h2 id="决心"><a href="#决心" class="headerlink" title="决心"></a>决心</h2><p>决心是一个创业人内在的力量。可以简单的理解一个人为了达成自己的愿望愿意付出的努力。<br>因此决心包含两个部分：愿望，努力。</p>
<p>首先，创业人该有的愿望，应该是一个无论何时何地、何种场景都能坚持下去的愿望。举几<br>个常见的不靠谱的愿望：</p>
<ol>
<li>赚很多钱。那如果你创业坚持的过程中一直在赔钱，而且这个事情是大概率发生的，请<br>问你是不是和“赚很多钱”的愿望矛盾了？如果遇到困难，本来可以坚持克服过去，但克<br>服需要亏很多钱，是不是又和“赚很多钱”的愿望矛盾了？如果每次都要用“现在的亏钱是<br>为了未来的赚钱”来缓解自己，那你到底能坚持多久呢？能坚持一辈子么？（一辈子亏欠<br>都不赚，也要选择创业）</li>
<li>不努力躺赢。首先，你在愿望里都描述清楚了你应该怎么做，你需要“躺着”。那你有其<br>他选择么？如果你选择了工作或做事情，那违背了“躺”的感觉。跟上一个问题一样，你<br>只能用“现在的努力是为了以后的躺赢”来缓解自己，那你到底能坚持多久呢？能坚持一<br>辈子么？（一辈子努力也无法躺赢，也要选择创业）</li>
<li>给自己打工，而不是给别人打工。其实很容易做到，不工作开公司就可以了。而开个公<br>养活自己，也不会十分困难；看看别人怎么做的，深入模仿就行了。问题是你达到了之<br>后呢？靠一个很容易的目标，是无法给人决心：开个公司养活自己为什么就比找工作养<br>活自己更值得做？找工作养不了自己么？</li>
</ol>
<p>上面两个是很多人有的愿望，但在很多缺乏动力的提供。因为任何一个坏事情的到来都会让<br>这些愿望的坚持变得非常困难。另外，在愿望中过分细节的描写愿望实现的办法，也不是靠<br>谱的做法。</p>
<p>举几个靠谱的愿望：</p>
<ol>
<li>体验以“科技进步、应用与创新”造福大众的真正快乐。当然不是所有人都有这样的愿望，<br>但对于有这样愿望的人来说，这个愿望是值得追求的，是无论遇到困境还是顺境都不会<br>变的。（这个是索尼的理念）</li>
<li>领导航空工业，永为先驱。听起来很虚无飘渺，很难做到。但信念和决心本身是不需要<br>细节的，否则为什么很多人会信上帝。（这个是波音的理念）</li>
</ol>
<p>举这些例子并不是告诉大家要“务虚”，只是想说，在确立决心这种事情上，“务虚”要比“务<br>实”更有作用。而怎么把“虚”化“实”，则需要头脑、毅力和行动力的结合了。比如索尼的理<br>念很虚，实际做法呢？开始的时候研究电饭煲(可以说跟理念有结合但很失败)，困难的时候<br>靠买劣质电热毯度日(很难和他的理念有真正的结合)。因此这些虚幻的目标在实现的时候，<br>往往是曲折的。“愿望”和“活下去”需要不停的权衡，但任何一个都不能失去。而前进的动力<br>主要源自“愿望”，而不是“活下去”。</p>
<p>至于决心的另一个事情也要充分考虑：愿意为了愿望付出多大的努力。换句话说，要考虑清<br>楚最坏的情况下，自己能否承受下去。常见的情况有：没有充分的休息时间、没有合理的收<br>入、远超工作时的焦虑、无时无刻都要面临竞争者的恶意、其他人的恶语相向、追随者的失<br>望。至于成功之后的自我膨胀也需要提防，但那是成功之后的幸福烦恼了。</p>
<h2 id="毅力"><a href="#毅力" class="headerlink" title="毅力"></a>毅力</h2><p>毅力是一个不需要怎么解释，大家也能理解的东西。因此可以说它是最简单的条件。而很多<br>人都不具备毅力，因此他也可以说是最难的条件。其实毅力是一个相对的东西，当你的短板<br>是毅力的时候，那么你需要去努力形成它。形成的办法就是：从内因上，养成习惯，体会其<br>中的乐趣；从外因上，被迫强制去做某个事情。</p>
<p>毅力在创业中，最大的要求是，不能作为你的短板出现；其次的要求是，你要超过竞争对手<br>的毅力水平。</p>
<p>毅力是可以磨练的。不过听起来是个很诡异的事情就是：磨练毅力也需要毅力。可以的做一<br>些对自己长期有好处的事情。如果失败了，想方设法化解掉负面情绪，靠鸡汤再次站起来。<br>久而久之，毅力就被提升起来了。</p>
<p>但一定要注意，这个东西不是万能的。比如你的目标是百米3秒，这不是你能靠毅力能达到<br>的。就算目标是人类能达到的，但毅力只是其中的原因之一，其他方面仍然很重要。</p>
<h2 id="行动力"><a href="#行动力" class="headerlink" title="行动力"></a>行动力</h2><p>行动力在我看来是所有五条里最容易的了。但他和其他点配合起来，才有真正的威力。甚至<br>任何一项和行动力结合，不能说会成功，但也会有莫大的收获。</p>
<p>行动力的关键就是：做。能够带着你自己想到的所有“不做”的理由，仍然去做下去。做一个<br>事情，是需要一个人能克服自己对自己造成的心里障碍的；尤其是“不做”的理由不够强大的<br>时候，那就做下去；“不做”的理由十分强大的时候，也要做到完成阶段性目标（对创业来说<br>就是产品达到可以提供用户价值的程度；当然，在做完之后仍然不可行的时候，你的头脑会<br>帮助你整理经验，切换方向，让你去做下一个事情）。</p>
<h1 id="木桶理论"><a href="#木桶理论" class="headerlink" title="木桶理论"></a>木桶理论</h1><p>创业想要真正成功，那么需要：运气、头脑、决心、毅力和行动力。而创业失败，你只需要<br>其中一项具有致命弱点就可以了。</p>
<ol>
<li>运气。一个人运气不好，生命提早结束。那又有什么办法呢？但比起极端情况，选择可<br>以让你拥有比不选择来说，更好的运气。</li>
<li>头脑。自负，固执，不专注。都会让你品尝失败的苦果。如何合理的权衡，则需要你在<br>实践中进行学习。很多创业的人常说：当你没办法的时候，你应该停止行动，换个方向<br>思考。但很多人太容易没办法，或者太不容易没办法，都是存在问题的。真正的办法只<br>有实践、反思、不断调整自己。</li>
<li>决心。没有决心，那么很多选择你都做不了；行动也茫然无序，一筹莫展。</li>
<li>毅力。没有毅力，那你不会完成任何一个复杂的任务。</li>
<li>行动力。没有行动力，那么上面的都属于空想。</li>
</ol>
<p>这就好比木桶理论，你只要一个板短，那么整体的盛水就盛不了多少。创业的人，需要的是<br>基本素质的均衡。</p>
<h1 id="关于创业者的迷思"><a href="#关于创业者的迷思" class="headerlink" title="关于创业者的迷思"></a>关于创业者的迷思</h1><p>下面直接针对一些常见的片面的观点举例子。</p>
<h2 id="创业者要有钱"><a href="#创业者要有钱" class="headerlink" title="创业者要有钱"></a>创业者要有钱</h2><ul>
<li>马云创建阿里巴巴的时候，并不是一个有钱人。</li>
<li>王思聪创建直播公司的时候，很有钱，但没成功。(头脑问题，不是说王思聪笨，而是说<br>他知识和经验不够，外加过度自信)</li>
<li>大量小本买卖，基本看天吃饭；多的时候能赚到很多，少的时候则少得可怜。(运气，头<br>脑，决心、毅力、行动力都有但都不强；主要靠运气带动收益)<h2 id="创业者要有逆天的运气"><a href="#创业者要有逆天的运气" class="headerlink" title="创业者要有逆天的运气"></a>创业者要有逆天的运气</h2></li>
<li>华为创建的时候，路由器市场已经形成巨头垄断；而且任正非属于工作失误被辞退。运气<br>跟逆天没有半点关系。</li>
<li>常常会有人中彩票，运气逆天了。但照样泯灭于社会。(头脑、决心、毅力、行动力都不<br>行)</li>
<li>在线出行时代，OFO是有好的运气，风口、热点、头部公司，然而濒临破产。(头脑问题：<br>缺乏经验，同时过度自信)</li>
<li>大量融到大笔良性资本，但没实现盈利的企业。(决心问题、行动力问题、部分头脑问题)<h2 id="当今的时代，创业者需要xxxx"><a href="#当今的时代，创业者需要xxxx" class="headerlink" title="当今的时代，创业者需要xxxx"></a>当今的时代，创业者需要xxxx</h2>既然结论是“当今的时代”，那么就不是一个普遍的结论，也不是一个本质的结论。</li>
</ul>
<p>举几个例子：</p>
<ul>
<li>很多人觉得，当今的时代，创业者选择服装这么传统的行业没什么可做的了。但是在快<br>消品牌做起来之前，很多人也是这么觉得的。</li>
<li>很多人觉得，当今的时代，创业者选择巨头所在的行业是自找灭亡。但是在华为做起来之<br>前(多个国际巨头存在的情况下崛起)，很多人也是这么觉得的。</li>
<li>很多人觉得，当今的时代，创业者必须融资。也许过个几年，你发现某一个大公司没有任<br>何融资，仍然发展的很健康。就像华为一样。你敢保证不会出现下一个完全不上市的巨头<br>么？反过来说，过去的时代，大家没有“创业者必须筹集足够的钱”这样和你一样的观点么？<br>那么那些没有筹到很多钱的公司，就真的没有做起来的么？</li>
</ul>
<p>时代在变，但除了最基本最核心的对创业人的要求以外，没什么是真正需要的。不要局限住<br>自己。当你认为某个东西是“某个时代”才可行的，“这个时代”是不可行的，那么往往就是你<br>没看透本质。</p>
<h2 id="创业者需要有好的背景-最好是大厂出身"><a href="#创业者需要有好的背景-最好是大厂出身" class="headerlink" title="创业者需要有好的背景(最好是大厂出身)"></a>创业者需要有好的背景(最好是大厂出身)</h2><ul>
<li>大厂创业失败的例子太多了。比如，物联网泡沫期，几乎全行业阵亡。</li>
<li>没有什么背景成功的例子也太多了。比如，老干妈。<h2 id="创业者需要有广泛的人脉"><a href="#创业者需要有广泛的人脉" class="headerlink" title="创业者需要有广泛的人脉"></a>创业者需要有广泛的人脉</h2></li>
<li>王思聪创建直播公司的时候，很有人脉，但没成功。</li>
<li>马云并不是很有人脉的人，只是做着做着渐渐有了人脉。</li>
<li>很多创始人是草根出身，人脉都是熬的足够久，运气中的好事情发生，逐渐积累起来的。<h2 id="创业者需要有渊博的知识"><a href="#创业者需要有渊博的知识" class="headerlink" title="创业者需要有渊博的知识"></a>创业者需要有渊博的知识</h2></li>
<li>很多教授创立的公司很成问题。</li>
<li>哪怕是知名MBA教授创立的公司，目前也算不上世界上最伟大的公司的行列。</li>
</ul>
<p>但不可否认，有知识的人创立的公司，下限比较高。</p>
<h2 id="创业者要是一个偏执狂"><a href="#创业者要是一个偏执狂" class="headerlink" title="创业者要是一个偏执狂"></a>创业者要是一个偏执狂</h2><p>较正常人来说的偏执是需要的。否则你连产品都做不好，各处得过且过。所有的加到一起就<br>岌岌可危了。</p>
<p>但“偏执狂”就过了。真正很多成功的公司，也完成过大转型。</p>
<ul>
<li>Intel公司本来是存储硬件的领军者，后来不得不转为买CPU。</li>
<li>3M公司本来是打算经营一个矿场，提供金刚沙，后来却转为提供各种制作的产品。</li>
</ul>
<p>按照偏执狂的设定，那么这些公司就应该坚持做存储，坚持采矿。那么也就不会有现在伟大<br>的公司。偏执是需要的，灵活变通也是需要的。真正不变的，应该是决心里的远景。</p>
<h2 id="创业者要是个追求完美主义的人"><a href="#创业者要是个追求完美主义的人" class="headerlink" title="创业者要是个追求完美主义的人"></a>创业者要是个追求完美主义的人</h2><p>较正常人来说的完美主义是需要的。但过分的追求“完美主义”，会让你根本就做不出产品来。<br>更别提盈利了。不盈利的公司，谈不上创业成功。</p>
<h2 id="创业者需要是个天才"><a href="#创业者需要是个天才" class="headerlink" title="创业者需要是个天才"></a>创业者需要是个天才</h2><p>搞科研才需要真正的天才，很多人的思辨能力和灵感，是难以解释的。天才，往往能通过很<br>小的努力就得到巨大的收益。</p>
<p>创业者需要的是努力，做好充足的准备，能够把握住运气的降临。</p>
<h2 id="创业者需要有领袖气质"><a href="#创业者需要有领袖气质" class="headerlink" title="创业者需要有领袖气质"></a>创业者需要有领袖气质</h2><p>“领袖气质”是个很主观的东西。因此你觉得自己没有，可能其他人觉得你有。而你觉得自己<br>有，其他人也会觉得你没有。</p>
<p>模糊的东西，仅仅值得研究，可能里面有潜在的规律。但并不会是创业者所必须的，也并不<br>会是成功的主要因素。（如果领袖气质是主要因素，那么这个词就不会如此模糊，也不会在<br>对领袖气质的判断上，很多人都无法达成共识。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/06/14/let-us-write-compiler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/let-us-write-compiler/" class="post-title-link" itemprop="url">小白学写编译器：1.编译基础概念</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-14 21:49:51 / Modified: 22:07:35" itemprop="dateCreated datePublished" datetime="2020-06-14T21:49:51+08:00">2020-06-14</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/06/14/let-us-write-compiler/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/let-us-write-compiler/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><p>我们知道CPU是计算机的大脑，也知道计算机只认识由0和1组成的二进制码，比如<br>“1001010110101010” 这样的。具体来说，当计算机的CPU遇到一个这样的二进制码时，会做<br>出相应的动作：读取内存、写入内存、执行加法、执行乘法、向其他设备发送IO指令(读取<br>键盘、写入显示器)等等。每个CPU都有自己所识别的二进制码，我们称之为 <strong>机器指令</strong><br>(machine code) 。将一系列机器指令组合成一个集合，那么计算机就可以完成很多复杂的<br>计算和行为，这种机器指令的集合，我们称呼为 <strong>程序</strong> (program)。当计算机运行一个<br>程序的时候，我们会说计算机正在执行一个 <strong>任务</strong>(task) 或 <strong>进程</strong> (process) 。</p>
<p>最早的程序员是使用机器语言编写程序的。比如早期的大家用纸带编写程序，通过对纸带上<br>是否打孔来区分是0还是1，从而识别出机器指令，让CPU执行计算。而如今随着技术的发展，<br>开发程序的工作即被便利化也被复杂化了。大家不再使用二进制开发程序，而是使用编程语<br>言(programming language)。</p>
<p>机器指令插图</p>
<h1 id="编程语言和编译器"><a href="#编程语言和编译器" class="headerlink" title="编程语言和编译器"></a>编程语言和编译器</h1><p>二进制代码太难以记忆，并且编写的程序很难阅读。因此人们首先开发了叫做 <strong>汇编</strong><br>(assembly) 的 <strong>编程语言</strong> (programming language)，用英文字母来代替机器指令。汇<br>编语言是比机器指令更容易理解的指令集，也更容易开发程序。但英文字母并不能被CPU理<br>解，因此需要由 <strong>汇编器</strong> (assembler) 把汇编代码翻译成机器指令。</p>
<p>后来人们发现这种方式非常有效果。因此发明了更多好用的编程语言，也更加接近自然语言<br>的表达方式，比如Fortran，Lisp，C语言等等。由编程语言编写的代码称为 <strong>源代码</strong><br>(source code) ，机器指令的集合称为 <strong>目标代码</strong> (object code) 。而把源代码翻译成<br>目标代码的工具，称为 <strong>编译器</strong> (compiler)</p>
<p>编译器的图示</p>
<p>编译器本身是一个非常复杂的程序。而开发编译器也是一个非常复杂的工程。编译器的作用<br>是生产程序，而编译器本身也是程序。因此编译器也是由编程语言开发的。那么困惑的点来<br>了，如果编译器是由编程语言开发的，那么编译器的源代码由谁来翻译？实际上，第一版编<br>译器是由机器指令开发的，实现了简单的汇编语言；随后用汇编语言再次开发了最初版本的<br>C语言；随后由C语言本身开发C语言的编译器。当一个语言可以用自己开发自己的编译器，<br>这种语言我们说它实现了 <strong>自举</strong>(bootstrap)。和编译器工程特别相似的就是机械领域的<br>大部分机床，第一代机床都是手工制作的；随后各代机床利用前代机床生产的零件，提升自<br>己的性能。大部分发达国家的技术垄断都是这种需要多轮迭代的技术。</p>
<p>和编译器相似的一个概念叫做 <strong>解释器(interpreter)</strong> 。解释器并不会产生目标程序，<br>而是直接将源代码一句一句的转化为机器指令进行执行。</p>
<p>解释器的图示</p>
<p>举两个例子：</p>
<ul>
<li>C语言由它的编译器——gcc进行编译，生成机器二进制码组成的程序，由CPU直接执行。类<br>似C语言这种编译生成由CPU直接执行的机器指令的语言，我们叫做 <strong>编译型语言</strong> 。</li>
<li>javascript语言由它的解释器——浏览器进行解释执行。javascript语言并不会生成程序，<br>真正被CPU执行的程序仍然是浏览器。而浏览器将javascript代码动态的转化为机器指令。<br>这种由其他程序(解释器)作为宿主，解释执行的语言，我们叫做 <strong>解释型语言</strong> 。</li>
</ul>
<p>实际上，很多现代的编程语言可以说是编译型和解释型相混合的。典型的例子就是java。<br>java会把源代码翻译成一种叫中间代码的文件(.class文件)，中间代码并不能被CPU理解，<br>但是可以被一个叫做JVM的程序理解并执行。可以看到下图中，java的编译器既包含编译器<br>也包含解释器。这里面的解释器有另一个名字，叫做 <strong>虚拟机</strong>(Virtual Machine)，因为<br>它像一个虚拟的机器一样。</p>
<p>java编译器的图示。</p>
<p>也许有人会说java最终是被解释执行的。但其实在java中也引入了一个叫JIT(Just In Time<br>Compiler)的技术，这个技术会将高频使用的中间代码在运行时动态地编译成机器代码。在<br>这样的情况下，就更难说java是编译型还是解释型了。</p>
<h1 id="编译器的构造"><a href="#编译器的构造" class="headerlink" title="编译器的构造"></a>编译器的构造</h1><p>接下来，我们较为浅显的看一下编译器的构造。</p>
<h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><p>从简单粗暴的方式来看，编译器主要是两个部分：</p>
<ul>
<li>分析部分：分析源代码，形成一个中间结构（中间代码）</li>
<li>综合部分：从中间结构，翻译成目标代码（机器代码）</li>
</ul>
<p>其中，分析部分也叫做编译器前端(front end)，综合部分也叫做编译器后端(back end)。</p>
<p>宏观视角图</p>
<h2 id="微观视角"><a href="#微观视角" class="headerlink" title="微观视角"></a>微观视角</h2><p>如果更加细节的看编译器的构造，可以分为以下部分：</p>
<ol>
<li>词法分析：将源代码转化为token序列 (类似于把一篇文章，按照单词拆分开)</li>
<li>语法分析：将token序列组织成语法树 (类似于把单词，按照语法组合成句子)</li>
<li>语义分析：验证语法树上的元素，做一些转换 (类似于把句子的语法格式标准化)</li>
<li>中间代码生成器：将语法树转化为 某种更基础格式的代码序列 (类似于把一个标准化的中文句子<br>翻译成标准化的英文句子)</li>
<li>机器无关代码优化：对中间代码优化（类似于将英文句子写的更加优美）</li>
<li>代码生成器：把中间代码转化为目标代码 (类似于将英文句子转化为某种方言下的英文，<br>比如美式英文)</li>
<li>机器相关代码优化：对目标代码优化（类似与对美式英文的文章进行润色）</li>
</ol>
<p>微观视角图</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们举一个龙书上的例子，考虑下面的语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">position</span> = initial+rate*<span class="number">60</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/let-us-write-compiler/compile.png" alt="赋值语句的编译"></p>
<ol>
<li>词法分析：将代码中的代词分离成一个个token。其中id代表标识符(identifier)。每个<br>标识符被存入到对应的符号表中。词法分析输出了token序列。</li>
<li>语法分析：把token按照结构组织起来。先做乘法再做加法，最终进行赋值。语法分析的<br>主要结果就是形成了语法树(syntax tree)。</li>
<li>语义分析：假设rate是浮点类型，60是整数类型，由于他们在内存中表达形式不一样，<br>无法直接做乘法运算。于是语义分析中，将60转化为了浮点类型。语义分析主要就是校<br>验语法树。</li>
<li>中间代码生成：我们将语句转化为更接近机器能理解的语句。常用的一种格式叫做三地<br>址代码 (three-address code) 。即一个语句中最多有三个变量。</li>
<li>代码优化器：对代码进行化简，让代码数量变得更少。</li>
<li>代码生成器：形成机器代码。</li>
</ol>
<h2 id="将多个步骤组合成趟-pass"><a href="#将多个步骤组合成趟-pass" class="headerlink" title="将多个步骤组合成趟(pass)"></a>将多个步骤组合成趟(pass)</h2><p>之前我们对编译器的拆解是逻辑拆解。在实际实现的时候，多个逻辑步骤会组合到一起，形<br>成一个 <strong>趟</strong> (pass/phrase) 。每趟读入一个输入文件并产生一个输出文件。比如前端步<br>骤中的词法、语法、语义以及中间代码生成可以组合成一趟；代码优化可以单独组合成一趟。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们浅显地讲解了程序的概念，程序是由机器指令构成的集合。讲解了程序是如何制作的，<br>程序是编译器将源代码编译成目标代码，从而制作出来的。</p>
<p>进一步的，我们探索了编译器的构造。了解了编译器的前端的组成部分：词法分析、语法分<br>析、语义分析和中间代码生成；编译器后端的组成部分：机器无关代码优化，机器相关代码<br>优化，生成目标代码。此外，将一系列步骤组合到一起，从一个输入文件产生一个输出文件<br>的过程叫做趟。</p>
<p>后续，我们将从编译器的构造一步一步展开讨论。下一节我们讨论的是词法分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/02/15/cmake-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crackhopper">
      <meta itemprop="description" content="一个做算法的技术宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crackhopper的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/15/cmake-tutorial/" class="post-title-link" itemprop="url">cmake入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-15 20:48:22" itemprop="dateCreated datePublished" datetime="2020-02-15T20:48:22+08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-22 18:20:41" itemprop="dateModified" datetime="2020-02-22T18:20:41+08:00">2020-02-22</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/15/cmake-tutorial/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/15/cmake-tutorial/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CMake是一个主要用来管理C++项目的工具。主要特点是：更好的解决C++项目跨平台编译带<br>来的配置问题。</p>
<p>CMake提供很多实用的功能，本文简单介绍我项目里常用的一些特性。</p>
<p>如何安装CMake这里就不介绍了，可以自行搜索。安装好后要确保在命令行可以执行cmake命<br>令。</p>
<h1 id="编译一个可执行文件"><a href="#编译一个可执行文件" class="headerlink" title="编译一个可执行文件"></a>编译一个可执行文件</h1><h2 id="Hello-World项目"><a href="#Hello-World项目" class="headerlink" title="Hello World项目"></a>Hello World项目</h2><p>CMake通过找寻目录下的 <code>CMakeLists.txt</code> 文件，读取文件里的内容对项目进行构建。使<br>用方式是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake &lt;project_dir&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;project_dir&gt;</code> 是 <code>CMakeLists.txt</code> 所在的文件夹。cmake的工作流程如下：</p>
<ol>
<li>cmake读取 <code>&lt;project_dir&gt;</code> 文件夹下面的 <code>CMakeLists.txt</code> 文件。</li>
<li>执行平台解析，基础库解析，依赖库查找。如果有错误则暴露错误，如果成功则生成一<br>系列用来构建的文件。其中最重要的一个文件叫 <code>Makefile</code> 。</li>
<li>用户通过执行 make ，读取  <code>Makefile</code> 对项目进行构建。</li>
</ol>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>看一个简单的例子，目录层级如下：<br><img src="/images/cmake-tutorial/hello-world.png" alt="最简单的cmake"></p>
<p>其中，两个文件的内容：</p>
<p><strong>helloworld.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CMakeLists</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">9</span>)</span><br><span class="line"><span class="keyword">project</span> (hello)</span><br><span class="line"><span class="keyword">add_executable</span>(hello helloworld.cpp)</span><br></pre></td></tr></table></figure>

<p>这里解释一下 <code>CMakeLists.txt</code> 的内容。</p>
<ul>
<li>第1行指定最低的cmake版本</li>
<li>第2行指定项目名称</li>
<li>第3方添加一个任务，生成可执行文件 <code>hello</code> 。生成这个文件需要用到<br><code>helloworld.cpp</code> 。</li>
<li>cmake不区分命令的大小写 。</li>
</ul>
<h3 id="构建helloworld"><a href="#构建helloworld" class="headerlink" title="构建helloworld"></a>构建helloworld</h3><p><img src="/images/cmake-tutorial/make-hello-world-s.png" alt="最简单的cmake"></p>
<p>解释一下： </p>
<ul>
<li><code>cmake .</code> 运行cmake命令，查找目录为 <code>.</code> (即当前目录) 。这个命令会生成一系列文<br>件。包括一个重要的 <code>Makefile</code> 文件</li>
<li><code>make</code> 会在当前文件夹查找 <code>Makefile</code> 文件 ，然后对项目进行编译，最终产生了二进<br>制 <code>hello</code></li>
<li><code>./hello</code> 运行这个编译好的二进制文件</li>
</ul>
<h2 id="项目外构建"><a href="#项目外构建" class="headerlink" title="项目外构建"></a>项目外构建</h2><p>cmake提供了一个非常好用的特性，就是 <strong>项目外构建</strong> 。简单来说，cmake支持在自定义<br>的位置对项目进行构建。这样就避免了构建时生成的临时文件把原本的项目弄的非常混乱。</p>
<p>比如说刚才的例子，我们在项目里创建一个build文件夹，在里面构建。</p>
<p><img src="/images/cmake-tutorial/out-build.png" alt="外部构建"></p>
<p>构建好了之后:<br><img src="/images/cmake-tutorial/out-build-res.png" alt="外部构建结果"></p>
<p>我们可以看到生成的文件都在build文件夹中。进入到里面，进行make即可编译。</p>
<p><img src="/images/cmake-tutorial/out-build-make.png" alt="外部构建make过程"></p>
<h1 id="编译一个静态库文件"><a href="#编译一个静态库文件" class="headerlink" title="编译一个静态库文件"></a>编译一个静态库文件</h1><h2 id="静态库机制"><a href="#静态库机制" class="headerlink" title="静态库机制"></a>静态库机制</h2><p>说静态库首先要说什么是编译。</p>
<p>编译就是把 <strong>源代码</strong> 转化为 <strong>目标代码</strong> 的过程。而什么是 <strong>目标代码</strong> 呢？就是<br>机器可以执行的二进制代码，一般来说都是要符合某种规范的，比如linux下的elf格式，<br>windows下的pe格式。这里就不细展开了。</p>
<p>有的代码具备很强的通用性，比如计算绝对值的函数。我们希望在多个项目里都使用这个函<br>数。那么一个方式就是把你的源代码编译成库文件 （也是一种二进制格式），当你写程序<br>需要的时候，链接器可以 <strong>链接</strong> 到这个库文件中，找到对应函数的二进制，“注入”到你<br>写的程序中。</p>
<p>因此我们通常常见的项目构建都分两步：编译、链接。</p>
<ul>
<li>编译：负责源代码转换为目标代码</li>
<li>链接：负责找到程序的入口（main函数），并把二进制组装起来，生成可执行格式（elf<br>或pe）</li>
</ul>
<p>那么如何把代码构建成一个静态库呢？</p>
<h2 id="静态库项目"><a href="#静态库项目" class="headerlink" title="静态库项目"></a>静态库项目</h2><p>我们先看一下 <code>CMakeLists.txt</code> 的写法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(abs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(abs STATIC abs.cpp)</span><br></pre></td></tr></table></figure>

<p>对应的cpp文件如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v&gt;<span class="number">0</span> ? v : -v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们尝试构建一下：<br><img src="/images/cmake-tutorial/static-lib-s.png" alt="静态库构建"></p>
<p>构建后的结果：<br><img src="/images/cmake-tutorial/static-lib-res.png" alt="静态库构建结果"></p>
<p>注意到，libabs.a文件，即为我们构造出的静态库文件。</p>
<h1 id="编译一个动态库文件"><a href="#编译一个动态库文件" class="headerlink" title="编译一个动态库文件"></a>编译一个动态库文件</h1><h2 id="动态库机制"><a href="#动态库机制" class="headerlink" title="动态库机制"></a>动态库机制</h2><p>静态库引入代码复用的能力后，有一个新的问题出现了：比如abs代码，在多个程序里都有<br>使用，而且这多个程序可能都在系统上执行，这样abs的代码就被系统内存加载了多次。这<br>无疑是一种浪费。</p>
<p>动态库提供了一种机制：库的代码并不会“注入”到编译产出的二进制文件中，而是由操作系<br>统加载对应的库，在程序加载到内存的过程中，操作系统自动把对应的动态库调用进行重定<br>向。这样abs的代码只会在内存中出现一次。</p>
<p>动态库技术是一个非常广泛使用的技术，操作系统大部分的api都是通过动态库提供的。</p>
<p>构建动态库和构建静态库一样简单。我们看一下例子：</p>
<h2 id="动态库项目"><a href="#动态库项目" class="headerlink" title="动态库项目"></a>动态库项目</h2><p>延用静态库的例子，我们只需要把 <code>CMakeLists.txt</code> 修改一下即可。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(abs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(abs SHARED abs.cpp)</span><br></pre></td></tr></table></figure>
<p>构造的结果会产生一个 <code>libabs.so</code> 文件。读者可以自行尝试一下。</p>
<p>如果要同时构建静态库和动态库，cmake的写法需要一点技巧：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(abs)</span><br><span class="line"><span class="keyword">add_library</span>(abs SHARED abs.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(abs_static STATIC abs.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(abs_static PROPERTIES OUTPUT_NAME <span class="string">"abs"</span>)</span><br></pre></td></tr></table></figure>
<p>这是因为cmake中不允许target有相同的名字，所以我们需要用不同的名字，同时修改target的输出。</p>
<h1 id="引入库文件"><a href="#引入库文件" class="headerlink" title="引入库文件"></a>引入库文件</h1><h2 id="引入子模块"><a href="#引入子模块" class="headerlink" title="引入子模块"></a>引入子模块</h2><p>使用 <code>add_subdirectory</code> 函数，可以把子文件夹中的 <code>CMakeLists.txt</code> 引入到当前<br><code>CMakeLists.txt</code> 中。</p>
<p>举个例子：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(helloworld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(./ ./hello ./world)<span class="comment">#添加多目录的路径</span></span><br><span class="line"><span class="comment"># Add block directories</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(hello)<span class="comment">#添加hello文件夹中的hello库</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(world)<span class="comment">#添加world文件夹中的world库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(helloworld main.cpp)</span><br><span class="line"><span class="comment">#将多目录下的hello库和world库链接上可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(helloworld hello world)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>add_subdirectory</code> 会把对应文件夹中的 <code>CMakeLists.txt</code> 引入进来，包括内部的<br>target。这里假定了 <code>hello</code> 文件夹的target是 <code>hello</code> ， 这里假定了 <code>world</code> 文件<br>夹的target是 <code>world</code> 。</li>
<li><code>target_link_libraries</code> 用来对 <code>helloworld</code> 这个target进行更多的描述：描述这个<br>target完成过程中，需要对 <code>hello</code> 以及 <code>world</code> 两个target进行链接（这两个target<br>必须是库）</li>
</ul>
<p>完整的目录结构：<br><img src="/images/cmake-tutorial/multi-cmake.png" alt="多目录CMake结构"></p>
<h2 id="引入第三方库"><a href="#引入第三方库" class="headerlink" title="引入第三方库"></a>引入第三方库</h2><p>由于大量开源模块都是使用cmake进行构建的，因此存在大量的开源脚本方便你快速把第三<br>方库引入到你的项目里。</p>
<p>我们这里以引入opencv为例。</p>
<p>编写一个使用opencv的程序， <code>hello_cv.cpp</code> 。</p>
<ul>
<li>复制官方文档的代码：<br><a href="https://docs.opencv.org/3.2.0/d0/d2a/contours2_8cpp-example.html">https://docs.opencv.org/3.2.0/d0/d2a/contours2_8cpp-example.html</a></li>
</ul>
<p>想要让这个程序运行起来，有以下几个条件：</p>
<ul>
<li>本地需要安装opencv开发环境。使用命令 <code>sudo apt-get install libopencv-dev</code></li>
<li>检测opencv是否安装成功 <code>dpkg -L libopencv-dev</code> 。这个命令会显示上面安装的包里<br>的文件都被安装到什么位置了。在我的系统里，文件主要被安装在 <code>/usr/bin</code> ,<br><code>/usr/include</code> , <code>/usr/lib/x86_64-linux-gnu</code>, <code>/usr/share/OpenCV</code> 这几个文件夹<br>中。</li>
</ul>
<p>接着，我们创建cmake配置文件：</p>
<ul>
<li>告诉cmake去那里找头文件，显然是要在 <code>/usr/include</code> 里找</li>
<li>告诉cmake去那里找库文件，显然是要在 <code>/usr/lib/x86_64-linux-gnu</code> 里找</li>
<li>告诉cmake应该链接哪些库文件，显然是 <code>libopencv_core.so</code> 、<br><code>libopencv_highgui.so</code> 和 <code>libopencv_imgproc.so</code> </li>
</ul>
<p>于是我们的 <code>CMakeLists.txt</code> 如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定查找头文件的目录                                                                                                                                 </span></span><br><span class="line"><span class="keyword">include_directories</span>(/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 指定查找库文件的目录                                                                                                                                 </span></span><br><span class="line"><span class="keyword">link_directories</span>(/usr/lib/x86_64-linux)</span><br><span class="line"><span class="comment"># 指定项目的target，产生一个二进制                                                                                                                     </span></span><br><span class="line"><span class="keyword">add_executable</span>(hellocv hello_cv.cpp)</span><br><span class="line"><span class="comment"># 指定链接库，优先链接动态库                                                                                                                           </span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hellocv opencv_core opencv_highgui opencv_imgproc)</span><br></pre></td></tr></table></figure>

<p>最后得到的结果：<br><img src="/images/cmake-tutorial/opencv.png" alt="opencv编译"></p>
<p>运行结果：<br><img src="/images/cmake-tutorial/opencv-demo.png" alt="opencv demo"></p>
<h2 id="使用find-package"><a href="#使用find-package" class="headerlink" title="使用find_package"></a>使用find_package</h2><p>引入opencv非常容易，但有一个新问题。不同的平台上，opencv的安装地址可能不一样。如<br>何才能更加通用的探测各个平台的opencv，并正确的链接呢？</p>
<p>cmake为了解决这个问题，要求所有兼容cmake的包，都编写对应的cmake模块。比如opencv<br>包安装文件，就包含了对应的cmake模块：<br><img src="/images/cmake-tutorial/opencv-cmake-s.png" alt="opencv cmake"></p>
<p>这里的.cmake文件被安装到 <code>/usr/share</code> 文件夹下。这个是cmake会搜索模块的路径之一。</p>
<ul>
<li>具体参见：<a href="https://cmake.org/cmake/help/v3.0/command/find_package.html">https://cmake.org/cmake/help/v3.0/command/find_package.html</a></li>
</ul>
<p>因此，我们只需要很简单的修改我们的cmake文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 OpenCVConfig.cmake 里面的注释，可以知道用法：</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定二进制和链接库</span></span><br><span class="line"><span class="keyword">add_executable</span>(hellocv hello_cv.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hellocv <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样即保证了跨平台，又很简单。赶快试一下吧！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">crackhopper</p>
  <div class="site-description" itemprop="description">一个做算法的技术宅</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crackhopper</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'CgYmCkO7FRljeD1Y1MRPlOnN-gzGzoHsz',
      appKey: 'Dufr6C96FrKMfcvai8LqRTNt',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
