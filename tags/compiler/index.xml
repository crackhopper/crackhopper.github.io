<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Compiler on crackhopper的技术博客</title><link>https://crackhopper.github.io/tags/compiler/</link><description>Recent content in Compiler on crackhopper的技术博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>crackhopper@gmail.com (crackhopper)</managingEditor><webMaster>crackhopper@gmail.com (crackhopper)</webMaster><lastBuildDate>Sun, 14 Jun 2020 21:49:51 +0800</lastBuildDate><atom:link href="https://crackhopper.github.io/tags/compiler/index.xml" rel="self" type="application/rss+xml"/><item><title>小白学写编译器：1.编译基础概念</title><link>https://crackhopper.github.io/notes/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A81.%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link><pubDate>Sun, 14 Jun 2020 21:49:51 +0800</pubDate><author>crackhopper@gmail.com (crackhopper)</author><guid>https://crackhopper.github.io/notes/%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A81.%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid><description>&lt;h1 id="机器指令"&gt;机器指令
&lt;/h1&gt;&lt;p&gt;我们知道CPU是计算机的大脑，也知道计算机只认识由0和1组成的二进制码，比如&amp;quot;1001010110101010&amp;quot; 这样的。具体来说，当计算机的CPU遇到一个这样的二进制码时，会做出相应的动作：读取内存、写入内存、执行加法、执行乘法、向其他设备发送IO指令(读取键盘、写入显示器)等等。每个CPU都有自己所识别的二进制码，我们称之为 &lt;strong&gt;机器指令&lt;/strong&gt; (machine code) 。将一系列机器指令组合成一个集合，那么计算机就可以完成很多复杂的计算和行为，这种机器指令的集合，我们称呼为 &lt;strong&gt;程序&lt;/strong&gt; (program)。当计算机运行一个程序的时候，我们会说计算机正在执行一个 &lt;strong&gt;任务&lt;/strong&gt; (task) 或 &lt;strong&gt;进程&lt;/strong&gt; (process) 。&lt;/p&gt;
&lt;p&gt;最早的程序员是使用机器语言编写程序的。比如早期的大家用纸带编写程序，通过对纸带上是否打孔来区分是0还是1，从而识别出机器指令，让CPU执行计算。而如今随着技术的发展，开发程序的工作即被便利化也被复杂化了。大家不再使用二进制开发程序，而是使用编程语言(programming language)。&lt;/p&gt;
&lt;p&gt;机器指令插图&lt;/p&gt;
&lt;h1 id="编程语言和编译器"&gt;编程语言和编译器
&lt;/h1&gt;&lt;p&gt;二进制代码太难以记忆，并且编写的程序很难阅读。因此人们首先开发了叫做 &lt;strong&gt;汇编&lt;/strong&gt; (assembly) 的 &lt;strong&gt;编程语言&lt;/strong&gt; (programming language)，用英文字母来代替机器指令。汇编语言是比机器指令更容易理解的指令集，也更容易开发程序。但英文字母并不能被CPU理解，因此需要由 &lt;strong&gt;汇编器&lt;/strong&gt; (assembler) 把汇编代码翻译成机器指令。&lt;/p&gt;
&lt;p&gt;后来人们发现这种方式非常有效果。因此发明了更多好用的编程语言，也更加接近自然语言的表达方式，比如Fortran，Lisp，C语言等等。由编程语言编写的代码称为 &lt;strong&gt;源代码&lt;/strong&gt; (source code) ，机器指令的集合称为 &lt;strong&gt;目标代码&lt;/strong&gt; (object code) 。而把源代码翻译成目标代码的工具，称为 &lt;strong&gt;编译器&lt;/strong&gt; (compiler)&lt;/p&gt;
&lt;p&gt;编译器的图示&lt;/p&gt;
&lt;p&gt;编译器本身是一个非常复杂的程序。而开发编译器也是一个非常复杂的工程。编译器的作用是生产程序，而编译器本身也是程序。因此编译器也是由编程语言开发的。那么困惑的点来了，如果编译器是由编程语言开发的，那么编译器的源代码由谁来翻译？实际上，第一版编译器是由机器指令开发的，实现了简单的汇编语言；随后用汇编语言再次开发了最初版本的C语言；随后由C语言本身开发C语言的编译器。当一个语言可以用自己开发自己的编译器，这种语言我们说它实现了 &lt;strong&gt;自举&lt;/strong&gt; (bootstrap)。和编译器工程特别相似的就是机械领域的大部分机床，第一代机床都是手工制作的；随后各代机床利用前代机床生产的零件，提升自己的性能。大部分发达国家的技术垄断都是这种需要多轮迭代的技术。&lt;/p&gt;
&lt;p&gt;和编译器相似的一个概念叫做 &lt;strong&gt;解释器(interpreter)&lt;/strong&gt; 。解释器并不会产生目标程序，而是直接将源代码一句一句的转化为机器指令进行执行。&lt;/p&gt;
&lt;p&gt;解释器的图示&lt;/p&gt;
&lt;p&gt;举两个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C语言由它的编译器——gcc进行编译，生成机器二进制码组成的程序，由CPU直接执行。类似C语言这种编译生成由CPU直接执行的机器指令的语言，我们叫做 &lt;strong&gt;编译型语言&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;javascript语言由它的解释器——浏览器进行解释执行。javascript语言并不会生成程序，真正被CPU执行的程序仍然是浏览器。而浏览器将javascript代码动态的转化为机器指令。这种由其他程序(解释器)作为宿主，解释执行的语言，我们叫做 &lt;strong&gt;解释型语言&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，很多现代的编程语言可以说是编译型和解释型相混合的。典型的例子就是java。java会把源代码翻译成一种叫中间代码的文件(.class文件)，中间代码并不能被CPU理解，但是可以被一个叫做JVM的程序理解并执行。可以看到下图中，java的编译器既包含编译器也包含解释器。这里面的解释器有另一个名字，叫做 &lt;strong&gt;虚拟机&lt;/strong&gt; (Virtual Machine)，因为它像一个虚拟的机器一样。&lt;/p&gt;
&lt;p&gt;java编译器的图示。&lt;/p&gt;
&lt;p&gt;也许有人会说java最终是被解释执行的。但其实在java中也引入了一个叫JIT(Just In Time Compiler)的技术，这个技术会将高频使用的中间代码在运行时动态地编译成机器代码。在这样的情况下，就更难说java是编译型还是解释型了。&lt;/p&gt;
&lt;h1 id="编译器的构造"&gt;编译器的构造
&lt;/h1&gt;&lt;p&gt;接下来，我们较为浅显的看一下编译器的构造。&lt;/p&gt;
&lt;h2 id="宏观视角"&gt;宏观视角
&lt;/h2&gt;&lt;p&gt;从简单粗暴的方式来看，编译器主要是两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析部分：分析源代码，形成一个中间结构（中间代码）&lt;/li&gt;
&lt;li&gt;综合部分：从中间结构，翻译成目标代码（机器代码）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，分析部分也叫做编译器前端(front end)，综合部分也叫做编译器后端(back end)。&lt;/p&gt;
&lt;p&gt;宏观视角图&lt;/p&gt;
&lt;h2 id="微观视角"&gt;微观视角
&lt;/h2&gt;&lt;p&gt;如果更加细节的看编译器的构造，可以分为以下部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析：将源代码转化为token序列 (类似于把一篇文章，按照单词拆分开)&lt;/li&gt;
&lt;li&gt;语法分析：将token序列组织成语法树 (类似于把单词，按照语法组合成句子)&lt;/li&gt;
&lt;li&gt;语义分析：验证语法树上的元素，做一些转换 (类似于把句子的语法格式标准化)&lt;/li&gt;
&lt;li&gt;中间代码生成器：将语法树转化为 某种更基础格式的代码序列 (类似于把一个标准化的中文句子翻译成标准化的英文句子)&lt;/li&gt;
&lt;li&gt;机器无关代码优化：对中间代码优化（类似于将英文句子写的更加优美）&lt;/li&gt;
&lt;li&gt;代码生成器：把中间代码转化为目标代码 (类似于将英文句子转化为某种方言下的英文，比如美式英文)&lt;/li&gt;
&lt;li&gt;机器相关代码优化：对目标代码优化（类似与对美式英文的文章进行润色）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;微观视角图&lt;/p&gt;
&lt;h2 id="一个例子"&gt;一个例子
&lt;/h2&gt;&lt;p&gt;我们举一个龙书上的例子，考虑下面的语句&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;position &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; initial&lt;span style="color:#0550ae"&gt;+&lt;/span&gt;rate&lt;span style="color:#0550ae"&gt;*&lt;/span&gt;&lt;span style="color:#0550ae"&gt;60&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://crackhopper.github.io/images/let-us-write-compiler/compile.png"
loading="lazy"
alt="compile"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析：将代码中的代词分离成一个个token。其中id代表标识符(identifier)。每个标识符被存入到对应的符号表中。词法分析输出了token序列。&lt;/li&gt;
&lt;li&gt;语法分析：把token按照结构组织起来。先做乘法再做加法，最终进行赋值。语法分析的主要结果就是形成了语法树(syntax tree)。&lt;/li&gt;
&lt;li&gt;语义分析：假设rate是浮点类型，60是整数类型，由于他们在内存中表达形式不一样，无法直接做乘法运算。于是语义分析中，将60转化为了浮点类型。语义分析主要就是校验语法树。&lt;/li&gt;
&lt;li&gt;中间代码生成：我们将语句转化为更接近机器能理解的语句。常用的一种格式叫做三地址代码 (three-address code) 。即一个语句中最多有三个变量。&lt;/li&gt;
&lt;li&gt;代码优化器：对代码进行化简，让代码数量变得更少。&lt;/li&gt;
&lt;li&gt;代码生成器：形成机器代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="将多个步骤组合成趟pass"&gt;将多个步骤组合成趟(pass)
&lt;/h2&gt;&lt;p&gt;之前我们对编译器的拆解是逻辑拆解。在实际实现的时候，多个逻辑步骤会组合到一起，形成一个 &lt;strong&gt;趟&lt;/strong&gt; (pass/phrase) 。每趟读入一个输入文件并产生一个输出文件。比如前端步骤中的词法、语法、语义以及中间代码生成可以组合成一趟；代码优化可以单独组合成一趟。&lt;/p&gt;
&lt;h1 id="总结"&gt;总结
&lt;/h1&gt;&lt;p&gt;我们浅显地讲解了程序的概念，程序是由机器指令构成的集合。讲解了程序是如何制作的，程序是编译器将源代码编译成目标代码，从而制作出来的。&lt;/p&gt;
&lt;p&gt;进一步的，我们探索了编译器的构造。了解了编译器的前端的组成部分：词法分析、语法分析、语义分析和中间代码生成；编译器后端的组成部分：机器无关代码优化，机器相关代码优化，生成目标代码。此外，将一系列步骤组合到一起，从一个输入文件产生一个输出文件的过程叫做趟。&lt;/p&gt;
&lt;p&gt;后续，我们将从编译器的构造一步一步展开讨论。下一节我们讨论的是词法分析。&lt;/p&gt;</description></item></channel></rss>