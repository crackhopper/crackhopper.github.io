<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Windbg on crackhopper的技术博客</title><link>https://crackhopper.github.io/tags/windbg/</link><description>Recent content in Windbg on crackhopper的技术博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>crackhopper@gmail.com (crackhopper)</managingEditor><webMaster>crackhopper@gmail.com (crackhopper)</webMaster><lastBuildDate>Fri, 21 Nov 2025 12:53:06 +0800</lastBuildDate><atom:link href="https://crackhopper.github.io/tags/windbg/index.xml" rel="self" type="application/rss+xml"/><item><title>Vulkan程序中Intel驱动总是被调用</title><link>https://crackhopper.github.io/2025/11/21/vulkan%E7%A8%8B%E5%BA%8F%E4%B8%ADintel%E9%A9%B1%E5%8A%A8%E6%80%BB%E6%98%AF%E8%A2%AB%E8%B0%83%E7%94%A8/</link><pubDate>Fri, 21 Nov 2025 12:53:06 +0800</pubDate><author>crackhopper@gmail.com (crackhopper)</author><guid>https://crackhopper.github.io/2025/11/21/vulkan%E7%A8%8B%E5%BA%8F%E4%B8%ADintel%E9%A9%B1%E5%8A%A8%E6%80%BB%E6%98%AF%E8%A2%AB%E8%B0%83%E7%94%A8/</guid><description>&lt;p&gt;这篇文章是闲暇时候的探索，并没有真正解决问题。&lt;/p&gt;
&lt;h2 id="正文开始"&gt;正文开始
&lt;/h2&gt;&lt;p&gt;之前调试神秘日志的时候，打印堆栈和文件操作，发现有大量intel驱动程序的调用，并且打开了特别多的文件。不知道为什么。&lt;/p&gt;
&lt;p&gt;我们这次也深入研究一下。先手动在程序中设定环境变量： （环境变量设定笔记：TODO ）&lt;/p&gt;
&lt;p&gt;这里罗列一下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 5
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 6
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 7
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 8
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 9
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;10
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;11
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;12
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;13
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#include&lt;/span&gt; &lt;span style="color:#57606a"&gt;&amp;#34;utils.h&amp;#34;&lt;/span&gt;&lt;span style="color:#57606a"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#ifdef _WIN32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#include&lt;/span&gt; &lt;span style="color:#57606a"&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;span style="color:#57606a"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#include&lt;/span&gt; &lt;span style="color:#57606a"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style="color:#57606a"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;void&lt;/span&gt; &lt;span style="color:#6639ba"&gt;expSetEnvVK&lt;/span&gt;&lt;span style="color:#1f2328"&gt;()&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#ifdef _WIN32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; SetEnvironmentVariableW&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#0a3069"&gt;L&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;VK_LOADER_LAYERS_DISABLE&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0a3069"&gt;L&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;~implicit~&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; setenv&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;VK_LOADER_LAYERS_DISABLE&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;~implicit~&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0550ae"&gt;1&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;检查环境变量是否设定成功，等程序完成该函数的调用后，执行下面命令查看进程环境变量：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;!peb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过，即使设定了环境变量，我们断点&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;bp KERNELBASE!CreateFileW &amp;#34;r rcx; du @rcx; k L3; g&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;日志目前不产生了。但是，仍然会有大量的打开文件操作。&lt;/p&gt;
&lt;p&gt;从堆栈可以看出：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;[0x0] igvk64!ctlTemperatureGetState+0x73ea6a 0xcb4b753750 0x7ff9329718a0
[0x1] igvk64!ctlTemperatureGetState+0x73c020 0xcb4b753b40 0x7ff93296ecfb
[0x2] igvk64!ctlTemperatureGetState+0x73947b 0xcb4b753ce0 0x7ff93296e00b
[0x3] igvk64!ctlTemperatureGetState+0x73878b 0xcb4b753d20 0x7ff932964276
[0x4] igvk64!ctlTemperatureGetState+0x72e9f6 0xcb4b753d70 0x7ff93211040f
[0x5] igvk64!DumpRegistryKeyDefinitions+0x1c605f 0xcb4b753ee0 0x7ff9321007fb
[0x6] igvk64!DumpRegistryKeyDefinitions+0x1b644b 0xcb4b7544e0 0x7ff9320e76a4
[0x7] igvk64!DumpRegistryKeyDefinitions+0x19d2f4 0xcb4b754650 0x7ff9320d1bd5
[0x8] igvk64!DumpRegistryKeyDefinitions+0x187825 0xcb4b754700 0x7ff9320431e6
[0x9] igvk64!DumpRegistryKeyDefinitions+0xf8e36 0xcb4b754750 0x7ff932027534
[0xa] igvk64!DumpRegistryKeyDefinitions+0xdd184 0xcb4b76b960 0x7ff931ffec7d
[0xb] igvk64!DumpRegistryKeyDefinitions+0xb48cd 0xcb4b76b9d0 0x7ff931f80ca5
[0xc] igvk64!DumpRegistryKeyDefinitions+0x368f5 0xcb4b76ba20 0x7ff9378dc6dc
[0xd] vulkan_1!vkResetEvent+0x4b14c 0xcb4b76baf0 0x7ff9378c3652
[0xe] vulkan_1!vkResetEvent+0x320c2 0xcb4b76bc50 0x7ff9378e751e
[0xf] vulkan_1!vkResetEvent+0x55f8e 0xcb4b76be40 0x7ff630566b2f
[0x10] VulkanGLFWDemo+0x6b2f 0xcb4b76f250 0x7ff630567e80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为是release外加关闭了implicit layers。所以没有任何validation layers干扰。但是，vulkan还是会产生大量 igvk64模块的调用。&lt;/p&gt;
&lt;h2 id="ai解释"&gt;AI解释
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;igvk64&lt;/code&gt; 很可能是 Intel 的 Vulkan ICD / 驱动相关模块（或 Intel GPU 的 Vulkan 支持库/监控库）。Vulkan loader 在进程初始化 / 创建实例时会把系统里注册的所有 ICD（以及某些层）都载入并初始化——因此即便你最后用的是 NVIDIA 的物理设备，Intel 的 ICD 也可能会被加载并执行初始化代码（查询注册表、查询温度/设备信息、打开设备/日志文件等），这就会看到大量 &lt;code&gt;CreateFileW&lt;/code&gt; / 注册表读取 等操作，堆栈里就会出现 &lt;code&gt;igvk64&lt;/code&gt; 的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于ICD机制，更多参见：&lt;/strong&gt; &lt;a class="link" href="https://crackhopper.github.io/notes/vulkan%E7%9A%84icd%E6%9C%BA%E5%88%B6/" &gt;Vulkan的ICD机制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="手动加载icd后"&gt;手动加载ICD后
&lt;/h2&gt;&lt;p&gt;新增环境变量设定：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;VK_DRIVER_FILES=C:\WINDOWS\System32\DriverStore\FileRepository\nvmi.inf_amd64_c6ae241e95feb82d\nv-vk64.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 5
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 6
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 7
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 8
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt; 9
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;10
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;11
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;12
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;13
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;14
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;15
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;16
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;17
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;18
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;19
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;20
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;21
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#include&lt;/span&gt; &lt;span style="color:#57606a"&gt;&amp;#34;utils.h&amp;#34;&lt;/span&gt;&lt;span style="color:#57606a"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#ifdef _WIN32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#include&lt;/span&gt; &lt;span style="color:#57606a"&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;span style="color:#57606a"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#include&lt;/span&gt; &lt;span style="color:#57606a"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style="color:#57606a"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;void&lt;/span&gt; &lt;span style="color:#6639ba"&gt;expSetEnvVK&lt;/span&gt;&lt;span style="color:#1f2328"&gt;()&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#ifdef _WIN32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; SetEnvironmentVariableW&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#0a3069"&gt;L&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;VK_DRIVER_FILES&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; LR&lt;span style="color:#0a3069"&gt;&amp;#34;(C:\WINDOWS\System32\DriverStore\FileRepository&lt;/span&gt;&lt;span style="color:#0a3069"&gt;\n&lt;/span&gt;&lt;span style="color:#0a3069"&gt;vmi.inf_amd64_c6ae241e95feb82d&lt;/span&gt;&lt;span style="color:#0a3069"&gt;\n&lt;/span&gt;&lt;span style="color:#0a3069"&gt;v-vk64.json)&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; SetEnvironmentVariableW&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#0a3069"&gt;L&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;VK_LOADER_LAYERS_DISABLE&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0a3069"&gt;L&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;~implicit~&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; setenv&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;VK_DRIVER_FILES&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; R&lt;span style="color:#0a3069"&gt;&amp;#34;(C:\WINDOWS\System32\DriverStore\FileRepository&lt;/span&gt;&lt;span style="color:#0a3069"&gt;\n&lt;/span&gt;&lt;span style="color:#0a3069"&gt;vmi.inf_amd64_c6ae241e95feb82d&lt;/span&gt;&lt;span style="color:#0a3069"&gt;\n&lt;/span&gt;&lt;span style="color:#0a3069"&gt;v-vk64.json)&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#0550ae"&gt;1&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; setenv&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;VK_LOADER_LAYERS_DISABLE&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;~implicit~&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0550ae"&gt;1&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;测试结果：设定成功后&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产生大量 nvogl的调用（这个可能符合预期）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;[0x0] KERNEL32!CreateFileW 0xc5662fabc8 0x7ff908effb25
[0x1] nvoglv64!vk_icdNegotiateLoaderICDInterfaceVersion+0xcc8a5 0xc5662fabd0 0x7ff908f00511
[0x2] nvoglv64!vk_icdNegotiateLoaderICDInterfaceVersion+0xcd291 0xc5662fac30 0x7ff90843a853
[0x3] nvoglv64+0xdaa853 0xc5662facb0 0x7ff90843a8b6
[0x4] nvoglv64+0xdaa8b6 0xc5662fafc0 0x7ff90843a8b6
[0x5] nvoglv64+0xdaa8b6 0xc5662fb2d0 0x7ff908439f6a
[0x6] nvoglv64+0xda9f6a 0xc5662fb5e0 0x7ff90843ae26
[0x7] nvoglv64+0xdaae26 0xc5662fb630 0x7ff90843acb9
[0x8] nvoglv64+0xdaacb9 0xc5662fb680 0x7ff90843a6fe
[0x9] nvoglv64+0xdaa6fe 0xc5662fb6d0 0x7ff9084385cb
[0xa] nvoglv64+0xda85cb 0xc5662fb700 0x7ff908dcca46
[0xb] nvoglv64!vkGetInstanceProcAddr+0x94276 0xc5662fb760 0x7ff908dcaf50
[0xc] nvoglv64!vkGetInstanceProcAddr+0x92780 0xc5662fb9e0 0x7ff908dc7e46
[0xd] nvoglv64!vkGetInstanceProcAddr+0x8f676 0xc5662fba30 0x7ff908dc8e4a
[0xe] nvoglv64!vkGetInstanceProcAddr+0x9067a 0xc5662fc1c0 0x7ff908dc7b6c
[0xf] nvoglv64!vkGetInstanceProcAddr+0x8f39c 0xc5662fc200 0x7ff93b99c6dc
[0x10] vulkan_1!vkResetEvent+0x4b14c 0xc5662fc230 0x7ff93b983652
[0x11] vulkan_1!vkResetEvent+0x320c2 0xc5662fc380 0x7ff93b9a751e
[0x12] vulkan_1!vkResetEvent+0x55f8e 0xc5662fc570 0x7ff6972b6b33
[0x13] VulkanGLFWDemo+0x6b33 0xc5662ff980 0x7ff6972b7e80
[0x14] VulkanGLFWDemo+0x7e80 0xc5662ffac0 0x7ff6972b95d4
[0x15] VulkanGLFWDemo+0x95d4 0xc5662ffc30 0x7ff6972ba2bf
[0x16] VulkanGLFWDemo+0xa2bf 0xc5662ffc80 0x7ff6972cb54c
[0x17] VulkanGLFWDemo+0x1b54c 0xc5662ffe70 0x7ffa4389e8d7
[0x18] KERNEL32!BaseThreadInitThunk+0x17 0xc5662ffeb0 0x7ffa4520c53c
[0x19] ntdll!RtlUserThreadStart+0x2c 0xc5662ffee0 0x0
&lt;/code&gt;&lt;/pre&gt;&lt;ol start="2"&gt;
&lt;li&gt;还会产生intel的驱动调用：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;000001b2`2e445620 &amp;#34;C:\Users\develop\AppData\LocalLo&amp;#34;
000001b2`2e445660 &amp;#34;w\Intel\ShaderCache\42c265904c15&amp;#34;
000001b2`2e4456a0 &amp;#34;3bce841ce64ab3cda0f27c76e6b1e7c0&amp;#34;
000001b2`2e4456e0 &amp;#34;efcc9de2f1082fe2a43e&amp;#34;
# Child-SP RetAddr Call Site
00 00000005`274fdb08 00007ffa`0324e16a KERNEL32!CreateFileW
01 00000005`274fdb10 00007ffa`0324b720 igxelpicd64!DumpRegistryKeyDefinitions+0xb43aa
02 00000005`274fdf00 00007ffa`03248cfb igxelpicd64!DumpRegistryKeyDefinitions+0xb1960
03 00000005`274fe0a0 00007ffa`0324800b igxelpicd64!DumpRegistryKeyDefinitions+0xaef3b
04 00000005`274fe0e0 00007ffa`0323be16 igxelpicd64!DumpRegistryKeyDefinitions+0xae24b
05 00000005`274fe130 00007ffa`030fce7c igxelpicd64!DumpRegistryKeyDefinitions+0xa2056
06 00000005`274fe2a0 00007ffa`030fb59e igxelpicd64!DrvValidateVersion+0x13c57c
07 00000005`274fe870 00007ffa`030ee572 igxelpicd64!DrvValidateVersion+0x13ac9e
08 00000005`274fe8b0 00007ffa`02fbf6aa igxelpicd64!DrvValidateVersion+0x12dc72
09 00000005`274fe8f0 00007ffa`2a8aacfe igxelpicd64!DrvDescribePixelFormat+0x3a
0a 00000005`274fe940 00007ffa`2a8ed7e9 opengl32!_DescribeDriverPixelFormat+0x5a
0b 00000005`274fe980 00007ffa`2a886e9f opengl32!LoadAvailableDrivers+0x3d9
0c 00000005`274fefe0 00007ff9`08d2005c opengl32!wglDescribePixelFormat+0xdf
0d 00000005`274ff120 00007ff9`08d23622 nvoglv64!vk_optimusGetInstanceProcAddr+0x230ec
0e 00000005`274ff150 00007ff9`08d1cfd7 nvoglv64!vk_optimusGetInstanceProcAddr+0x266b2
0f 00000005`274ff1a0 00007ff9`3b9ad9cc nvoglv64!vk_optimusGetInstanceProcAddr+0x20067
10 00000005`274ff1d0 00007ff9`3b9af465 vulkan_1!vkResetEvent+0x5c43c
11 00000005`274ff2c0 00007ff6`972b72e2 vulkan_1!vkResetEvent+0x5ded5
12 00000005`274ff300 00007ff6`972b7f29 VulkanGLFWDemo+0x72e2
13 00000005`274ff470 00007ff6`972b95d4 VulkanGLFWDemo+0x7f29
14 00000005`274ff5e0 00007ff6`972ba2bf VulkanGLFWDemo+0x95d4
15 00000005`274ff630 00007ff6`972cb54c VulkanGLFWDemo+0xa2bf
16 00000005`274ff820 00007ffa`4389e8d7 VulkanGLFWDemo+0x1b54c
17 00000005`274ff860 00007ffa`4520c53c KERNEL32!BaseThreadInitThunk+0x17
18 00000005`274ff890 00000000`00000000 ntdll!RtlUserThreadStart+0x2c
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="ai的解释"&gt;AI的解释
&lt;/h2&gt;&lt;h3 id="1-nvidia-optimusamd-switchable-graphics"&gt;1. NVIDIA Optimus/AMD Switchable Graphics
&lt;/h3&gt;&lt;p&gt;您运行的系统几乎肯定是一个拥有&lt;strong&gt;集成显卡 (Intel)&lt;/strong&gt; 和 &lt;strong&gt;独立显卡 (NVIDIA)&lt;/strong&gt; 的笔记本电脑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;集成显卡 (Intel iGPU):&lt;/strong&gt; 通常直接连接到显示器，负责低功耗下的桌面显示和简单图形渲染。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;独立显卡 (NVIDIA dGPU):&lt;/strong&gt; 负责高性能渲染。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Optimus 的工作机制：&lt;/strong&gt; NVIDIA 的 Optimus 技术允许应用程序启动时默认使用低功耗的 &lt;strong&gt;Intel iGPU&lt;/strong&gt;。如果应用程序需要高性能（例如，一个 3D 游戏或 Vulkan/OpenGL 程序），NVIDIA 的驱动程序会&lt;strong&gt;拦截&lt;/strong&gt;图形 API 调用，并将渲染工作交给 &lt;strong&gt;NVIDIA dGPU&lt;/strong&gt; 完成。&lt;strong&gt;渲染完成后，dGPU 将结果帧通过 PCIe/内部总线复制回 iGPU 的帧缓冲区，再由 iGPU 将画面输出到显示器。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="2-openglwgl-路径依赖-"&gt;2. OpenGL/WGL 路径依赖 ⚠️
&lt;/h3&gt;&lt;p&gt;您的堆栈跟踪（Stack Trace）清晰地显示了调用链经过了 &lt;strong&gt;OpenGL/WGL&lt;/strong&gt; 的函数：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;09 00000005`274fe8f0 00007ffa`2a8aacfe igxelpicd64!DrvDescribePixelFormat+0x3a
0a 00000005`274fe940 00007ffa`2a8ed7e9 opengl32!_DescribeDriverPixelFormat+0x5a
0b 00000005`274fe980 00007ffa`2a886e9f opengl32!LoadAvailableDrivers+0x3d9
0c 00000005`274fefe0 00007ff9`08d2005c opengl32!wglDescribePixelFormat+0xdf
0d 00000005`274ff120 00007ff9`08d23622 nvoglv64!vk_optimusGetInstanceProcAddr+0x230ec
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然您在使用 Vulkan (&lt;code&gt;vulkan_1.dll&lt;/code&gt;), 但您的程序可能使用了像 &lt;strong&gt;GLFW&lt;/strong&gt; 或类似的跨平台窗口库来创建窗口表面。&lt;/li&gt;
&lt;li&gt;在 Windows 上，这些库在创建窗口或进行必要的初始化时，往往会调用 &lt;strong&gt;OpenGL/WGL&lt;/strong&gt; 相关的函数（例如 &lt;code&gt;wglDescribePixelFormat&lt;/code&gt;），即使目标是 Vulkan。&lt;/li&gt;
&lt;li&gt;在 Optimus 系统上，这个 &lt;strong&gt;WGL 调用&lt;/strong&gt; 默认被路由到 &lt;strong&gt;Intel iGPU 的驱动程序 (&lt;code&gt;igxelpicd64.dll&lt;/code&gt;)&lt;/strong&gt;，因为它是实际连接到显示器的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;igxelpicd64&lt;/code&gt; 正在尝试访问 &lt;strong&gt;Intel 的 Shader Cache&lt;/strong&gt; 路径 (&lt;code&gt;C:\Users\develop\AppData\LocalLow\Intel\ShaderCache\..&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-vulkan-实例和物理设备分离"&gt;3. Vulkan 实例和物理设备分离
&lt;/h3&gt;&lt;p&gt;您手动设置 &lt;code&gt;VK_DRIVER_FILES&lt;/code&gt; 只影响了 Vulkan &lt;strong&gt;实例 (Instance)&lt;/strong&gt; 的创建过程，确保 NVIDIA 的 ICD 驱动程序被加载。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;vkCreateInstance&lt;/code&gt; 成功：&lt;/strong&gt; NVIDIA 驱动（&lt;code&gt;nvoglv64.dll&lt;/code&gt;）被成功加载并初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;后续步骤：&lt;/strong&gt; 即使 NVIDIA 驱动被加载，当程序调用 &lt;code&gt;vkEnumeratePhysicalDevices&lt;/code&gt; 时，它会发现 &lt;strong&gt;系统上的所有 Vulkan 兼容设备&lt;/strong&gt;，包括 Intel iGPU 和 NVIDIA dGPU。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Optimus 干预：&lt;/strong&gt; 如上所述，在窗口和上下文的初始化过程中，&lt;strong&gt;OpenGL/WGL&lt;/strong&gt; 的初始化路径（即使不是最终的 Vulkan 渲染路径）依然可能被 Intel 驱动程序介入，因为它管理着显示输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="解决方案"&gt;解决方案
&lt;/h3&gt;&lt;p&gt;在您的代码中添加一个全局导出变量，告诉 NVIDIA 驱动程序，您的程序是一个高性能应用，应该使用 dGPU。&lt;/p&gt;
&lt;p&gt;在您的任何 .cpp 文件（最好是 main 所在的源文件）的全局作用域内添加以下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;5
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;6
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;7
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;8
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;// 告诉 NVIDIA 驱动程序使用独立显卡 (dGPU)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;&lt;span style="color:#cf222e"&gt;extern&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;C&amp;#34;&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;__declspec&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;dllexport&lt;span style="color:#1f2328"&gt;)&lt;/span&gt; DWORD NvOptimusEnablement &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; &lt;span style="color:#0550ae"&gt;0x00000001&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;// 告诉 AMD 驱动程序使用独立显卡 (dGPU) (可选)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;&lt;span style="color:#cf222e"&gt;extern&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;C&amp;#34;&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;__declspec&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;dllexport&lt;span style="color:#1f2328"&gt;)&lt;/span&gt; &lt;span style="color:#cf222e"&gt;int&lt;/span&gt; AmdPowerXpressRequestHighPerformance &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; &lt;span style="color:#0550ae"&gt;1&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="添加高性能标记后"&gt;添加高性能标记后
&lt;/h2&gt;&lt;p&gt;还是有大量intel驱动的调用：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;00000154`764574e0 &amp;#34;C:\Users\develop\AppData\LocalLo&amp;#34;
00000154`76457520 &amp;#34;w\Intel\ShaderCache\5f11c2592227&amp;#34;
00000154`76457560 &amp;#34;90422146768d167662e6e467ee38e871&amp;#34;
00000154`764575a0 &amp;#34;11911336f4e1aec31b96&amp;#34;
# Child-SP RetAddr Call Site
00 0000000c`adafa1e8 00007ffa`35b172ea KERNEL32!CreateFileW
01 0000000c`adafa1f0 00007ffa`35b148a0 igd10um64xe!OpenAdapter10_2+0x6935a
02 0000000c`adafa5e0 00007ffa`35b11d8b igd10um64xe!OpenAdapter10_2+0x66910
03 0000000c`adafa780 00007ffa`35b1109b igd10um64xe!OpenAdapter10_2+0x63dfb
04 0000000c`adafa7c0 00007ffa`35b07f56 igd10um64xe!OpenAdapter10_2+0x6310b
05 0000000c`adafa810 00007ffa`35a5874a igd10um64xe!OpenAdapter10_2+0x59fc6
06 0000000c`adafa980 00007ffa`35a976d3 igd10um64xe!ctlInit+0x1d8a
07 0000000c`adafb040 00007ffa`35a9747f igd10um64xe!ctlInit+0x40d13
08 0000000c`adafb0c0 00007ffa`3f94d011 igd10um64xe!ctlInit+0x40abf
09 0000000c`adafb0f0 00007ffa`3f94b512 d3d11!NDXGI::CDevice::CreateDriverInstance+0x271
0a 0000000c`adafb210 00007ffa`3f94af26 d3d11!CDevice::CreateDriverInstance+0xa2
0b 0000000c`adafb280 00007ffa`3f95d01b d3d11!CContext::LUCCompleteLayerConstruction+0xc2
0c 0000000c`adafb3a0 00007ffa`3f95d602 d3d11!NOutermost::CDeviceChild::LUCCompleteLayerConstruction+0x5b
0d 0000000c`adafb400 00007ffa`3f95d1f6 d3d11!CUseCountedObject&amp;lt;NOutermost::CDeviceChild&amp;gt;::CUseCountedObject&amp;lt;NOutermost::CDeviceChild&amp;gt;+0x2a2
0e 0000000c`adafb490 00007ffa`3f9da7db d3d11!NOutermost::CDevice::CreateLayeredChild+0x166
0f 0000000c`adafb5b0 00007ffa`3f94c72b d3d11!CDevice::LLOCompleteLayerConstruction+0xafb
10 0000000c`adafbcb0 00007ffa`3f94fe14 d3d11!NDXGI::CDevice::LLOCompleteLayerConstruction+0xdf
11 0000000c`adafbf80 00007ffa`3f94ff1a d3d11!NOutermost::CDevice::LLOCompleteLayerConstruction+0x14
12 0000000c`adafbfb0 00007ffa`3f94c561 d3d11!TComObject&amp;lt;NOutermost::CDevice&amp;gt;::TComObject&amp;lt;NOutermost::CDevice&amp;gt;+0xf6
13 0000000c`adafc020 00007ffa`3f94e8bb d3d11!D3D11CreateLayeredDevice+0x231
14 0000000c`adafc120 00007ffa`3f94f2b7 d3d11!D3D11CoreCreateLayeredDevice+0x11b
15 0000000c`adafc1f0 00007ffa`3f94dabf d3d11!D3D11RegisterLayersAndCreateDevice+0x57f
16 0000000c`adafc350 00007ffa`3f9bb073 d3d11!D3D11CoreCreateDevice+0x40f
17 0000000c`adafc670 00007ffa`3f9c22fe d3d11!D3D11CreateDeviceAndSwapChainImpl+0x2a3
18 0000000c`adafc8e0 00007ffa`3f9c224c d3d11!D3D11CreateDeviceAndSwapChain+0x9e
19 0000000c`adafc960 00007ffa`3f9c3b36 d3d11!D3D11CreateDeviceImpl+0x5c
1a 0000000c`adafc9d0 00007ffa`3f9d764b d3d11!D3D11CreateDevice+0x86
1b 0000000c`adafca40 00007ffa`3fbf4692 d3d11!NDXGI::CDevice::EnsureChildDevice+0xdb
1c 0000000c`adafcad0 00007ffa`3fbbf76d dxgi!CDXGISwapChain::EnsureChildDeviceInternal+0x6a
1d 0000000c`adafcda0 00007ffa`3fbc05a2 dxgi!CDXGISwapChain::PrepareWindowedBltPresent+0x72d
1e 0000000c`adafcec0 00007ffa`3fbb3674 dxgi!CDXGISwapChain::PresentImplCore+0x502
1f 0000000c`adafd870 00007ffa`3fbb2e1a dxgi!CDXGISwapChain::PresentImpl+0x104
20 0000000c`adafd940 00007ff9`089965d3 dxgi!CDXGISwapChain::Present+0x17a
21 0000000c`adafdad0 00007ff9`089ca824 nvoglv64!DrvPresentBuffers+0x3553
22 0000000c`adafdb70 00007ff9`089a83f4 nvoglv64!DrvPresentBuffers+0x377a4
23 0000000c`adafde80 00007ff9`089cbef9 nvoglv64!DrvPresentBuffers+0x15374
24 0000000c`adafe390 00007ff9`08acb4ab nvoglv64!DrvPresentBuffers+0x38e79
25 0000000c`adafe650 00007ff9`08ad807c nvoglv64!DrvPresentBuffers+0x13842b
26 0000000c`adafe6f0 00007ff9`08aeeb75 nvoglv64!DrvPresentBuffers+0x144ffc
27 0000000c`adafe8b0 00007ff9`08964906 nvoglv64!DrvPresentBuffers+0x15baf5
28 0000000c`adafe990 00007ff9`08ab3bd1 nvoglv64!DrvValidateVersion+0x6db6
29 0000000c`adafe9e0 00007ff9`08a906cc nvoglv64!DrvPresentBuffers+0x120b51
2a 0000000c`adaff270 00007ff9`08a8fb12 nvoglv64!DrvPresentBuffers+0xfd64c
2b 0000000c`adaff2a0 00007ff9`08d22259 nvoglv64!DrvPresentBuffers+0xfca92
2c 0000000c`adaff700 00007ff9`08d2456c nvoglv64!vk_optimusGetInstanceProcAddr+0x252e9
2d 0000000c`adaff740 00007ff9`08d1e4ea nvoglv64!vk_optimusGetInstanceProcAddr+0x275fc
2e 0000000c`adaffac0 00007ff9`08e2ff05 nvoglv64!vk_optimusGetInstanceProcAddr+0x2157a
2f 0000000c`adaffb10 00007ff6`53b47941 nvoglv64!vkGetInstanceProcAddr+0xf7735
30 0000000c`adaffcb0 00007ff6`53b4952e VulkanGLFWDemo+0x7941
31 0000000c`adaffe70 00007ff6`53b42522 VulkanGLFWDemo+0x952e
32 0000000c`adaffec0 00007ffa`429e37b0 VulkanGLFWDemo+0x2522
33 0000000c`adaffef0 00007ffa`4389e8d7 ucrtbase!thread_start&amp;lt;unsigned int (__cdecl*)(void *),1&amp;gt;+0x30
34 0000000c`adafff20 00007ffa`4520c53c KERNEL32!BaseThreadInitThunk+0x17
35 0000000c`adafff50 00000000`00000000 ntdll!RtlUserThreadStart+0x2c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仍然有从nvida驱动最终转发给 intel驱动的调用。&lt;/p&gt;
&lt;h2 id="ai解释-1"&gt;AI解释
&lt;/h2&gt;&lt;h3 id="核心结论窗口创建和显示管理"&gt;核心结论：窗口创建和显示管理
&lt;/h3&gt;&lt;p&gt;即使您的最终渲染 API 是 Vulkan，您的程序在创建窗口和将 Vulkan 渲染结果&lt;strong&gt;呈现 (Present)&lt;/strong&gt; 到屏幕时，仍需要依赖底层的 OS/窗口管理系统。&lt;/p&gt;
&lt;p&gt;在 Windows 的双显卡系统上：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;D3D11/DXGI 接口被调用：&lt;/strong&gt; 许多现代窗口库（如 GLFW, SDL 等）在底层创建窗口表面时，或者为了与 Windows 的桌面合成管理器（DWM）更好地集成，会涉及到 D3D11 和 DXGI 的初始化路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Intel 驱动拥有显示输出权：&lt;/strong&gt; 由于 Intel iGPU 通常是&lt;strong&gt;直接连接&lt;/strong&gt;到笔记本电脑显示器的，所以任何与 &lt;strong&gt;显示适配器 (Adapter)&lt;/strong&gt; 相关的操作（如 DXGI 创建设备、枚举显示模式等），都会首先或默认涉及到 Intel 驱动程序（&lt;code&gt;igd10um64xe.dll&lt;/code&gt;），因为它管理着最终的像素输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;着色器缓存访问：&lt;/strong&gt; 在 D3D11/DXGI 初始化的过程中，Intel 驱动程序会执行标准操作，例如检查或创建其自身的着色器缓存目录 (&lt;code&gt;C:\Users\...\Intel\ShaderCache\&lt;/code&gt;)。这表明 &lt;strong&gt;Intel 驱动程序被加载并运行了初始化逻辑&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="方案尝试使用-vulkan-原生表面创建"&gt;方案：尝试使用 Vulkan 原生表面创建
&lt;/h3&gt;&lt;p&gt;如果您使用的是 GLFW 或 SDL，尝试查看是否可以在 Vulkan 初始化阶段&lt;strong&gt;之前&lt;/strong&gt;避免任何 WGL/DXGI 的调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于 GLFW 库：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在调用 &lt;code&gt;glfwInit()&lt;/code&gt; 之后、创建窗口之前，确保您明确告诉 GLFW &lt;strong&gt;不创建任何图形 API 上下文&lt;/strong&gt;，这将有助于跳过 WGL/OpenGL 或 D3D/DXGI 的早期初始化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;// 确保在创建窗口前设置以下提示
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;glfwWindowHint&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;GLFW_CLIENT_API&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; GLFW_NO_API&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;// 创建窗口
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;GLFWwindow&lt;span style="color:#0550ae"&gt;*&lt;/span&gt; window &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; glfwCreateWindow&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;WIDTH&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; HEIGHT&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;Vulkan App&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#cf222e"&gt;nullptr&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#cf222e"&gt;nullptr&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;目前AI提供的代码并没有用。因为目前出现问题的时候就是这么设置的。暂时卡在这里，后续可以考虑用windows原生API创建窗口，以及从堆栈看，可能d3d11可以做一些配置，避免其使用intel显卡&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>WinDbg的初级用法</title><link>https://crackhopper.github.io/notes/windbg%E7%9A%84%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 17 Nov 2025 22:05:20 +0800</pubDate><author>crackhopper@gmail.com (crackhopper)</author><guid>https://crackhopper.github.io/notes/windbg%E7%9A%84%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>&lt;p&gt;起因开始于 &lt;a class="link" href="https://crackhopper.github.io/2025/11/17/%E8%AE%B0%E5%BD%95%E8%B0%83%E8%AF%95vulkan%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8D%B0%E5%A5%87%E6%80%AA%E6%97%A5%E5%BF%97%E7%9A%84%E9%97%AE%E9%A2%98/" &gt;记录调试Vulkan程序打印奇怪日志的问题&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="正文开始"&gt;正文开始
&lt;/h1&gt;&lt;h2 id="简要介绍"&gt;简要介绍
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;WinDbg&lt;/strong&gt;（Windows Debugger）是 Microsoft 提供的强大调试工具，广泛应用于 Windows 系统的内核调试、用户模式调试、崩溃转储分析等场景。它适用于调试应用程序、驱动程序、操作系统内核等各种不同类型的程序。WinDbg 支持命令行界面，并且具有图形用户界面（WinDbg Preview），它能够帮助开发人员和系统管理员诊断并修复系统崩溃或程序错误。&lt;/p&gt;
&lt;h2 id="安装与启动-windbg"&gt;安装与启动 WinDbg
&lt;/h2&gt;&lt;p&gt;参考文档： &lt;a class="link" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/" target="_blank" rel="noopener"
&gt;https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-ps" data-lang="ps"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#6639ba"&gt;winget&lt;/span&gt; &lt;span style="color:#6639ba"&gt;install&lt;/span&gt; &lt;span style="color:#6639ba"&gt;Microsoft.WinDbg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;用windows的包管理器下载即可。（类似苹果的HomeBrew，windows下我一般除了 winget，还会用到 chocolate 和 scoop）&lt;/p&gt;
&lt;h2 id="启动调试"&gt;启动调试
&lt;/h2&gt;&lt;p&gt;点击文件：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://crackhopper.github.io/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763393136760.png"
loading="lazy"
alt="WinDbg的初级用法-1763393136760"
&gt;&lt;/p&gt;
&lt;p&gt;选项介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Launch executable : 直接启动一个exe，并且中断到最开始的地方。&lt;/li&gt;
&lt;li&gt;Launch executable (advanced) : 这个模式支持更多设置，包括运行参数(arguments)和运行目录(start directory) 。还支持 时间旅行调试 (Time Travel Debugging, TTD)&lt;/li&gt;
&lt;li&gt;Attach to process: 附加到已经在运行的进程上进行调试。&lt;/li&gt;
&lt;li&gt;Open dump file: 加载一个先前捕获的内存转储文件（crash dump）进行事后分析。&lt;/li&gt;
&lt;li&gt;Open trace file: 加载一个先前记录的 时间旅行调试 (TTD) 跟踪文件进行回放和分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们这里选择 Launch executable ，选择要调试的vulkan程序即可。&lt;/p&gt;
&lt;h2 id="时间旅行调试-ttd-time-travel-debugging"&gt;时间旅行调试 (TTD, Time Travel Debugging)
&lt;/h2&gt;&lt;p&gt;启动调试的时候，选择 &lt;code&gt;Launch executable(advanced)&lt;/code&gt; 。并勾选开启 Time Travel Debugging&lt;/p&gt;
&lt;p&gt;微软开发的一种革命性的调试技术。它允许开发者和逆向工程师&lt;strong&gt;记录&lt;/strong&gt;一个进程的执行过程，然后像观看视频一样，对这个记录进行&lt;strong&gt;回放&lt;/strong&gt;和&lt;strong&gt;反向调试&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;反向执行 (Reverse Execution)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可以在程序的执行时间轴上&lt;strong&gt;向后移动&lt;/strong&gt;。&lt;/td&gt;
&lt;td&gt;能够轻松地回溯到程序状态发生损坏、或导致崩溃的那个瞬间之前，准确找出问题的根源。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;完整记录 (Full Recording)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;捕获了程序执行过程中的所有状态变化，包括 CPU 寄存器、内存读写等。&lt;/td&gt;
&lt;td&gt;无需重现 Bug。一旦记录了 Bug 发生的过程，您可以无限次地回放和分析，而 Bug 不会再“跑掉”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;可重复性 (Reproducibility)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;调试会话基于记录文件，而不是实时运行的程序。&lt;/td&gt;
&lt;td&gt;调试过程是完全确定的，在不同的机器上、不同的时间点上分析结果始终一致，非常利于协作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;高级查询 (Advanced Query)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;允许使用查询语言（如 Linq）来搜索整个执行历史记录。&lt;/td&gt;
&lt;td&gt;可以快速找到“是谁最后写入了这个内存地址？”或“这个函数在哪里被调用过？”等复杂问题。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;非常好用，建议调试复杂问题的时候，先开启TTD录制一次。随后加载对应的trace文件。就可以用TTD调试了。在这个调试模式可以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g-&lt;/code&gt; : 跳到上一个断点（所以把所有断点 disable 或者清空后，可以直接跳到开头）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p-&lt;/code&gt; : 往回跳1个指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="常用寄存器"&gt;常用寄存器
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义 (x64)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@rcx&lt;/code&gt;, &lt;code&gt;@rdx&lt;/code&gt;, &lt;code&gt;@r8&lt;/code&gt;, &lt;code&gt;@r9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通用寄存器 （易失性）&lt;/td&gt;
&lt;td&gt;在windows x64下，函数调用前，这四个寄存器会保存函数调用的前4个参数。（使用的时候，可以不带 &lt;code&gt;@&lt;/code&gt; 符号)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@ip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;instruction pointer&lt;/td&gt;
&lt;td&gt;指向下一个要执行的指令。通常配合查看汇编代码的时候。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@rsp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;栈指针寄存器&lt;/td&gt;
&lt;td&gt;总是指向栈顶的地址。（地址越低，越靠近栈顶；函数开始调用前，会移动栈顶指针向低地址，以准备足够的栈空间用来存储局部变量）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@r14, r15&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通用寄存器（非易失性）&lt;/td&gt;
&lt;td&gt;常用于标识当前函数的栈帧起始位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ymm0, ymm1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;256位矢量寄存器&lt;/td&gt;
&lt;td&gt;avx指令集中的寄存器。AVX（Advanced Vector Extensions）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="内存的引用"&gt;内存的引用
&lt;/h2&gt;&lt;p&gt;一般采用 &lt;code&gt;[ expression ]&lt;/code&gt; 的方式引用一个内存地址。随后配合指令，决定读写的大小。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;expression&lt;/code&gt; 可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;寄存器 + 偏移&lt;/li&gt;
&lt;li&gt;基址 + 索引 * 缩放 + 偏移&lt;/li&gt;
&lt;li&gt;标号&lt;/li&gt;
&lt;li&gt;常量&lt;/li&gt;
&lt;li&gt;任意合法的组合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，有些指令需要内存对齐。否则产生GP异常（General Protection Fault，通用保护异常）。比如SSE，AVX指令。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;movaps xmm0, [rax] ; 需要 16 字节对齐，否则 #GP 异常
movdqa xmm1, [rax] ; 需要 16 字节对齐
vmovaps ymm0, [rax] ; rax 必须 32 字节对齐
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="指令集sseavx简介"&gt;指令集（SSE/AVX）简介
&lt;/h2&gt;&lt;p&gt;上一节中，提到的一些用比较特别寄存器的，都是扩展指令集的指令。这节简要介绍一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSE: Streaming SIMD Extensions 。Intel 在 &lt;strong&gt;1999 年&lt;/strong&gt; 发布的 SIMD（Single Instruction Multiple Data）扩展。使用 &lt;strong&gt;128 位的 XMM 寄存器（xmm0–xmm15）&lt;/strong&gt; ，提供浮点加速。通常需要对齐。&lt;/li&gt;
&lt;li&gt;AVX: Advanced Vector Extensions 。Intel 在 &lt;strong&gt;2011 年&lt;/strong&gt; 推出的 SSE 进化版。 使用 &lt;strong&gt;256 位 YMM 寄存器（ymm0–ymm15 / ymm31）&lt;/strong&gt;。具备无需对齐的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多高阶指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AVX2（2013）： 整数 SIMD，Gather 指令，更强的向量整数操作（如 vpblendd、vpmulld）。&lt;/li&gt;
&lt;li&gt;AVX-512（2016）：寄存器扩大到 &lt;strong&gt;512 位的 ZMM0–31&lt;/strong&gt;。掩码寄存器（k0–k7），更丰富的数学指令（如 exp/log），分段化（Foundation / BW / VL / VNNI / IFMA 等）。应用：HPC（科学计算），AI 推理（VNNI），数据中心服务器（Xeon 里普遍支持）&lt;/li&gt;
&lt;li&gt;VNNI（Vector Neural Network Instructions）： 属于 AVX-512 家族（也有 AVX2 版本）。专为 AI 推理优化：提供更快的 dot-product（点积）运算，用于 INT8/INT16 加速。&lt;/li&gt;
&lt;li&gt;AMX（Advanced Matrix Extensions）(2021)：&lt;strong&gt;矩阵加速器&lt;/strong&gt;，不是传统 SIMD 了。Tile 寄存器（矩阵寄存器）、Tile 配置指令、Tile DP（矩阵乘加）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些跟处理器相关。通常消费级处理器，没有AMX。&lt;/p&gt;
&lt;h2 id="常用指令"&gt;常用指令
&lt;/h2&gt;&lt;h3 id="first-of-all"&gt;First of All
&lt;/h3&gt;&lt;p&gt;用 &lt;code&gt;.hh &amp;lt;x&amp;gt;&lt;/code&gt; 指令可以查看 &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; 指令的文档。&lt;/p&gt;
&lt;h3 id="执行控制和断点"&gt;执行控制和断点
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;完整形式/别名&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;g&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;go&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;继续执行&lt;/strong&gt;。程序将从当前位置继续运行直到遇到断点或退出。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;p&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;step&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;步过 (Step Over)&lt;/strong&gt;。执行下一条指令。如果下一条是函数调用，则执行完整个函数再停下。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;p&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;t&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;步入 (Step Into)&lt;/strong&gt;。执行下一条指令。如果下一条是函数调用，则进入该函数内部并停在第一条指令。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;bp&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Set Breakpoint&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;设置软件断点&lt;/strong&gt;。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bp MyModule!MyFunction&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;ba&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Set Access Breakpoint&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;设置访问断点（硬件断点）&lt;/strong&gt;。用于监视内存地址的读、写或执行。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ba w8 @rcx&lt;/code&gt; (在 &lt;code&gt;@rcx&lt;/code&gt; 地址上设置 8 字节的写访问断点)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;bl&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List Breakpoints&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;列出&lt;/strong&gt; 当前设置的所有断点。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bl&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;bc&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Clear Breakpoints&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;清除&lt;/strong&gt; 指定编号的断点。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bc 0&lt;/code&gt; (清除编号为 0 的断点)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;be&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Enable Breakpoints&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;启用&lt;/strong&gt; 指定编号的断点。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;be 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;bd&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Disable Breakpoints&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;禁用&lt;/strong&gt; 指定编号的断点。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bd 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重中之重：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bp, ba&lt;/code&gt; : 调试必备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意， &lt;code&gt;bl,bc,be,bd&lt;/code&gt; 在UI上操作更方便。&lt;/p&gt;
&lt;h3 id="内存检查"&gt;内存检查
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;db&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Byte (字节)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;显示&lt;/strong&gt; 字节数据 (1 字节/8 位)。同时显示十六进制和 ASCII 字符。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;db 0x180000000&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;dw&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Word (字)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;显示&lt;/strong&gt; 字数据 (2 字节/16 位)。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dw @rcx&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;dd&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Double-Word (双字)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;显示&lt;/strong&gt; 双字数据 (4 字节/32 位)。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dd @rsp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;dq&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Quad-Word (四字)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;显示&lt;/strong&gt; 四字数据 (8 字节/64 位)。&lt;strong&gt;x64 环境下最常用&lt;/strong&gt;。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dq @rcx&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;da&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ASCII String&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;显示&lt;/strong&gt; 内存中的 &lt;strong&gt;ASCII&lt;/strong&gt; 字符串。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;da @rdx&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;du&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;UNICODE String&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;显示&lt;/strong&gt; 内存中的 &lt;strong&gt;UNICODE&lt;/strong&gt; (UTF-16) 字符串。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;du @rcx&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="上下文与符号信息-context--symbol"&gt;上下文与符号信息 (Context &amp;amp; Symbol)
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;别名&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;r&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;registers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;查看/修改&lt;/strong&gt; 寄存器的值。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;r&lt;/code&gt; (查看所有) 或 &lt;code&gt;r rcx=0x123&lt;/code&gt; (修改 &lt;code&gt;rcx&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;k&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;kb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;显示栈回溯 (Stack Backtrace)&lt;/strong&gt;。这是最常用的调试命令之一。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;k&lt;/code&gt; 或 &lt;code&gt;kb&lt;/code&gt; (后者会显示栈上前4个QWORD)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;lm&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;list modules&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;列出&lt;/strong&gt; 当前加载的所有模块（DLL/EXE）。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lm&lt;/code&gt; 或 &lt;code&gt;lm v&lt;/code&gt; (显示详细信息)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;x&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;examine symbols&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;检查&lt;/strong&gt; 指定模块内的符号（函数名、变量名）。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x MyModule!*&lt;/code&gt; (列出 MyModule 的所有符号)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;?&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;evaluate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;计算&lt;/strong&gt; 表达式的值。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;? 0x10 + @r8&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lmv m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查看具体模块的详细信息&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lmv m vulkan_1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;x&lt;/code&gt; 指令，支持通配符。可以先用来查询模块中可以使用的符号。（有些带有pdb信息的，有些无pdb信息的仍然有导出库的符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 指令看寄存器的时候，可以指定格式。例如 &lt;code&gt;r ymm1:uq&lt;/code&gt; 。具体参照文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="断点设定示例"&gt;断点设定示例
&lt;/h2&gt;&lt;p&gt;考虑在文件创建的时候打断点。&lt;/p&gt;
&lt;h3 id="createfilea-和-createfilew-函数"&gt;CreateFileA 和 CreateFileW 函数
&lt;/h3&gt;&lt;p&gt;这两个是windows的api函数，用来创建文件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;CreateFileA (ANSI 版本)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;CreateFileW (Unicode 版本)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;字符串类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;接受 &lt;strong&gt;ANSI/多字节&lt;/strong&gt; 字符串。&lt;/td&gt;
&lt;td&gt;接受 &lt;strong&gt;Unicode&lt;/strong&gt; (UTF-16) 字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;主要用于&lt;strong&gt;较老&lt;/strong&gt;或非 Unicode 环境的程序。&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;现代 Windows 应用程序的主流&lt;/strong&gt;，支持全球语言字符集。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;内部机制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要在内部将 ANSI 转换为 Unicode 才能交给系统内核处理，有轻微性能开销。&lt;/td&gt;
&lt;td&gt;直接使用 Unicode，无需转换，&lt;strong&gt;效率更高，更可靠&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="createfile函数参数"&gt;CreateFile函数参数
&lt;/h3&gt;&lt;p&gt;两个函数调用的参数是类似的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;5
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;6
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;7
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;8
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;HANDLE &lt;span style="color:#6639ba"&gt;CreateFileW&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; LPCWSTR lpFileName&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0550ae"&gt;//&lt;/span&gt; &lt;span style="color:#0550ae"&gt;1.&lt;/span&gt; &lt;span style="color:#f6f8fa;background-color:#82071e"&gt;文件名&lt;/span&gt; &lt;span style="color:#1f2328"&gt;(&lt;/span&gt;W版本使用 LPCWSTR&lt;span style="color:#1f2328"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; DWORD dwDesiredAccess&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 2. 期望的访问权限
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwShareMode&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 3. 文件共享模式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; LPSECURITY_ATTRIBUTES lpSecurityAttributes&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 4. 安全属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwCreationDisposition&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#57606a"&gt;// 5. 创建/打开的方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwFlagsAndAttributes&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 6. 文件属性和标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; HANDLE hTemplateFile &lt;span style="color:#57606a"&gt;// 7. 模板文件句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;期望的访问权限：主要传入 &lt;code&gt;GENERIC_READ|GENERIC_WRITE|GENERIC_EXECUTE|0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件共享模式: 决定其他程序是否可以打开同一个文件。 &lt;code&gt;0|FILE_SHARED_READ|FILE_SHARED_WRITE|FILE_SHARED_DELETE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安全属性: 主要是权限控制&lt;/li&gt;
&lt;li&gt;创建/打开的方式 : 当文件存在或者不存在的时候如何处理。&lt;strong&gt;非常关键&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CREATE_NEW&lt;/code&gt; ：创建新文件。如果文件已存在，则失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CREATE_ALWAYS&lt;/code&gt; ：创建新文件。如果文件已存在，则覆盖并清空。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPEN_EXISTING&lt;/code&gt; ：打开现有文件。如果文件不存在则失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPEN_ALWAYS&lt;/code&gt; ：打开现有文件。如果文件不存在则创建。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件属性和标志：设置隐藏文件、只读文件等等。&lt;/li&gt;
&lt;li&gt;模板文件句柄：按照模板文件来创建文件，继承其属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="windows-x64调用约定"&gt;Windows x64调用约定
&lt;/h3&gt;&lt;p&gt;在 Windows x64 架构下，微软规定使用 &lt;strong&gt;Fastcall&lt;/strong&gt; 调用约定，它要求函数的前四个非浮点数参数通过特定的通用寄存器传递，而不是通过栈传递。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;参数序号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;寄存器&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;WinDbg 伪寄存器&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;第一个参数 (Param 1)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;RCX&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;通用寄存器 C&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@rcx&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;第二个参数 (Param 2)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;RDX&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;通用寄存器 D&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@rdx&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;第三个参数 (Param 3)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;R8&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;通用寄存器 R8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@r8&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;第四个参数 (Param 4)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;R9&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;通用寄存器 R9&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@r9&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;第五个及后续参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;栈 (Stack)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;从栈上获取参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dq @rsp + 0x28&lt;/code&gt; / &lt;code&gt;dq @rsp + 0x30&lt;/code&gt; 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;回顾 &lt;code&gt;CreateFileW&lt;/code&gt; 的前四个参数：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;lpFileName&lt;/code&gt; $\rightarrow$ &lt;strong&gt;&lt;code&gt;@rcx&lt;/code&gt;&lt;/strong&gt; (文件名指针)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dwDesiredAccess&lt;/code&gt; $\rightarrow$ &lt;strong&gt;&lt;code&gt;@rdx&lt;/code&gt;&lt;/strong&gt; (访问权限 DWORD)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dwShareMode&lt;/code&gt; $\rightarrow$ &lt;strong&gt;&lt;code&gt;@r8&lt;/code&gt;&lt;/strong&gt; (共享模式 DWORD)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lpSecurityAttributes&lt;/code&gt; $\rightarrow$ &lt;strong&gt;&lt;code&gt;@r9&lt;/code&gt;&lt;/strong&gt; (安全属性指针)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，您在 WinDbg 中查看参数时，总是使用 &lt;code&gt;du @rcx&lt;/code&gt; 或 &lt;code&gt;? @rdx&lt;/code&gt; 等命令。&lt;/p&gt;
&lt;h1 id="实操演练"&gt;实操演练
&lt;/h1&gt;&lt;p&gt;我们的目标是找到异常写日志的代码。选择一个合适的方式，加载exe启动后，看到如下页面。&lt;/p&gt;
&lt;p&gt;启动对应exe：
&lt;img src="https://crackhopper.github.io/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763395254791.png"
loading="lazy"
alt="WinDbg的初级用法-1763395254791"
&gt;&lt;/p&gt;
&lt;h2 id="初始页面讲解"&gt;初始页面讲解
&lt;/h2&gt;&lt;h3 id="模块加载信息"&gt;模块加载信息
&lt;/h3&gt;&lt;h4 id="主程序"&gt;主程序
&lt;/h4&gt;&lt;pre tabindex="0"&gt;&lt;code&gt;ModLoad: 00007ff7`f70b0000 00007ff7`f70fa000 image00007ff7`f70b0000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加载主程序。名称image后面跟着的是虚拟内存地址，意味着程序被加载到这个内存位置上。主程序永远是第一个被加载的。&lt;/p&gt;
&lt;p&gt;查看主程序模块：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; lm a 00007ff7`f70b0000
Browse full module list
start end module name
00007ff7`f70b0000 00007ff7`f70fa000 VulkanGLFWDemo C (no symbols)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;lm&lt;/code&gt; (List Modules):&lt;/strong&gt; 基本命令，用于显示模块信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;a&lt;/code&gt; (Address):&lt;/strong&gt; 这是一个子命令或限定符，意思是**&amp;ldquo;按地址过滤&amp;rdquo;**。它告诉 WinDbg &lt;strong&gt;只显示包含这个特定地址的模块&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;地址用 $`$ 分隔 : 分隔内存地址的高位和低位部分是为了&lt;strong&gt;提高可读性和清晰度&lt;/strong&gt;，尤其是在处理 &lt;strong&gt;64 位 (8 字节)&lt;/strong&gt; 地址时 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="其他模块简要介绍"&gt;其他模块简要介绍
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ntdll.dll&lt;/code&gt; : &lt;strong&gt;Windows NT 层的核心库&lt;/strong&gt;。它提供用户模式程序到内核模式驱动程序和函数的接口，是所有 Windows 进程的基石。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KERNEL32.DLL&lt;/code&gt; : 提供基本的 &lt;strong&gt;操作系统服务&lt;/strong&gt;，如内存管理、进程和线程管理、文件 I/O 等。它是 Windows 编程中最重要的 DLL 之一。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KERNELBASE.dll&lt;/code&gt; : 包含 &lt;code&gt;KERNEL32.DLL&lt;/code&gt; 的许多底层函数实现。在现代 Windows 中，许多核心 API 调用被路由到这里。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER32.dll&lt;/code&gt; : 负责管理用户界面元素，如&lt;strong&gt;窗口、菜单、对话框&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;win32u.dll&lt;/code&gt; : 包含底层用户模式的图形和窗口管理函数，是 &lt;code&gt;USER32.dll&lt;/code&gt; 和 &lt;code&gt;GDI32.dll&lt;/code&gt; 的&lt;strong&gt;更底层实现&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vulkan-1.dll&lt;/code&gt; : 这是一个&lt;strong&gt;图形 API 库&lt;/strong&gt;。它表明你的程序正在使用 &lt;strong&gt;Vulkan&lt;/strong&gt; 图形 API，这通常用于高性能的 3D 游戏或渲染应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="为什么是这个加载顺序"&gt;为什么是这个加载顺序？
&lt;/h4&gt;&lt;p&gt;任何 Windows 进程启动，都需要两个最基本的 DLL 来与内核交互和管理自身。因此，它们总是最先被加载，并且顺序非常固定：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;顺序&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;模块&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;职责和原因&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;主程序 (&lt;code&gt;VulkanGLFWDemo C&lt;/code&gt; / &lt;code&gt;image...&lt;/code&gt;)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;原因：&lt;/strong&gt; 它是被执行的文件。加载器首先将 EXE 文件映射到进程的虚拟地址空间，并开始解析它的导入表（Import Table）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;ntdll.dll&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;原因：&lt;/strong&gt; 这是所有用户模式代码访问内核服务（&lt;code&gt;ntoskrnl.exe&lt;/code&gt;）的&lt;strong&gt;唯一网关&lt;/strong&gt;。任何更高层的 DLL，包括 &lt;code&gt;KERNEL32.DLL&lt;/code&gt;，都必须通过 &lt;code&gt;ntdll.dll&lt;/code&gt; 来工作。它必须在其他所有依赖内核的模块之前加载。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;KERNEL32.DLL&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;原因：&lt;/strong&gt; 它是提供进程、内存、文件等基本 API 的高级层。它自身依赖于 &lt;code&gt;ntdll.dll&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;KERNELBASE.dll&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;原因：&lt;/strong&gt; 它是 &lt;code&gt;KERNEL32.DLL&lt;/code&gt; 的底层实现库。现代 Windows 将 &lt;code&gt;KERNEL32&lt;/code&gt; 的许多实际功能移到了 &lt;code&gt;KERNELBASE&lt;/code&gt; 中，以提高效率和隔离性。它紧随其后的加载，是为了满足 &lt;code&gt;KERNEL32&lt;/code&gt; 启动时的依赖。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在基础的系统服务加载完成后，加载器会继续加载主程序&lt;strong&gt;导入表&lt;/strong&gt;中列出的下一组核心依赖项，通常是与用户界面 (UI) 相关的库：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;顺序&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;模块&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;职责和原因&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;USER32.dll&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;原因：&lt;/strong&gt; 主程序是一个图形应用（基于 &lt;code&gt;Vulkan&lt;/code&gt;），所以它需要窗口管理 API。&lt;code&gt;USER32.dll&lt;/code&gt; 是管理窗口、消息和对话框的关键。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;6.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;win32u.dll&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;原因：&lt;/strong&gt; 类似 &lt;code&gt;KERNELBASE&lt;/code&gt; 和 &lt;code&gt;KERNEL32&lt;/code&gt; 的关系，&lt;code&gt;win32u.dll&lt;/code&gt; 是 &lt;code&gt;USER32.dll&lt;/code&gt; 的底层实现，用于处理用户模式和内核模式之间的用户界面切换。它在 &lt;code&gt;USER32&lt;/code&gt; 之后加载，因为它被 &lt;code&gt;USER32&lt;/code&gt; 所依赖。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;7.&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;GDI32.dll&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;原因：&lt;/strong&gt; 图形设备接口库，负责绘图、字体等。它通常是与 &lt;code&gt;USER32&lt;/code&gt; 捆绑在一起加载的，用于提供图形界面所需的基本绘制能力。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="ui配置"&gt;UI配置
&lt;/h3&gt;&lt;p&gt;页面中的View选项可以调出很多好用的窗口。根据自己的需求配置即可。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://crackhopper.github.io/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763519564490.png"
loading="lazy"
alt="WinDbg的初级用法-1763519564490"
&gt;&lt;/p&gt;
&lt;p&gt;随后可以拖拽窗口，dock到自己喜欢的位置上。&lt;/p&gt;
&lt;h3 id="第一个中断"&gt;第一个中断
&lt;/h3&gt;&lt;pre tabindex="0"&gt;&lt;code&gt;(4d30.26a4): Break instruction exception - code 80000003 (first chance)
ntdll!LdrpDoDebuggerBreak+0x35:
00007ff8`9503f5fd cc int 3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;进程线程信息：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;4d30&lt;/code&gt;&lt;/strong&gt;: 进程 ID (PID)，十六进制表示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;26a4&lt;/code&gt;&lt;/strong&gt;: 线程 ID (TID)，十六进制表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异常类型和状态：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Break instruction exception&lt;/code&gt;&lt;/strong&gt;: &lt;strong&gt;异常类型：&lt;/strong&gt; &lt;strong&gt;中断指令异常&lt;/strong&gt;。这意味着 CPU 遇到了一个专门用于触发调试中断的指令。&lt;/li&gt;
&lt;li&gt;code 80000003： &lt;strong&gt;异常代码：&lt;/strong&gt; 这是 Windows 中 &lt;strong&gt;硬编码断点&lt;/strong&gt;（Hardcoded Breakpoint）的异常代码。这个代码通常是由 &lt;code&gt;int 3&lt;/code&gt;（汇编指令）触发的。在 Windows 进程启动或调试器接管时，系统会故意执行这个指令，以确保调试器能在程序真正开始运行前获得控制权。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;暂停位置：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ntdll!LdrpDoDebuggerBreak+0x35&lt;/code&gt;&lt;/strong&gt;: &lt;strong&gt;模块与函数：&lt;/strong&gt; 程序当前暂停在 &lt;code&gt;ntdll.dll&lt;/code&gt; 模块中的 &lt;code&gt;LdrpDoDebuggerBreak&lt;/code&gt; 函数内，偏移量为 &lt;code&gt;+0x35&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;00007ff8`9503f5fd&lt;/code&gt; : &lt;strong&gt;内存地址：&lt;/strong&gt; 异常发生的具体指令地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cc&lt;/code&gt; 机器码。对应的汇编为 &lt;code&gt;int 3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="命令窗口-0000"&gt;命令窗口 &lt;code&gt;0:000&amp;gt;&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;命令提示符格式: &lt;code&gt;P:T&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P: 代表正在调试的处理器编号（CPU编号）。&lt;/li&gt;
&lt;li&gt;T: 代表正在调试的线程编号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命令窗口后面可以输出上面我们介绍过的调试指令。&lt;/p&gt;
&lt;h2 id="添加断点"&gt;添加断点
&lt;/h2&gt;&lt;p&gt;命令行里输入如下命令&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;bp kernel32!CreateFileA;
bp kernel32!CreateFileW;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;右下角面板可以打开 Breakpoint 选项卡：
&lt;img src="https://crackhopper.github.io/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763396928280.png"
loading="lazy"
alt="WinDbg的初级用法-1763396928280"
&gt;&lt;/p&gt;
&lt;p&gt;随后可以输入命令：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动程序运行。&lt;/p&gt;
&lt;p&gt;注意，断点另一个常见的用法是，后面接中断触发后执行的指令，比如：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;bp kernel32!CreateFileW &amp;#34;du rcx;&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个断点中断后，会以 unicode字符串的方式打印 rcx指针指向的地址。这是非常常用的技巧。&lt;/p&gt;
&lt;h2 id="中断到createfile"&gt;中断到CreateFile
&lt;/h2&gt;&lt;p&gt;下面进入我们第一次中断的情况：
&lt;img src="https://crackhopper.github.io/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763397056640.png"
loading="lazy"
alt="WinDbg的初级用法-1763397056640"
&gt;&lt;/p&gt;
&lt;h3 id="寄存器观察"&gt;寄存器观察
&lt;/h3&gt;&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; r
rax=000000000000005c rbx=0000000000000000 rcx=00000073ac18c1b0
rdx=0000000080000000 rsi=0000022a13050f00 rdi=000000000000005c
rip=00007ff893b970f0 rsp=00000073ac18c168 rbp=00000073ac18c270
r8=0000000000000001 r9=0000000000000000 r10=0000022a13050f5c
r11=00000073ac18c1b0 r12=0000000000000000 r13=00000073ac18c310
r14=0000000000000000 r15=00000073ac18c1b0
iopl=0 nv up ei pl zr na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246
KERNEL32!CreateFileW:
00007ff8`93b970f0 ff25ea270300 jmp qword ptr [KERNEL32!_imp_CreateFileW (00007ff8`93bc98e0)] ds:00007ff8`93bc98e0={KERNELBASE!CreateFileW (00007ff8`922f3ac0)}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回忆API接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;5
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;6
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;7
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;8
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;HANDLE &lt;span style="color:#6639ba"&gt;CreateFileW&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; LPCWSTR lpFileName&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0550ae"&gt;//&lt;/span&gt; &lt;span style="color:#0550ae"&gt;1.&lt;/span&gt; &lt;span style="color:#f6f8fa;background-color:#82071e"&gt;文件名&lt;/span&gt; &lt;span style="color:#1f2328"&gt;(&lt;/span&gt;W版本使用 LPCWSTR&lt;span style="color:#1f2328"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; DWORD dwDesiredAccess&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 2. 期望的访问权限
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwShareMode&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 3. 文件共享模式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; LPSECURITY_ATTRIBUTES lpSecurityAttributes&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 4. 安全属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwCreationDisposition&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#57606a"&gt;// 5. 创建/打开的方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwFlagsAndAttributes&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 6. 文件属性和标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; HANDLE hTemplateFile &lt;span style="color:#57606a"&gt;// 7. 模板文件句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;函数入参：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rcx&lt;/code&gt; : 第一个参数。&lt;code&gt;lpFileName&lt;/code&gt; (文件名地址)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdx&lt;/code&gt; : 第二个参数。&lt;code&gt;dwDesiredAccess&lt;/code&gt; (期望访问权限) 。$0x80000000$ 对应 &lt;code&gt;GENERIC_READ&lt;/code&gt;。这表示程序&lt;strong&gt;只请求读取权限&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r8&lt;/code&gt;: 第三个参数： &lt;code&gt;dwShareMode&lt;/code&gt; (共享模式)。 &lt;code&gt;0x1&lt;/code&gt; 对应 &lt;code&gt;FILE_SHARE_READ&lt;/code&gt;。这意味着其他进程在文件打开时&lt;strong&gt;可以同时拥有读取权限&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r9&lt;/code&gt;: 第四个参数： &lt;code&gt;lpSecurityAttributes&lt;/code&gt; (安全属性) 。0代表不使用安全属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数返回：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rax&lt;/code&gt; : &lt;strong&gt;返回值寄存器&lt;/strong&gt; 。 在调用前，&lt;code&gt;RAX&lt;/code&gt; 的值不确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制/指针寄存器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rip&lt;/code&gt; : &lt;strong&gt;Instruction Pointer (指令指针)&lt;/strong&gt;。指向当前 CPU 正在执行的下一条指令的地址，即 &lt;code&gt;KERNEL32!CreateFileW&lt;/code&gt; 的入口点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsp&lt;/code&gt; : &lt;strong&gt;Stack Pointer (栈指针)&lt;/strong&gt;。指向当前线程栈的顶部。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rbp&lt;/code&gt; : &lt;strong&gt;Base Pointer (基址指针)&lt;/strong&gt;。通常用于标记当前函数栈帧的底部。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="易失性和非易失性寄存器"&gt;易失性和非易失性寄存器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rbx&lt;/code&gt; : &lt;strong&gt;非易失性（Non-Volatile）寄存器&lt;/strong&gt;，也称为&lt;strong&gt;被调用者保存（Callee-Saved）&lt;/strong&gt; 寄存器。程序员和编译器通常用 $RBX$ 来存储在整个函数执行过程中需要保持不变的 &lt;strong&gt;重要本地变量&lt;/strong&gt;或 &lt;strong&gt;指针&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsi/rdi&lt;/code&gt; : 同上。在旧的 x86 架构中，它们传统上用作源索引（Source Index）和目标索引（Destination Index），常用于字符串和内存块操作。x64架构中，则类似 &lt;code&gt;rbx&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;同样非易失性寄存器有： &lt;code&gt;rbx, rbp, rsi, rdi, r12, r13, r14, r15&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;而易失性寄存器有： &lt;code&gt;rcx, rdx,r8,r9 r10, r11&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="状态和段寄存器不太常用"&gt;状态和段寄存器（不太常用）
&lt;/h4&gt;&lt;p&gt;状态和段寄存器解读：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;iopl=0 nv up ei pl zr na po nc
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;iopl=0&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义：&lt;/strong&gt; &lt;strong&gt;I/O Privilege Level (I/O 特权级别)&lt;/strong&gt;。这是一个 2 位的字段，用于控制当前代码是否可以直接执行 I/O 指令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值：&lt;/strong&gt; $0$ 是最高的特权级别（通常是内核模式，Ring 0）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;nv &amp;hellip;.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;含义 &lt;strong&gt;RFLAGS&lt;/strong&gt; (Registers Flags)，它包含了控制 CPU 操作和指示上次运算结果的各种标志位。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;缩写&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;nv&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Overflow Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;nv&lt;/strong&gt; (No Overflow)&lt;/td&gt;
&lt;td&gt;上一次运算没有发生溢出。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;up&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Direction Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;up&lt;/strong&gt; (Up)&lt;/td&gt;
&lt;td&gt;字符串操作（如移动数据）的方向是从低地址到高地址（递增）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ei&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Interrupt Enable Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ei&lt;/strong&gt; (Enable Interrupts)&lt;/td&gt;
&lt;td&gt;CPU &lt;strong&gt;允许&lt;/strong&gt;接收外部可屏蔽中断信号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;pl&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Sign Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;pl&lt;/strong&gt; (Positive)&lt;/td&gt;
&lt;td&gt;上一次算术运算的结果是非负数（或零）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;zr&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Zero Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;zr&lt;/strong&gt; (Zero)&lt;/td&gt;
&lt;td&gt;上一次算术或逻辑运算的结果是&lt;strong&gt;零&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;na&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Auxiliary Carry Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;na&lt;/strong&gt; (Not Applicable)&lt;/td&gt;
&lt;td&gt;辅助进位标志，主要用于 BCD (Binary-Coded Decimal) 运算，通常不显示具体状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;po&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Parity Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;po&lt;/strong&gt; (Parity Odd)&lt;/td&gt;
&lt;td&gt;上一次运算结果的低 8 位中，置位（1）的个数是奇数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;nc&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Carry Flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;nc&lt;/strong&gt; (No Carry)&lt;/td&gt;
&lt;td&gt;上一次算术运算没有产生进位或借位。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;cs=0033 &amp;hellip;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;段寄存器（Segment Registers）。x64架构中，主要用于定义&lt;strong&gt;特权级别&lt;/strong&gt;和访问一些特殊结构（如线程本地存储）。在x86架构中，段寄存器主要是辅助地址选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;寄存器&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释 (x64 Windows)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;cs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0033&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Code Segment&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;代码段。段选择子 $0x33$ 对应于**用户模式（User Mode, Ring 3）**代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ss&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;002b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Stack Segment&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;栈段。段选择子 $0x2B$ 对应于**用户模式（User Mode, Ring 3）**数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ds&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;002b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Data Segment&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;数据段。与 SS 相同，对应于用户模式数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;es&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;002b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Extra Segment&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;附加段。与 SS/DS 相同，对应于用户模式数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;fs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0053&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;FS Segment&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;特殊用途&lt;/strong&gt;。在 64 位 Windows 中，$FS$ 寄存器指向&lt;strong&gt;线程信息块 (TEB)&lt;/strong&gt;，用于访问线程特定的数据（如异常处理、栈限制等）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;gs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;002b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;GS Segment&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;特殊用途&lt;/strong&gt;。在 64 位 Windows 中，$GS$ 寄存器通常指向 &lt;strong&gt;KPCR (内核处理器控制区)&lt;/strong&gt;，但用户模式下它的使用较少或被重定义。这里的值 $0x2B$ 可能只是一个占位符。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="更多函数参数的观察"&gt;更多函数参数的观察
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;5
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;6
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;7
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;8
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;HANDLE &lt;span style="color:#6639ba"&gt;CreateFileW&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; LPCWSTR lpFileName&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0550ae"&gt;//&lt;/span&gt; &lt;span style="color:#0550ae"&gt;1.&lt;/span&gt; &lt;span style="color:#f6f8fa;background-color:#82071e"&gt;文件名&lt;/span&gt; &lt;span style="color:#1f2328"&gt;(&lt;/span&gt;W版本使用 LPCWSTR&lt;span style="color:#1f2328"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; DWORD dwDesiredAccess&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 2. 期望的访问权限
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwShareMode&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 3. 文件共享模式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; LPSECURITY_ATTRIBUTES lpSecurityAttributes&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 4. 安全属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwCreationDisposition&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#57606a"&gt;// 5. 创建/打开的方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; DWORD dwFlagsAndAttributes&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 6. 文件属性和标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt; HANDLE hTemplateFile &lt;span style="color:#57606a"&gt;// 7. 模板文件句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;lpFileName&lt;/code&gt; 下面的值显示为一个字符串。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;du @rcx
00000073`ac18c1b0 &amp;#34;C:\WINDOWS\System32\DriverStore\&amp;#34;
00000073`ac18c1f0 &amp;#34;FileRepository\nvmi.inf_amd64_c6&amp;#34;
00000073`ac18c230 &amp;#34;ae241e95feb82d\nv-vk64.json&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;code&gt;dwDesiredAccess&lt;/code&gt; : 注意，不能用 dw, db等指令，这些指令会解析参数为地址。如果是直接看寄存器的值，用r指令。下面的值显示为 &lt;code&gt;GENERIC_READ&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; r @rdx
rdx=0000000080000000
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;code&gt;dwShareMode&lt;/code&gt; ： &lt;code&gt;r @r8&lt;/code&gt; 结果为 &lt;code&gt;0x1&lt;/code&gt; 即 &lt;code&gt;FILE_SHARE_READ&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="4"&gt;
&lt;li&gt;&lt;code&gt;lpSecurityAttributes&lt;/code&gt; ： 先用r来看地址是否为空。 &lt;code&gt;r @r9&lt;/code&gt; 。结果为0。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="关于-db-dw-dd-dq"&gt;关于 &lt;code&gt;db, dw, dd, dq&lt;/code&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BYTE&lt;/code&gt; : 8字节 。因此， &lt;code&gt;db&lt;/code&gt; 会把内存按照8字节切分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WORD&lt;/code&gt; : 16字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DWORD&lt;/code&gt; : 32字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QWORD&lt;/code&gt; : 64字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="关于寄存器"&gt;关于寄存器
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;WinDbg 默认将寄存器名称视为其&lt;/strong&gt;存储的 &lt;strong&gt;值&lt;/strong&gt; 。因此比如 &lt;code&gt;dd rcx&lt;/code&gt; 实际上将rcx的值作为dd的参数。dd的参数需要使用到一个地址，因此实际会解析 rcx 存储值所指向的地址，而不是rcx的值。&lt;/p&gt;
&lt;p&gt;所以要注意： &lt;strong&gt;寄存器在 windbg 中被当作值来使用；而指令后面的参数常常作为地址来解析&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="栈上参数"&gt;栈上参数
&lt;/h4&gt;&lt;p&gt;接着，对于5，6，7参数，都保存在栈上。对于栈上来说，约定有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;相对地址（相对于 RSP）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;长度 (字节)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;CreateFileW 参数&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x00}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;返回地址&lt;/strong&gt;（Return Address）&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&amp;mdash; 32 字节阴影空间（Shadow Space）开始 &amp;mdash;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x08}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;阴影空间槽位 1&lt;/td&gt;
&lt;td&gt;（用于保存 $\text{RCX}$ 的副本）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x10}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;阴影空间槽位 2&lt;/td&gt;
&lt;td&gt;（用于保存 $\text{RDX}$ 的副本）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x18}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;阴影空间槽位 3&lt;/td&gt;
&lt;td&gt;（用于保存 $\text{R8}$ 的副本）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x20}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;阴影空间槽位 4&lt;/td&gt;
&lt;td&gt;（用于保存 $\text{R9}$ 的副本）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&amp;mdash; 32 字节阴影空间（Shadow Space）结束 &amp;mdash;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x28}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;第 5 个参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dwCreationDisposition&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x30}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;第 6 个参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dwFlagsAndAttributes&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\mathbf{RSP + 0x38}$&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;第 7 个参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hTemplateFile&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;阴影空间&lt;/strong&gt; : 其实是按照规范，所有参数都应该在栈上。不过windows会放入寄存器，因此这些栈上空间就相当于被留空了。（实际会保存副本）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调用参数的存储位置&lt;/strong&gt; (正偏移): 一般在 &lt;code&gt;rsp&lt;/code&gt; 向高地址的方向去找，每次64位（即8byte）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;局部变量&lt;/strong&gt; (负偏移): 一般在 rsp 向低地址的方向去找，每次64位。所以，第一个局部变量位置在 &lt;code&gt;rsp-0x08&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="5"&gt;
&lt;li&gt;&lt;code&gt;dwCreateionDisposition&lt;/code&gt; : dw 代表 &lt;code&gt;DWORD&lt;/code&gt; ，因此用dd指令。容易看到第一个值为 &lt;code&gt;0x03&lt;/code&gt; ，对应 &lt;code&gt;OPEN_EXISTING&lt;/code&gt; ，即打开一个文件或设备。如果文件或设备不存在，函数将失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; dd rsp+0x28
00000073`ac18c190 00000003 00000073 00000080 00000000
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol start="6"&gt;
&lt;li&gt;&lt;code&gt;dwCreateionDisposition&lt;/code&gt; 从上一步的结果也容易看到这个参数为 &lt;code&gt;0x80&lt;/code&gt; (注意，每64bit一个参数，因此 &lt;code&gt;00000073&lt;/code&gt; 被跳过，随后是 &lt;code&gt;00000080&lt;/code&gt; ，即 &lt;code&gt;0x80&lt;/code&gt; ) ，对应值为 &lt;code&gt;FILE_ATTRIBUTE_NORMAL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="7"&gt;
&lt;li&gt;&lt;code&gt;hTemplateFile&lt;/code&gt; ，这个参数是HANDLE类型，通常是指针，在 64位程序中，就是8个字节，用dq命令来看。容易看到结果为空。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; dq @rsp+0x38
00000073`ac18c1a0 00000000`00000000 00000000`00000000
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="函数代码的观察"&gt;函数代码的观察
&lt;/h2&gt;&lt;p&gt;断点处，我们可以看到&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;KERNEL32!CreateFileW:
00007ff8`93b970f0 ff25ea270300 jmp qword ptr [KERNEL32!_imp_CreateFileW (00007ff8`93bc98e0)] ds:00007ff8`93bc98e0={KERNELBASE!CreateFileW (00007ff8`922f3ac0)}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个代表下一步要执行的指令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;00007ff8`93b970f0&lt;/code&gt; : 当前指令的地址。&lt;/li&gt;
&lt;li&gt;指令 &lt;code&gt;ff25ea270300&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="指令的解读-ff25ea270300"&gt;指令的解读 &lt;code&gt;ff25ea270300&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;拆分为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ff25&lt;/code&gt; : &lt;code&gt;jmp qword ptr [RIP+displacement]&lt;/code&gt; 这个操作码（OPCODE）。意思是，以当前 &lt;code&gt;RIP&lt;/code&gt; （当前指令地址） 作为基地址，叠加 displacement 偏移量后，得到的地址按照QWORD解析，并作为地址进一步跳转到其指向的位置。（因此涉及到一次跳转）
&lt;ul&gt;
&lt;li&gt;这个跳转通常叫做 IAT （操作系统和指令层都实现的概念：Import Address Table，导入地址表）&lt;/li&gt;
&lt;li&gt;IAT这个技术用来做动态链接。提供一个间接层，程序在自己的内存空间设置一张指针表。那么通过IAT跳转指令 &lt;code&gt;jmp qword ptr&lt;/code&gt; （间接跳转指令），就会进一步解码这个表中指向的地址，从而实现RIP的计算、解码加跳转。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ea270300&lt;/code&gt; ：4个byte，偏移量。因为是 Little Endian，所以代表的值为 &lt;code&gt;0x000327ea&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;计算间接跳转地址 &lt;code&gt;00007ff8`93b970f0&lt;/code&gt; + &lt;code&gt;0x000327ea&lt;/code&gt; = &lt;code&gt;00007ff8`93bc98e0&lt;/code&gt; 。这个地址是IAT表的地址。因此按照里面的值，进一步查找地址，得到 &lt;code&gt;00007ff8`922f3ac0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示区域的 &lt;code&gt;ds:00007ff8`93bc98e0={KERNELBASE!CreateFileW (00007ff8`922f3ac0)}&lt;/code&gt; 显示的是IAT表项的地址。不过并不代表使用了段寄存器，而是反汇编工具的约定，是一个注释，表明它访问的是数据内存（IAT表）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="真正的代码位置"&gt;真正的代码位置
&lt;/h4&gt;&lt;p&gt;经过上面的分析，我们知道，真正的要执行的代码的位置在 &lt;code&gt;00007ff8`922f3ac0&lt;/code&gt; ，其对应的符号表的符号为 &lt;code&gt;KERNELBASE!CreateFileW&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="函数地址和符号"&gt;函数地址和符号
&lt;/h4&gt;&lt;p&gt;函数地址在调试的时候，经常有与之相关的符号：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; ln 00007ff8`922f3ac0
Browse module
Set bu breakpoint
(00007ff8`922f3ac0) KERNELBASE!CreateFileW | (00007ff8`922f3ba0) KERNELBASE!SleepEx
Exact matches:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到地址对应的符号为 &lt;code&gt;KERNELBASE!CreateFileW&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;反之，也可以从符号找到对应的地址：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; ln KERNELBASE!CreateFileW
Browse module
Set bu breakpoint
(00007ff8`922f3ac0) KERNELBASE!CreateFileW | (00007ff8`922f3ba0) KERNELBASE!SleepEx
Exact matches:
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="符号和地址如何关联的呢"&gt;符号和地址如何关联的呢？
&lt;/h4&gt;&lt;p&gt;答案：通过调试信息文件。windows自己加载了对应的调试信息。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; lm m kernelbase
Browse full module list
start end module name
00007ff8`922b0000 00007ff8`926a8000 KERNELBASE (pdb symbols) C:\ProgramData\Dbg\sym\kernelbase.pdb\8314490F996705E2CF4A8DF59DF277DB1\kernelbase.pdb
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="如何知道我们自己程序的调试符号表有没有加载"&gt;&lt;strong&gt;如何知道我们自己程序的调试符号表有没有加载？&lt;/strong&gt;
&lt;/h4&gt;&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; lm m VulkanGLFWDemo
Browse full module list
start end module name
00007ff7`f70b0000 00007ff7`f70fa000 VulkanGLFWDemo C (no symbols)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到没有加载。这是由于我们用的时release无符号版本的程序。（当然，release也可以配置生成pdb调试信息）&lt;/p&gt;
&lt;h4 id="如何查看具体汇编代码指令方式"&gt;&lt;strong&gt;如何查看具体汇编代码&lt;/strong&gt;（指令方式）
&lt;/h4&gt;&lt;pre tabindex="0"&gt;&lt;code&gt;0:000&amp;gt; u KERNELBASE!CreateFileW L10
KERNELBASE!CreateFileW:
00007ff8`922f3ac0 488bc4 mov rax,rsp
00007ff8`922f3ac3 48895808 mov qword ptr [rax+8],rbx
00007ff8`922f3ac7 48896810 mov qword ptr [rax+10h],rbp
00007ff8`922f3acb 48897018 mov qword ptr [rax+18h],rsi
00007ff8`922f3acf 48897820 mov qword ptr [rax+20h],rdi
00007ff8`922f3ad3 4156 push r14
00007ff8`922f3ad5 4883ec50 sub rsp,50h
00007ff8`922f3ad9 448bb42480000000 mov r14d,dword ptr [rsp+80h]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; ： unassemble，反汇编&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L8&lt;/code&gt; : 8行 。注意 L后面跟的是16进制数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面来具体解释这里面的汇编干了什么&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;地址&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;机器码&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;汇编指令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3ac0}$&lt;/td&gt;
&lt;td&gt;$\text{488bc4}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;mov rax,rsp&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将当前的栈指针 $\text{RSP}$ 的值备份到 $\text{RAX}$。&lt;/td&gt;
&lt;td&gt;暂时保存栈指针，以便在 $\text{RSP}$ 被后续指令修改后，仍能通过 $\text{RAX}$ 访问原始栈帧（特别是阴影空间）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3ac3}$&lt;/td&gt;
&lt;td&gt;$\text{48895808}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;mov qword ptr [rax+8],rbx&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将 $\text{RBX}$ 寄存器的值保存到 $\text{RAX}+0\text{x}08$ 处。&lt;/td&gt;
&lt;td&gt;保存 &lt;strong&gt;非易失性&lt;/strong&gt; 寄存器 $\text{RBX}$。该地址是 $\text{RSP}+0\text{x}08$，即&lt;strong&gt;阴影空间&lt;/strong&gt;的第一个槽位。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3ac7}$&lt;/td&gt;
&lt;td&gt;$\text{48896810}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;mov qword ptr [rax+10h],rbp&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将 $\text{RBP}$ 的值保存到 $\text{RAX}+0\text{x}10$ 处。&lt;/td&gt;
&lt;td&gt;保存 &lt;strong&gt;非易失性&lt;/strong&gt; 寄存器 $\text{RBP}$（基址指针）。这是阴影空间的第二个槽位。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3acb}$&lt;/td&gt;
&lt;td&gt;$\text{48897018}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;mov qword ptr [rax+18h],rsi&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将 $\text{RSI}$ 的值保存到 $\text{RAX}+0\text{x}18$ 处。&lt;/td&gt;
&lt;td&gt;保存 &lt;strong&gt;非易失性&lt;/strong&gt; 寄存器 $\text{RSI}$。这是阴影空间的第三个槽位。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3acf}$&lt;/td&gt;
&lt;td&gt;$\text{48897820}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;mov qword ptr [rax+20h],rdi&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将 $\text{RDI}$ 的值保存到 $\text{RAX}+0\text{x}20$ 处。&lt;/td&gt;
&lt;td&gt;保存 &lt;strong&gt;非易失性&lt;/strong&gt; 寄存器 $\text{RDI}$。这是阴影空间的第四个槽位。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3ad3}$&lt;/td&gt;
&lt;td&gt;$\text{4156}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;push r14&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将 $\text{R14}$ 寄存器的值压入栈中。&lt;/td&gt;
&lt;td&gt;保存 &lt;strong&gt;非易失性&lt;/strong&gt; 寄存器 $\text{R14}$。这会使 $\text{RSP}$ 减去 $0\text{x}08$。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3ad5}$&lt;/td&gt;
&lt;td&gt;$\text{4883ec50}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;sub rsp,50h&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将 $\text{RSP}$ 减去 $0\text{x}50$ ($80$ 字节)。&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;分配局部变量和后续函数调用所需的栈帧空间。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\text{922f3ad9}$&lt;/td&gt;
&lt;td&gt;$\text{448bb42480000000}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;mov r14d,dword ptr [rsp+80h]&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将 $\text{RSP} + 0\text{x}80$ 处的 4 字节数据加载到 $\text{R14D}$（$\text{R14}$ 的低 32 位）。&lt;/td&gt;
&lt;td&gt;访问栈上参数或调用者栈帧中的局部变量。$0\text{x}80$ 是相对于&lt;strong&gt;调整后的 $\text{RSP}$&lt;/strong&gt; 的大偏移量。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似 &lt;code&gt;r14d&lt;/code&gt; ，还有 &lt;code&gt;eax, ebx, ecx&lt;/code&gt; 分别代表 &lt;code&gt;rax, rbx, rcx&lt;/code&gt; 的低32位&lt;/li&gt;
&lt;li&gt;更多代码内容，从汇编分析，就比较费时间和偏离主题了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="如何查看具体汇编代码ui方式"&gt;&lt;strong&gt;如何查看具体汇编代码&lt;/strong&gt;（UI方式）
&lt;/h4&gt;&lt;p&gt;可以打开 Disaseembly 面板。（当然如果有源代码+pdb文件，甚至可以直接打开源代码，类似普通在 vscode 中调试一样）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://crackhopper.github.io/images/WinDbg%e7%9a%84%e5%88%9d%e7%ba%a7%e7%94%a8%e6%b3%95-1763521358979.png"
loading="lazy"
alt="WinDbg的初级用法-1763521358979"
&gt;&lt;/p&gt;
&lt;h1 id="ttd指令"&gt;TTD指令
&lt;/h1&gt;&lt;p&gt;time travel 模式下，有一些便捷指令。尤其常用 &lt;code&gt;!tt&lt;/code&gt; 和 &lt;code&gt;!tt &amp;lt;position&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt; tt 0 - Time travel to the beginning of the trace (percentage)
tt 50 - Time travel to halfway through the trace (percentage)
tt 100 - Time travel to the end of the trace (percentage)
tt 13.56 - Time travel to 13.56% through the trace
tt 1A0: - Time travel to position 1A0:0
tt 1A0:0 - Time travel to position 1A0:0
tt 1A0:12F - Time travel to position 1A0:12F
tt 1A0000000000000012F - Time travel to position 1A0:12F
tt br rax - Time travel to the next write to RAX
tt br- rax 0x12345678 - Time travel to the previous write to RAX with the value 0x12345678
tt ba- rw 0x12345678 0x4000 - Find previous position that reads or writes from memory range
[0x12345678 - 0x12345678 + 0x4000).
tt ba e 0x7fffe0001234 0x30000 - Find next position that executes from specified range. If the
address and range represent the range of ntdll.dll, this command
would find the next position where ntdll.dll is entered.
tt bm - Time travel to the next instruction that is in a different module
than current instruction&amp;#39;s module.
tt bm- ntdll.dll - Time travel to the previous instruction that is in ntdll.dll
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，在ttd模式下，还可以用 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p-&lt;/code&gt; ： 回退一步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g-&lt;/code&gt; ： 回退到上一个缎带你&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="todo-未来有空再进一步研究"&gt;TODO: (未来有空再进一步研究)
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;memory leak调试&lt;/li&gt;
&lt;li&gt;脚本：NatVis&lt;/li&gt;
&lt;li&gt;脚本：javascript&lt;/li&gt;
&lt;li&gt;以及更多学习资料： &lt;a class="link" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-resources" target="_blank" rel="noopener"
&gt;https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-resources&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>